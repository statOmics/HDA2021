<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Lieven Clement" />


<title>2. Singular Value Decomposition</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">HDDA21</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-chalkboard-teacher"></span>
     
    Lectures
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="intro.html">1. Introduction</a>
    </li>
    <li>
      <a href="svd.html">2. Singular Value Decomposition</a>
    </li>
    <li>
      <a href="svdGeometricInterpretation.html">2.3. Geometric Interpretation SVD</a>
    </li>
    <li>
      <a href="MDS_linkGramDistanceMatrix.html">2.7. Link MDS and Gram Distance Matrix</a>
    </li>
    <li>
      <a href="prediction.html">3. Prediction with High Dimensional Predictors</a>
    </li>
    <li>
      <a href="sparseSvd.html">4. Sparse Singular Value Decomposition</a>
    </li>
    <li>
      <a href="lda.html">5. Linear Discriminant Analysis</a>
    </li>
    <li>
      <a href="lsi.html">6. Large Scale Inference</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-laptop"></span>
     
    Labs
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Coming soon!</li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/statOmics/HDDA21">
    <span class="fab fa-github"></span>
     
  </a>
</li>
<li>
  <a href="http://statomics.github.io/">statOmics</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">2. Singular Value Decomposition</h1>
<h4 class="author">Lieven Clement</h4>
<h4 class="date">statOmics, Ghent University (<a href="https://statomics.github.io" class="uri">https://statomics.github.io</a>)</h4>

</div>


<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<div id="motivation" class="section level2">
<h2><span class="header-section-number">1.1</span> Motivation</h2>
<p>The SVD is one of the most well used and general purpose tools from linear algebra for data processing!</p>
<p>Methodologically</p>
<ul>
<li>Dimension reduction (e.g. images, gene expression data, movie preferences)</li>
<li>Used as a first step in many data reduction and machine learning approaches</li>
<li>Taylor a coordinate system based on the data we have</li>
<li>Solve system of linear equations for non-square matrices: e.g. linear regression</li>
<li>Basis for principal component analysis (PCA) and multidimensional scaling (MDS).
<ul>
<li>PCA is one of the most widely used methods to study high dimensional data and to understand them in terms of their dominant patterns and correlations</li>
</ul></li>
</ul>
<p>Applications:</p>
<ul>
<li>At the heart of search engines: Google</li>
<li>Basis of many facial recognition methods: e.g. Facebook</li>
<li>Recommender systems such as Amazon and Netflix</li>
<li>A standard tool for data exploration and dimension reduction in Genomics</li>
</ul>
</div>
<div id="disclaimer" class="section level2">
<h2><span class="header-section-number">1.2</span> Disclaimer</h2>
<p>When you want to run the script you will have to comment out the eval=FALSE statement in some R chunks. Because the SVD takes a while on the faces example we save the svd for later use. So you have to comment the eval=FALSE statement in this chunk when you run the script for the first time.</p>
</div>
<div id="data" class="section level2">
<h2><span class="header-section-number">1.3</span> Data</h2>
<ul>
<li>Extended Yale Face Database B</li>
<li>Cropped and aligned images of 38 individuals under 64 lighting conditions.</li>
<li>Each image is 192 pixels tall and 168 pixels wide.</li>
<li>Each of the facial images in our library will be reshaped into a large vector with 192 × 168 = 32 256 elements.</li>
<li>We will use the 64 images of 36 people to build our models</li>
</ul>
<pre class="r"><code>library(pixmap)
library(tidyverse)
library(gridExtra)
library(grid)
library(ggmap)
library(downloader)
library(imager)</code></pre>
<pre class="r"><code>## Download and unzip data
if(!dir.exists(&quot;raw-data&quot;)) dir.create(&quot;raw-data&quot;)
download(
  &quot;https://github.com/statOmics/HDA2020/raw/data/yalefaces_cropped.zip&quot;,
  destfile = &quot;raw-data/yalefaces_cropped.zip&quot;, mode = &quot;wb&quot;, quiet = TRUE
)
unzip (&quot;raw-data/yalefaces_cropped.zip&quot;, exdir = &quot;./raw-data&quot;)

dir &lt;- &quot;./raw-data/CroppedYale&quot;</code></pre>
<pre class="r"><code>people &lt;- list.files(dir)
people2 &lt;- sapply(people,
  function(x) list.files(
    paste0(dir,&quot;/&quot;,x),
    full.names=TRUE
    )
  )

facesList &lt;- lapply(people2, function(x) read.pnm(x))

 grid.arrange(
  grobs=lapply(facesList[1+(0:35)*64],
     function(x) getChannels(x) %&gt;%
        ggimage(.,coord_equal=TRUE)
        ),
  ncol=6)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
</div>
<div id="method" class="section level2">
<h2><span class="header-section-number">1.4</span> Method</h2>
<p>Let <span class="math inline">\(\mathbf{X}\)</span> be an <span class="math inline">\(n\times p\)</span> matrix e.g.</p>
<ul>
<li>gene expression of <span class="math inline">\(p=40 000\)</span> genes for <span class="math inline">\(n=30\)</span> subjects</li>
<li>n = 100 000 000 webpages indexed with p search terms, or</li>
<li><span class="math inline">\(n\)</span> images each stored as a <span class="math inline">\(p=32 256\)</span> vector with the intensity of each pixel</li>
</ul>
<!-- Need "emo" package for emojis, install with -->
<!-- `devtools::install_github("hadley/emo")` -->
<p><strong>Note:</strong> the emoji characters will not be visible in the PDF output.</p>
<p><span class="math display">\[X=
\left[\begin{array}{ccc}
-&amp;\mathbf{x}_{1}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{x}_{i}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{x}_{n}^T &amp;- \\
\end{array}\right]_{n \times p}
\begin{array}{c}
💇\\\\
👮\\
\\
👸\\
\end{array}
\]</span></p>
<p>The data matrix <span class="math inline">\(\mathbf{X}\)</span> can be decomposed with the SVD into 3 matrices:</p>
<p><span class="math display">\[
\mathbf{X}=\mathbf{U}_{n\times n}\boldsymbol{\Delta}_{n\times p}\mathbf{V}^T_{p \times p}
\]</span></p>
<ul>
<li><p>an orthonormal matrix <span class="math inline">\(\mathbf{U}_{n\times n}\)</span> with left singular vectors: <span class="math inline">\(\mathbf{u}_j^T \mathbf{u}_k=1\)</span> if <span class="math inline">\(k=j\)</span> and <span class="math inline">\(\mathbf{u}_j^T \mathbf{u}_k=0\)</span> if <span class="math inline">\(j\neq k\)</span>, i.e. <span class="math display">\[ \mathbf{U}^T\mathbf{U}=\mathbf{I}\]</span></p></li>
<li><p>a matrix <span class="math inline">\(\boldsymbol{\Delta}_{n\times p}\)</span> with only singular values: the singular values <span class="math inline">\(\delta_i\)</span> are the only non-zero elements of the matrix and are on the diagonal element <span class="math inline">\([\boldsymbol{\Delta}]_{ii}\)</span>. They are also organised so that <span class="math inline">\(\delta_1 &gt; \delta_2 &gt; \ldots &gt; \delta_r\)</span>.</p></li>
<li><p>an orthonormal matrix <span class="math inline">\(\mathbf{V}_{p\times p}\)</span> with right singular vectors: <span class="math inline">\(\mathbf{v}_j^T \mathbf{v}_k=1\)</span> if <span class="math inline">\(k=j\)</span> and <span class="math inline">\(\mathbf{v}_j^T \mathbf{v}_k=0\)</span> if <span class="math inline">\(j\neq k\)</span> otherwise, i.e. <span class="math display">\[ \mathbf{V}^T\mathbf{V}=\mathbf{I}\]</span></p></li>
</ul>
<p>Note, that there are only <span class="math inline">\(r\)</span> non-zero singular values, with <span class="math inline">\(r\)</span> the rank of matrix <span class="math inline">\(X\)</span>: <span class="math inline">\(r \leq \text{min}(n,p)\)</span>. So we have <span class="math inline">\(k=1 \ldots r\)</span> non-zero singular values. Hence, we can also rewrite the approximation by restricting us to the rank of matrix <span class="math inline">\(\mathbf{X}\)</span>. Indeed, the n times p matrix <span class="math inline">\(\boldsymbol\Delta\)</span> only contains <span class="math inline">\(r\)</span> non-zero diagonal elements!</p>
<ul>
<li>So <span class="math display">\[
\mathbf{X}=\mathbf{U}_{n\times r}\boldsymbol{\Delta}_{r\times r}\mathbf{V}^T_{p \times r}
\]</span></li>
</ul>
<p><span class="math display">\[
\left[\begin{array}{ccc}
-&amp;\mathbf{x}_{1}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{x}_{i}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{x}_{n}^T &amp;- \\
\end{array}\right]_{n \times p}
=
\left[\begin{array}{ccc}
\mid&amp;&amp;\mid\\
\mathbf{u}_1&amp;\ldots&amp;\mathbf{u}_r\\
\mid&amp;&amp;\mid
\end{array}\right]_{n \times r}
\left[\begin{array}{ccc}
\delta_1\\
&amp;\ddots&amp;\\
&amp;&amp;\delta_r\\
\end{array}\right]_{r \times r}
\left[\begin{array}{ccc}
\mid&amp;&amp;\mid\\
\mathbf{v}_1&amp;\ldots&amp;\mathbf{v}_r\\
\mid&amp;&amp;\mid\\
\end{array}
\right]^T_{p \times r}
\]</span></p>
<p>Also note that <span class="math display">\[
\mathbf{V}^T=\left[\begin{array}{ccc}
-&amp;\mathbf{v}_{1}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{v}_{r}^T &amp;- \\
\end{array}\right]_{r \times p}
\]</span></p>
<ul>
<li><p>For high dimensional data <span class="math inline">\(p&gt;&gt;&gt;n\)</span> <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(\text{max}(r)=n\)</span> and</p></li>
<li><p>equivalently for multivariate data with <span class="math inline">\(n&gt;p\)</span> <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(\text{max}(r)=p\)</span></p></li>
</ul>
<p>We can also rewrite the decomposition using the properties of matrix multiplication</p>
<p><span class="math display">\[\begin{eqnarray}
\mathbf{X} &amp;=&amp; \delta_1\left[
\begin{array}{c}
\mid\\
\mathbf{u}_1\\
\mid
\end{array}
\right]
\begin{array}{c}
\left[
\begin{array}{ccc}
-&amp;
\mathbf{v}_1^T&amp;
-
\end{array}
\right]\\\quad\\\quad
\end{array}
+ \ldots +
\delta_r\left[
\begin{array}{c}
\mid\\
\mathbf{u}_r\\
\mid
\end{array}
\right]
\begin{array}{c}
\left[
\begin{array}{ccc}
-&amp;
\mathbf{v}_r^T&amp;
-
\end{array}
\right]\\\quad\\\quad
\end{array}\\
\mathbf{X} &amp;=&amp; \sum_{k=1}^r \delta_k\mathbf{u}_k\mathbf{v}_k^T
\end{eqnarray}\]</span></p>
<ul>
<li><p>Because both <span class="math inline">\(\mathbf{U}\)</span> and <span class="math inline">\(\mathbf{V}\)</span> are orthonormal all their <span class="math inline">\(r\)</span> vectors are having unit length and they are thus reshaped by the singular values.</p></li>
<li><p>Hence, the singular values determine the importance of the rank one matrices <span class="math inline">\(\delta_k\mathbf{u}_k\mathbf{v}_k^T\)</span> in the reconstruction of the matrix <span class="math inline">\(\mathbf{X}\)</span> and they are ordered so that <span class="math inline">\(\delta_1 &gt; \ldots &gt; \delta_r\)</span>.</p></li>
</ul>
<p>Note, that for symmetric matrices <span class="math inline">\(\mathbf{X}\)</span> <span class="math inline">\(\longrightarrow\)</span> <span class="math inline">\(\mathbf{U} = \mathbf{V}\)</span>.</p>
</div>
<div id="interpretation-of-singular-vectors-face-example" class="section level2">
<h2><span class="header-section-number">1.5</span> Interpretation of singular vectors: face example</h2>
<div id="convert-images-to-vectors" class="section level3">
<h3><span class="header-section-number">1.5.1</span> Convert images to vectors</h3>
<ol style="list-style-type: decimal">
<li>Convert images to vectors and store them as a matrix
<ul>
<li>We use an <code>sapply</code> loop to loop over all faces</li>
<li>We extract the grey intensities from the pictures</li>
<li>We convert the matrix in a long skinny vector (<code>c</code>)</li>
<li>We transpose the resulting matrix from sapply</li>
</ul></li>
</ol>
<pre class="r"><code>allFacesMx &lt;- sapply(facesList,
                     function(x)
                        getChannels(x) %&gt;% c
                     ) %&gt;% t
dim(allFacesMx)</code></pre>
<pre><code>## [1]  2432 32256</code></pre>
<p>Save memory by removing facesList object</p>
<pre><code>rm(facesList)
gc()</code></pre>
<p>Hence we obtain a matrix for n = 2432 images with p = 32256 intensities for each pixel of an image.</p>
<p>Before we do the svd we typically center the data by substracting the average of the columns, i.e. the average face.</p>
<p>We will only work with the first 36 people: <span class="math inline">\(n = 36 \times 64 = 2304\)</span> pictures.</p>
<pre class="r"><code>allFacesCenteredMx &lt;- allFacesMx[1:(36*64),]
meanFace &lt;- colMeans(allFacesCenteredMx)

allFacesMxCentered &lt;- allFacesCenteredMx -
  matrix(1, nrow=nrow(allFacesCenteredMx), ncol=1) %*% matrix(meanFace,nrow=1)</code></pre>
</div>
<div id="visualisation-of-mean-image" class="section level3">
<h3><span class="header-section-number">1.5.2</span> Visualisation of mean image</h3>
<pre class="r"><code>plotFaceVector &lt;- function(faceVector,nrow=192,ncol=168) {
  matrix(faceVector,nrow=nrow,ncol=ncol) %&gt;%
  ggimage()
}

meanFace %&gt;%
  plotFaceVector</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
</div>
<div id="svd" class="section level3">
<h3><span class="header-section-number">1.5.3</span> SVD</h3>
<div id="perform-svd-in-r" class="section level4">
<h4><span class="header-section-number">1.5.3.1</span> Perform SVD in R</h4>
<ol style="list-style-type: decimal">
<li>We adopt svd on the centered matrix</li>
<li>We cache the result because the calculation takes 10 minutes.</li>
</ol>
<pre class="r"><code>faceSvd &lt;- svd(allFacesMxCentered)</code></pre>
<!-- ```{r, eval=FALSE} -->
<!-- ## Run this code manually to store the SVD for later re-use -->
<!-- saveRDS(faceSvd, file = "faceSvd.rds") -->
<!-- ``` -->
<!-- ```{r, eval=FALSE} -->
<!-- ## Run this code manually to reload the SVD result -->
<!-- faceSvd <- readRDS("faceSvd.rds") -->
<!-- ``` -->
</div>
<div id="svd-1" class="section level4">
<h4><span class="header-section-number">1.5.3.2</span> SVD</h4>
<p>Dimensions of <span class="math inline">\(\mathbf{U}\)</span>, <span class="math inline">\(\mathbf{V}\)</span>?</p>
<pre class="r"><code>n &lt;- nrow(allFacesCenteredMx)
p &lt;- ncol(allFacesCenteredMx)
dim(faceSvd$u)</code></pre>
<pre><code>## [1] 2304 2304</code></pre>
<pre class="r"><code>dim(faceSvd$v)</code></pre>
<pre><code>## [1] 32256  2304</code></pre>
<p>Indeed, for the face example <span class="math inline">\(n&lt;p\)</span> so <span class="math inline">\(r=n\)</span></p>
<p>Check orthogonality?</p>
<p>We do not do it for all vectors because it takes too long. First left eigen vector and second left eigenvector. Happens in <span class="math inline">\(\mathbf{U}^T\mathbf{U}\)</span></p>
<pre class="r"><code>t(faceSvd$u[,1])%*%faceSvd$u[,1]</code></pre>
<pre><code>##      [,1]
## [1,]    1</code></pre>
<pre class="r"><code>t(faceSvd$u[,1])%*%faceSvd$u[,2]</code></pre>
<pre><code>##               [,1]
## [1,] -3.794708e-19</code></pre>
<pre class="r"><code>t(faceSvd$u[,2])%*%faceSvd$u[,2]</code></pre>
<pre><code>##      [,1]
## [1,]    1</code></pre>
<p>So we see that the left eigenvectors are orthonormal.</p>
<p>We check if it also holds for the rows i.e. <span class="math inline">\(\mathbf{U}\mathbf{U}^T\)</span></p>
<pre class="r"><code>t(faceSvd$u[1,])%*%faceSvd$u[1,]</code></pre>
<pre><code>##      [,1]
## [1,]    1</code></pre>
<pre class="r"><code>t(faceSvd$u[2,])%*%faceSvd$u[1,]</code></pre>
<pre><code>##               [,1]
## [1,] -1.691355e-16</code></pre>
<pre class="r"><code>t(faceSvd$u[2,])%*%faceSvd$u[2,]</code></pre>
<pre><code>##      [,1]
## [1,]    1</code></pre>
<p>We also see that the rows of <span class="math inline">\(\mathbf{U}\)</span> are orthonormal.</p>
<pre class="r"><code>t(faceSvd$v[,1])%*%faceSvd$v[,1]</code></pre>
<pre><code>##      [,1]
## [1,]    1</code></pre>
<pre class="r"><code>t(faceSvd$v[,1])%*%faceSvd$v[,2]</code></pre>
<pre><code>##               [,1]
## [1,] -9.397551e-16</code></pre>
<pre class="r"><code>t(faceSvd$v[,2])%*%faceSvd$v[,2]</code></pre>
<pre><code>##      [,1]
## [1,]    1</code></pre>
<p>So we see that the right eigenvectors are orthonormal.</p>
<pre class="r"><code>t(faceSvd$v[1,])%*%faceSvd$v[1,]</code></pre>
<pre><code>##           [,1]
## [1,] 0.6181993</code></pre>
<pre class="r"><code>t(faceSvd$v[1,])%*%faceSvd$v[2,]</code></pre>
<pre><code>##            [,1]
## [1,] 0.07690404</code></pre>
<pre class="r"><code>t(faceSvd$v[2,])%*%faceSvd$v[2,]</code></pre>
<pre><code>##           [,1]
## [1,] 0.1017995</code></pre>
<p>This, however does not hold for the rows of <span class="math inline">\(\mathbf{V}\)</span>. This is because the matrix <span class="math inline">\(\mathbf{V}\)</span> no longer is a square matrix! <span class="math inline">\(r=n\)</span> and <span class="math inline">\(r&lt;p\)</span>!</p>
</div>
<div id="visualize-right-eigenvectors-mathbfv" class="section level4">
<h4><span class="header-section-number">1.5.3.3</span> Visualize right eigenvectors <span class="math inline">\(\mathbf{V}\)</span></h4>
<pre class="r"><code>grid.arrange(
 grobs=apply(
   faceSvd$v[,1:36],
   2,
   plotFaceVector
   )
 )</code></pre>
<pre><code>## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...
## rescaling mat to [0,1]...</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<ul>
<li><p>Hence, the right singular vectors (in <span class="math inline">\(\mathbf{V}\)</span> of <span class="math inline">\(\mathbf{X}=\mathbf{U}\boldsymbol{\Delta}\mathbf{V}\)</span>) are also faces and we can thus reconstruct the original faces by linear combinations of the eigen faces.</p></li>
<li><p>The first eigen faces are most important to capture overall patterns in the matrix.</p></li>
<li><p>Here it are mainly characteristics and shadows that are important for all faces.</p></li>
<li><p>From eigen face 5 onwards we start to see specific features.</p></li>
<li><p>In this case: <span class="math inline">\(n &lt; p\)</span>, so <span class="math inline">\(r = n\)</span>.</p></li>
</ul>
<p><span class="math display">\[
\mathbf{X}_{n\times p}=\mathbf{U}_{n \times n}\boldsymbol{\Delta}_{n\times n}\mathbf{V}_{p\times n}^T
\]</span></p>
<p><span class="math display">\[
\begin{array}{ccccc}
\left[\begin{array}{ccc}
-&amp;\mathbf{x}_{1}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{x}_{i}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{x}_{n}^T &amp;- \\
\end{array}\right]_{n \times p}
\begin{array}{c}
💇\\\\
👮\\
\\
👸\\
\end{array}
&amp;=&amp;
\begin{array}{c}
\quad\\
\left[\begin{array}{ccc}
\mid&amp;&amp;\mid\\
\mathbf{u}_1&amp;\ldots&amp;\mathbf{u}_n\\
\mid&amp;&amp;\mid
\end{array}\right]_{n \times n}\\
\quad \\
\end{array}
\begin{array}{c}
\quad\\
\left[\begin{array}{ccc}
\delta_1\\
&amp;\ddots&amp;\\
&amp;&amp;\delta_n\\
\end{array}\right]_{n \times n}\\
\quad\\
\end{array}
\begin{array}{c}
\quad
\left[\begin{array}{ccc}
\mid&amp;&amp;\mid\\
\mathbf{v}_1&amp;\ldots&amp;\mathbf{v}_n\\
\mid&amp;&amp;\mid\\
\end{array}
\right]^T_{p \times n}\\
\begin{array}{ccc}
😨&amp;\quad&amp;😐
\end{array}
\end{array}
\end{array}
\]</span></p>
<ul>
<li>Or upon transposing the matrix <span class="math inline">\(\mathbf{V}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{array}{ccccc}
\left[\begin{array}{ccc}
-&amp;\mathbf{x}_{1}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{x}_{i}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{x}_{n}^T &amp;- \\
\end{array}\right]_{n \times p}
\begin{array}{c}
💇\\\\
👮\\
\\
👸\\
\end{array}
&amp;=&amp;
\left[\begin{array}{ccc}
\mid&amp;&amp;\mid\\
\mathbf{u}_1&amp;\ldots&amp;\mathbf{u}_n\\
\mid&amp;&amp;\mid
\end{array}\right]_{n \times n}
\left[\begin{array}{ccc}
\delta_1\\
&amp;\ddots&amp;\\
&amp;&amp;\delta_r\\
\end{array}\right]_{n \times n}
\left[\begin{array}{ccc}
-&amp;\mathbf{v}_{1}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{v}_{p}^T &amp;- \\
\end{array}\right]_{n \times p}
\begin{array}{c}
😨\\
\\
😐
\end{array}
\end{array}
\]</span></p>
</div>
<div id="reconstruction-of-faces-via-linear-combination-of-eigen-faces." class="section level4">
<h4><span class="header-section-number">1.5.3.4</span> Reconstruction of faces via linear combination of eigen faces.</h4>
<p>In left singular vectors <span class="math inline">\(u_{ij}\)</span> we quantify the contribution of the <span class="math inline">\(j^\text{th}\)</span> eigenface in the reconstruction of face <span class="math inline">\(i\)</span> and we rescale the importance of each eigen face by its corresponding eigen value <span class="math inline">\(\delta_j\)</span>.</p>
<p><span class="math display">\[
\left[\begin{array}{ccc}
-&amp;\mathbf{x}_{1}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{x}_{i}^T &amp;- \\
\vdots&amp;\vdots&amp;\vdots\\
-&amp;\mathbf{x}_{n}^T &amp;- \\
\end{array}\right]_{n \times p}
\begin{array}{c}
💇\\\\
👮\\
\\
👸\\
\end{array} =
\delta_1\left[
\begin{array}{c}
\mid\\
\mathbf{u}_1\\
\mid
\end{array}
\right]
\begin{array}{c}
\left[
\begin{array}{ccc}
-&amp;
\mathbf{v}_1^T&amp;
-
\end{array}
\right]\\\quad\\\quad
\end{array}
\begin{array}{c}
😨
\\\quad\\\quad
\end{array}
+ \ldots +
\delta_r\left[
\begin{array}{c}
\mid\\
\mathbf{u}_r\\
\mid
\end{array}
\right]
\begin{array}{c}
\left[
\begin{array}{ccc}
-&amp;
\mathbf{v}_r^T&amp;
-
\end{array}
\right]\\\quad\\\quad
\end{array}
\begin{array}{c}
😐
\\\quad\\\quad
\end{array}
\]</span></p>
<p>If we truncate the eigen faces say at <span class="math inline">\(k&lt;r\)</span> we can approximate faces using a limited number of eigen faces!</p>
<pre class="r"><code>approximateFace &lt;- function(meanFace,faceSvd,k){
  reconstruct &lt;- (meanFace + faceSvd$u[1,1:k] %*%
    diag(faceSvd$d[1:k]) %*%
  t(faceSvd$v[,1:k]) %&gt;%
  c)
}

approxHlp &lt;- sapply(
      c(25,100,500),
      approximateFace,
      meanFace=meanFace,
      faceSvd=faceSvd)

grid.arrange(
 grobs=apply(
   cbind(
     approxHlp,
     allFacesMxCentered[1,]+meanFace
   ),
   2,
   plotFaceVector
   )
 )</code></pre>
<div class="figure">
<img src="svd_files/figure-html/unnamed-chunk-11-1.png" alt="approximation with 25 (top left),  100 (top right) and 500 (bottom left) eigenfaces and original face (bottom right, or with all eigenfaces)" width="672" />
<p class="caption">
approximation with 25 (top left), 100 (top right) and 500 (bottom left) eigenfaces and original face (bottom right, or with all eigenfaces)
</p>
</div>
</div>
</div>
</div>
</div>
<div id="svd-as-a-matrix-approximation-method" class="section level1">
<h1><span class="header-section-number">2</span> SVD as a Matrix Approximation Method</h1>
<ul>
<li><p>We have seen that we can use the truncted SVD to approximate matrix <span class="math inline">\(\mathbf{X}\)</span> by <span class="math inline">\(\tilde{\mathbf{X}}\)</span>, with <span class="math inline">\(k&lt;r\)</span> and <span class="math display">\[
\tilde{\mathbf{X}}=\mathbf{U}_{n\times k}\boldsymbol{\Delta}_{k\times k}\mathbf{V}_{p \times k}^T
\]</span></p></li>
<li><p>It can be shown that <strong>SVD: optimal approximation</strong></p>
<ul>
<li><p>Let <span class="math inline">\(\mathbf{X}\)</span> be an <span class="math inline">\(n\times p\)</span> matrix of rank <span class="math inline">\(r\leq \min(n,p)\)</span>, and let <span class="math inline">\(\mathbf{A}\)</span> denote an <span class="math inline">\(n \times p\)</span> matrix of rank <span class="math inline">\(k\leq r\)</span>, with elements denoted by <span class="math inline">\(a_{ij}\)</span>.</p></li>
<li><p>The matrix <span class="math inline">\(\mathbf{A}\)</span> of rank <span class="math inline">\(k\leq r\)</span> that minimises the Frobenius norm <span class="math display">\[
\vert\vert\mathbf{X}-\mathbf{A}\vert\vert^2_\text{fr}=\sum_{i=1}^n\sum_{j=1}^p (x_{ij}-a_{ij})^2
\]</span> is given by the truncated SVD <span class="math display">\[
 \mathbf{X}_k = \sum_{j=1}^k \delta_j \mathbf{u}_j\mathbf{v}_j^T.
\]</span></p></li>
<li><p>The truncated SVD has <span class="math inline">\(k &lt; r\)</span> terms. Hence, generally <span class="math inline">\(\mathbf{X}_k\)</span> does not coincide with <span class="math inline">\(\mathbf{X}\)</span>. It is considered as an approximation.</p></li>
<li><p>Note, that the truncated SVD thus approximates the matrix by minimising a kind of sum of least squared errors between the elements of matrix <span class="math inline">\(\mathbf{X}\)</span> and <span class="math inline">\(\mathbf{A}\)</span> and that</p></li>
<li><p>the truncated SVD <span class="math inline">\(\mathbf{X}_k\)</span> is the best rank-k approximation of <span class="math inline">\(\mathbf{X}\)</span> in terms of this Frobenius norm.</p></li>
<li><p>Also, note that upon truncation <span class="math display">\[\mathbf{V}^T_{p\times k} \mathbf{V}_{p\times k} = \mathbf{I}_{k\times k}\]</span> <span class="math display">\[\mathbf{U}^T_{n\times k} \mathbf{U}_{n\times k} = \mathbf{I}_{k\times k}\]</span></p></li>
<li><p>But, that <span class="math display">\[\mathbf{V}_{p\times k} \mathbf{V}_{p\times k}^T \neq \mathbf{I}_{p\times p}!!!\]</span> <span class="math display">\[\mathbf{U}_{n\times k} \mathbf{U}_{n\times k}^T \neq \mathbf{I}_{n\times n}!!!\]</span></p></li>
</ul></li>
</ul>
<hr />
<p>Some <strong>informal statement</strong> about the truncated SVD <span class="math display">\[
     \mathbf{X}_k = \sum_{j=1}^k \delta_j \mathbf{u}_j\mathbf{v}_j^T.
  \]</span></p>
<ul>
<li><p>It can be considered as a weighted sum of matrices <span class="math inline">\(\mathbf{u}_j\mathbf{v}_j^T\)</span>, with weights <span class="math inline">\(\delta_j\)</span>.</p></li>
<li><p>The terms are ordered with decreasing weights <span class="math inline">\(\delta_1\geq \delta_2 \geq \cdots \geq \delta_k &gt;0\)</span>.</p></li>
<li><p>The matrices <span class="math inline">\(\mathbf{u}_j\mathbf{v}_j^T\)</span> are of equal “magnitude” (constructed from normalised vectors).</p></li>
<li><p>Truncation at <span class="math inline">\(k\)</span> results in <span class="math inline">\(k\)</span> <span class="math inline">\(\delta_j\)</span>’s, <span class="math inline">\(k\times n\)</span> elements in the <span class="math inline">\(\mathbf{u}_j\)</span> and <span class="math inline">\(k \times p\)</span> elements in the <span class="math inline">\(\mathbf{v}_j\)</span>. Hence a total of <span class="math inline">\(k+kn+kp=k(1+n+p)\)</span> elements (usually much smaller than <span class="math inline">\(np\)</span>). (Note that restrictions apply to <span class="math inline">\(\mathbf{u}_j\)</span> and <span class="math inline">\(\mathbf{v}_j\)</span>; hence even less independent elements).</p></li>
</ul>
<p><span class="math inline">\(\longrightarrow\)</span> <strong>data compression</strong></p>
<div id="example-1-image-compression" class="section level2">
<h2><span class="header-section-number">2.1</span> Example 1: Image compression</h2>
<div id="painting-mondriaan-composition_no.iii-with-red-blue-yellow-and-black-1929." class="section level3">
<h3><span class="header-section-number">2.1.1</span> Painting Mondriaan: Composition_No.III with red, blue, yellow and black (1929).</h3>
<ul>
<li>Have a look at this painting of Mondriaan (1872 – 1944), here shown in black-and-white.</li>
</ul>
<div id="load-the-original-painting" class="section level4">
<h4><span class="header-section-number">2.1.1.1</span> Load the original painting</h4>
<ol style="list-style-type: decimal">
<li>fetch image from the web</li>
<li>convert into greyscale</li>
<li>plot</li>
<li>save as Matrix</li>
</ol>
<pre class="r"><code>mondriaan &lt;- load.image(&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/Piet_Mondrian_-_Composition_No._III%2C_with_red%2C_blue%2C_yellow_and_black%2C_1929.jpg/1920px-Piet_Mondrian_-_Composition_No._III%2C_with_red%2C_blue%2C_yellow_and_black%2C_1929.jpg&quot;)
mondriaan &lt;- grayscale(mondriaan)
plot(mondriaan,axes=FALSE)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r"><code>X &lt;- matrix(as.data.frame(mondriaan)[,3],nrow=nrow(mondriaan),ncol=ncol(mondriaan))</code></pre>
<ul>
<li><p>This picture can be represented as a <span class="math inline">\(1920 \times 1913`\)</span> matrix <span class="math inline">\(\mathbf{X}\)</span> with gray scale intensities <span class="math inline">\(\in [0,1]\)</span>. (<span class="math inline">\(\approx 4\times 10^6\)</span> data entries)</p></li>
<li><p>We will here not transform the image in a vector, but will look at the performance of the SVD to compress this image. The SVD can be applied to any matrix!</p></li>
</ul>
</div>
<div id="singular-values" class="section level4">
<h4><span class="header-section-number">2.1.1.2</span> Singular values</h4>
<pre class="r"><code>monSvd &lt;- svd(X)

p1 &lt;- data.frame(x=1:length(monSvd$d),y=monSvd$d) %&gt;%
  ggplot(aes(x=x,y=y)) +
  geom_point() +
  xlab(&quot;k&quot;) +
  ylab(&quot;singular value&quot;)

p2 &lt;- data.frame(x=1:10,y=monSvd$d[1:10]) %&gt;%
  ggplot(aes(x=x,y=y)) +
  geom_point() +
  xlab(&quot;k&quot;) +
  ylab(&quot;singular value&quot;)

grid.arrange(p1,p2,nrow=1)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<ul>
<li>The singular values decay very quickly!</li>
</ul>
</div>
<div id="data-compression" class="section level4">
<h4><span class="header-section-number">2.1.1.3</span> Data compression</h4>
<ul>
<li>We make the plot for a reconstruction with 1 singular vector. This leads to a data compression of <span class="math inline">\(1-\frac{(1+1920+1913)}{1920\times 1913}\)</span> = 99.9%. We only use 1 left singular vector (1920), 1 eigen value, 1 right singular vector (1913).</li>
</ul>
<pre class="r"><code>k &lt;- 1
approxMon &lt;- monSvd$u[,1:k] %*%
  diag(monSvd$d[1:k],ncol=k) %*%
  t(monSvd$v[,1:k])

approxMon[approxMon &lt; 0] &lt;- 0
approxMon[approxMon &gt; 1] &lt;- 1

as.cimg(approxMon) %&gt;%
  plot(.,main=paste0(&quot;Approximation with &quot;,k,&quot; singular vectors&quot;),axes=FALSE)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<ul>
<li>We make the plot for a reconstruction with 2 singular vector. This leads to a data compression of <span class="math inline">\(1-\frac{2\times (1+1920+1913)}{1920\times 1913}\)</span> = 99.8%. We only use 2 left singular vectors (2 <span class="math inline">\(\times\)</span> 1920), 2 singular values, 2 right singular vectors (2 <span class="math inline">\(\times\)</span> 1913).</li>
</ul>
<pre class="r"><code>k &lt;- 2
approxMon &lt;- monSvd$u[,1:k] %*%
  diag(monSvd$d[1:k],ncol=k) %*%
  t(monSvd$v[,1:k])

approxMon[approxMon &lt; 0] &lt;- 0
approxMon[approxMon &gt; 1] &lt;- 1

as.cimg(approxMon) %&gt;%
  plot(.,main=paste0(&quot;Approximation with &quot;,k,&quot; singular vectors&quot;),axes=FALSE)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<pre class="r"><code>par (mfrow=c(3,3))
par(mar=c(1,2,1,1))
for (k in c(1:8))
{
approxMon &lt;- monSvd$u[,1:k] %*%
  diag(monSvd$d[1:k],ncol=k) %*%
  t(monSvd$v[,1:k])


approxMon[approxMon &lt; 0] &lt;- 0
approxMon[approxMon &gt; 1] &lt;- 1


approxMon %&gt;%
  as.cimg %&gt;%
  plot(.,main=paste0(k,&quot; singular vectors&quot;),axes=FALSE)
}
plot(as.cimg(X),main=paste0(&quot;Original image&quot;),axes=FALSE)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
</div>
</div>
<div id="more-complex-painting-composition-a-piet-mondriaan" class="section level3">
<h3><span class="header-section-number">2.1.2</span> More complex painting: Composition A, Piet Mondriaan</h3>
<div id="load-the-original-painting-1" class="section level4">
<h4><span class="header-section-number">2.1.2.1</span> Load the original painting</h4>
<pre class="r"><code>mondriaan &lt;- load.image(&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Composition_A_by_Piet_Mondrian_Galleria_Nazionale_d%27Arte_Moderna_e_Contemporanea.jpg/1920px-Composition_A_by_Piet_Mondrian_Galleria_Nazionale_d%27Arte_Moderna_e_Contemporanea.jpg&quot;)
mondriaan &lt;- grayscale(mondriaan)
plot(mondriaan,axes=FALSE)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<pre class="r"><code>X &lt;- matrix(as.data.frame(mondriaan)[,3],nrow=dim(mondriaan)[1],ncol=dim(mondriaan)[2])</code></pre>
</div>
<div id="singular-values-1" class="section level4">
<h4><span class="header-section-number">2.1.2.2</span> Singular values</h4>
<pre class="r"><code>monSvd &lt;- svd(X)</code></pre>
<pre class="r"><code>p1 &lt;- data.frame(x=1:length(monSvd$d),y=monSvd$d) %&gt;%
  ggplot(aes(x=x,y=y)) +
  geom_point() +
  xlab(&quot;k&quot;) +
  ylab(&quot;singular value&quot;)

p2 &lt;- data.frame(x=1:10,y=monSvd$d[1:10]) %&gt;%
  ggplot(aes(x=x,y=y)) +
  geom_point() +
  xlab(&quot;k&quot;) +
  ylab(&quot;singular value&quot;)

grid.arrange(p1,p2,nrow=1)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<ul>
<li>The singular values decay a bit slower. The painting is a bit more complex. More lines and colors.</li>
</ul>
</div>
<div id="evaluate-data-compression" class="section level4">
<h4><span class="header-section-number">2.1.2.3</span> Evaluate data compression</h4>
<pre class="r"><code>par (mfrow=c(3,3))
par(mar=c(1,2,1,1))
for (k in c(1,seq(3,21,3)))
{
approxMon &lt;- monSvd$u[,1:k] %*%
  diag(monSvd$d[1:k],ncol=k) %*%
  t(monSvd$v[,1:k])


approxMon[approxMon &lt; 0] &lt;- 0
approxMon[approxMon &gt; 1] &lt;- 1


approxMon %&gt;%
  as.cimg %&gt;%
  plot(.,main=paste0(k,&quot; singular vectors&quot;),axes=FALSE)
}
plot(as.cimg(X),main=paste0(&quot;Original image&quot;),axes=FALSE)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
</div>
</div>
<div id="self-portret-piet-mondriaan" class="section level3">
<h3><span class="header-section-number">2.1.3</span> Self portret Piet Mondriaan</h3>
<div id="load-the-painting" class="section level4">
<h4><span class="header-section-number">2.1.3.1</span> Load the painting</h4>
<pre class="r"><code>mondriaan &lt;- load.image(&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Mondrian_Zelfportret.jpg/1920px-Mondrian_Zelfportret.jpg&quot;)
mondriaan &lt;- grayscale(mondriaan)
plot(mondriaan,axes=FALSE)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<pre class="r"><code>X &lt;- matrix(as.data.frame(mondriaan)[,3],nrow=dim(mondriaan)[1],ncol=dim(mondriaan)[2])</code></pre>
</div>
<div id="singular-values-2" class="section level4">
<h4><span class="header-section-number">2.1.3.2</span> Singular values</h4>
<pre class="r"><code>monSvd &lt;- svd(X)

p1 &lt;- data.frame(x=1:length(monSvd$d),y=monSvd$d) %&gt;%
  ggplot(aes(x=x,y=y)) +
  geom_point() +
  xlab(&quot;k&quot;) +
  ylab(&quot;singular value&quot;)

p2 &lt;- data.frame(x=1:10,y=monSvd$d[1:10]) %&gt;%
  ggplot(aes(x=x,y=y)) +
  geom_point() +
  xlab(&quot;k&quot;) +
  ylab(&quot;singular value&quot;)

grid.arrange(p1,p2,nrow=1)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<ul>
<li>The singular values decay much slower. The painting is more complex.</li>
</ul>
</div>
<div id="evaluate-compression" class="section level4">
<h4><span class="header-section-number">2.1.3.3</span> Evaluate compression</h4>
<pre class="r"><code>par (mfrow=c(3,3))
par(mar=c(1,2,1,1))
for (k in c(1,5,10,20,30,40,50,100))
{
approxMon &lt;- monSvd$u[,1:k] %*%
  diag(monSvd$d[1:k],ncol=k) %*%
  t(monSvd$v[,1:k])


approxMon[approxMon &lt; 0] &lt;- 0
approxMon[approxMon &gt; 1] &lt;- 1


approxMon %&gt;%
  as.cimg %&gt;%
  plot(.,main=paste0(k,&quot; singular vectors&quot;),axes=FALSE)
}
plot(as.cimg(X),main=paste0(&quot;Original image&quot;),axes=FALSE)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p>Here we need at least 40 singular vector. This leads to a data compression of <span class="math inline">\(1-\frac{40\times (1+1920+2494)}{1920 \times 2494}\)</span> = 96.3%. We only use 40 left singular vectors (<span class="math inline">\(40 \times 1920\)</span>), 40 singular values, 40 right eigens vector (<span class="math inline">\(40\times 2494\)</span>).</p>
</div>
</div>
</div>
</div>
<div id="geometric-interpretation" class="section level1">
<h1><span class="header-section-number">3</span> Geometric interpretation</h1>
<p>Write the <strong>truncated SVD</strong> as <span class="math display">\[
  \mathbf{X}_k = \mathbf{U}_k \boldsymbol{\Delta}_k \mathbf{V}_k^T = \mathbf{Z}_k \mathbf{V}_k^T
\]</span> with <span class="math display">\[
  \mathbf{Z}_k = \mathbf{U}_k \boldsymbol{\Delta}_k
\]</span> an <span class="math inline">\(n \times k\)</span> matrix.</p>
<p>Each of the <span class="math inline">\(n\)</span> rows of <span class="math inline">\(\mathbf{Z}_k\)</span>, say <span class="math inline">\(\mathbf{z}^T_{k,i}\)</span>, represents a point in a <span class="math inline">\(k\)</span>-dimensional space.</p>
<p>Because of the orthonormality of the singular vectors, we also have <span class="math display">\[\begin{eqnarray*}
  \mathbf{X}_k\mathbf{V}_k &amp;=&amp; \mathbf{Z}_k \mathbf{V}_k^T\mathbf{V}_k \\
  \mathbf{X}_k\mathbf{V}_k &amp;=&amp; \mathbf{Z}_k.
\end{eqnarray*}\]</span></p>
<p>Thus the matrix <span class="math inline">\(\mathbf{V}_k\)</span> is a <strong>transformation matrix</strong> that may be used to transform <span class="math inline">\(\mathbf{X}_k\)</span> into <span class="math inline">\(\mathbf{Z}_k\)</span>, and <span class="math inline">\(\mathbf{Z}_k\)</span> into <span class="math inline">\(\mathbf{X}_k\)</span>.</p>
<hr />
<p>Note that</p>
<ul>
<li><p>The matrix <span class="math inline">\(\mathbf{V}_k\)</span> transforms the <span class="math inline">\(p\)</span>-dimensional <span class="math inline">\(\mathbf{X}_k\)</span> into the <span class="math inline">\(k\)</span>-dimensional <span class="math inline">\(\mathbf{Z}_k\)</span>: <span class="math inline">\(\mathbf{Z}_k = \mathbf{X}_k\mathbf{V}_k\)</span>. Note, however, that the matrix <span class="math inline">\(\mathbf{X}_k\)</span> must not necessarily be used for this transformation, because the SVD of the original matrix <span class="math inline">\(\mathbf{X}\)</span> also gives directly <span class="math inline">\(\mathbf{Z}_k = \mathbf{U}_k \boldsymbol{\Delta}_k\)</span>.</p></li>
<li><p>The inverse transformation from the <span class="math inline">\(k\)</span>-dimensional <span class="math inline">\(\mathbf{Z}_k\)</span> to the <span class="math inline">\(p\)</span>-dimensional <span class="math inline">\(\mathbf{X}_k\)</span> is given by the transpose of <span class="math inline">\(\mathbf{V}_k\)</span>: <span class="math inline">\(\mathbf{Z}_k \mathbf{V}_k^T=\mathbf{X}_k\)</span>. Often inverse transformations are given by the inverse of a matrix, but thanks to the orthonormality of the columns of <span class="math inline">\(\mathbf{V}_k\)</span>, we get <span class="math inline">\(\mathbf{V}_k^T\mathbf{V}_k=\mathbf{I}\)</span>, and thus <span class="math inline">\(\mathbf{V}_k^T\)</span> acts as an inverse.</p></li>
<li><p>The transformation from the <span class="math inline">\(k\)</span>-dimensional <span class="math inline">\(\mathbf{Z}_k\)</span> to the <span class="math inline">\(p\)</span>-dimensional <span class="math inline">\(\mathbf{X}_k\)</span> is transforming points from a low dimensional space (<span class="math inline">\(k\)</span>) to a high dimensional space (<span class="math inline">\(p\)</span>). You may not interpret this as if this transformation adds information; the transformed points in <span class="math inline">\(\mathbf{X}_k\)</span> still live in a <span class="math inline">\(k\)</span>-dimensional subspace of the larger <span class="math inline">\(p\)</span>-dimensional space; the matrix <span class="math inline">\(\mathbf{X}_k\)</span> is only of rank <span class="math inline">\(k\)</span> and thus contains less information than the original data matrix <span class="math inline">\(\mathbf{X}\)</span> (if rank(<span class="math inline">\(\mathbf{X}\)</span>)<span class="math inline">\(=r&gt;k\)</span>).</p></li>
</ul>
<hr />
<p>More importantly, it can be shown that (thanks to orthonormality of <span class="math inline">\(\mathbf{V}\)</span>) <span class="math display">\[
     \mathbf{X}\mathbf{V}_k = \mathbf{Z}_k.
  \]</span> This follows from (w.l.g. rank(<span class="math inline">\(\mathbf{X}\)</span>)=<span class="math inline">\(r\)</span>) <span class="math display">\[\begin{eqnarray*}
    \mathbf{X}\mathbf{V}_k
       &amp;=&amp; \mathbf{UDV}^T\mathbf{V}_k = \mathbf{UD}\begin{pmatrix}
                \mathbf{v}_1^T \\
            \vdots \\
            \mathbf{v}_r^T
               \end{pmatrix}
               \begin{pmatrix}
                 \mathbf{v}_1 \ldots \mathbf{v}_k
               \end{pmatrix} \\
       &amp;=&amp; \mathbf{UDV}^T\mathbf{V}_k = \mathbf{UD}\begin{pmatrix}
                1 &amp; 0 &amp; \ldots &amp; 0 \\
                0 &amp; 1 &amp; \ldots &amp; 0 \\
                \vdots &amp; \vdots &amp; \ddots &amp; 0 \\
                0 &amp; 0 &amp; \ldots &amp; 1 \\
                0 &amp; 0 &amp; \ldots &amp; 0 \\
                \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
                0 &amp; 0 &amp; \ldots &amp; 0
               \end{pmatrix} \
               = \mathbf{U}_k\boldsymbol{\Delta}_k = \mathbf{Z}_k
  \end{eqnarray*}\]</span></p>
<p>The <span class="math inline">\(p \times k\)</span> matrix <span class="math inline">\(\mathbf{V}_k\)</span> acts as a transformation matrix: transforming <span class="math inline">\(n\)</span> points in a <span class="math inline">\(p\)</span> dimensional space to <span class="math inline">\(n\)</span> points in a <span class="math inline">\(k\)</span> dimensional space.</p>
<hr />
<p>We take a closer look at <span class="math display">\[
  \mathbf{Z}_k = \mathbf{X}\mathbf{V}_k = \begin{pmatrix}
   \mathbf{x}_1^T \\
   \vdots \\
   \mathbf{x}_n^T
  \end{pmatrix} \begin{pmatrix}
   \mathbf{v}_1 \ldots \mathbf{v}_k
  \end{pmatrix}.
\]</span> The <span class="math inline">\(i\)</span>th row (observation) in <span class="math inline">\(\mathbf{Z}_k\)</span> equals <span class="math display">\[
 \mathbf{z}_{k,i}^T = \mathbf{x}_i^T\mathbf{V}_k = \left(\mathbf{x}_i^T \mathbf{v}_1 , \mathbf{x}_i^T \mathbf{v}_2 , \ldots , \mathbf{x}_i^T \mathbf{v}_k\right).
\]</span></p>
<p>Hence, <span class="math inline">\(\mathbf{z}_{k,i}^T = \mathbf{x}_i^T\mathbf{V}_k\)</span> is the orthogonal projection of <span class="math inline">\(\mathbf{x}_i\)</span> onto the <span class="math inline">\(k\)</span>-dimensional subspace spanned by the columns of <span class="math inline">\(\mathbf{V}_k\)</span>.</p>
<p>SVD transforms data set to lower dimensional data set: The SVD thus gives a transformation of the <span class="math inline">\(p\)</span> dimensional data to <span class="math inline">\(k\leq r\)</span> dimensional data: <span class="math display">\[
  \mathbf{Z}_k = \mathbf{X}\mathbf{V}_k.
\]</span> This is essentially a dimension reduction.</p>
<hr />
<p>Note that,</p>
<ul>
<li><p>The transformation from <span class="math inline">\(p\)</span>-dimensional <span class="math inline">\(\mathbf{X}\)</span> to <span class="math inline">\(k\)</span>-dimensional <span class="math inline">\(\mathbf{Z}_k\)</span> is important. It shows that the <span class="math inline">\(n\)</span> points in the rows of <span class="math inline">\(\mathbf{Z}_k\)</span> are the result of projecting the <span class="math inline">\(n\)</span> points in <span class="math inline">\(\mathbf{X}\)</span> onto the columns of <span class="math inline">\(\mathbf{V}_k\)</span> (i.e. the first <span class="math inline">\(k\)</span> singular vectors of <span class="math inline">\(\mathbf{X}\)</span>). We say that the space of <span class="math inline">\(\mathbf{Z}_k\)</span> is spanned by the column of <span class="math inline">\(\mathbf{V}_k\)</span>.</p></li>
<li><p>The points (rows) in <span class="math inline">\(\mathbf{X}\)</span> live in a <span class="math inline">\(p\)</span>-dimensional space (or rank(<span class="math inline">\(\mathbf{X}\)</span>)<span class="math inline">\(=r\)</span> if <span class="math inline">\(r&lt;p\)</span>) and they are thus projected onto a lower dimensional space. This is in contrast to the projection <span class="math inline">\(\mathbf{X}_k\mathbf{V}_k=\mathbf{Z}_k\)</span>, because the points in <span class="math inline">\(\mathbf{X}_k\)</span> live in a <span class="math inline">\(k\)</span>-dimensional subspace of <span class="math inline">\(\mathbf{X}\)</span>.</p></li>
<li><p>Note that with <span class="math inline">\(k&lt;r\)</span> there is no unique transformation to transform <span class="math inline">\(\mathbf{Z}_k\)</span> back to <span class="math inline">\(\mathbf{X}\)</span>. On the previous slide we only established the transformation <span class="math inline">\(\mathbf{Z}_k \mathbf{V}_k^T=\mathbf{X}_k\)</span>. Indeed, starting from <span class="math inline">\(\mathbf{X}\mathbf{V}_k = \mathbf{Z}_k\)</span>, and right-multiplying with <span class="math inline">\(\mathbf{V}_k^T\)</span> does not give the backtransformation, because <span class="math inline">\(\mathbf{V}_k\mathbf{V}_k^T\)</span> is not the identity matrix.</p></li>
</ul>
</div>
<div id="interpretation-of-svd-in-terms-of-correlation-matrices" class="section level1">
<h1><span class="header-section-number">4</span> Interpretation of SVD in terms of correlation matrices</h1>
<p>For a matrix <span class="math inline">\(\mathbf X\)</span> the sample variance covariance matrix estimator is <span class="math inline">\(p\times p\)</span> matrix</p>
<p><span class="math display">\[\begin{eqnarray}
\mathbf{S}&amp;=&amp;\frac{1}{N-1}(\mathbf{X}-\bar{\mathbf{X}})^T (\mathbf{X}-\bar{\mathbf{X}})\\
&amp;=&amp;\frac{1}{N-1}\left[\mathbf{X}^T\mathbf{X} - \bar{\mathbf{X}}^T\bar{\mathbf{X}}\right]
\end{eqnarray}\]</span></p>
<p>So <span class="math inline">\(\mathbf{X}^T\mathbf{X}\)</span> defines up to a constant the variance covariance matrix of <span class="math inline">\(\mathbf{X}\)</span>! When the matrix is column centered <span class="math inline">\(\mathbf{S}=\frac{1}{n-1}\mathbf{X}^T\mathbf{X}\)</span>.</p>
<p>The same holds for the rows of <span class="math inline">\(\mathbf{X}\)</span>! The covariance between the subjects can be estimated as <span class="math display">\[\mathbf{S}=\frac{1}{p-1}\mathbf{X}\mathbf{X}^T\]</span> upon row centering.</p>
<p>Note, that <span class="math display">\[\begin{eqnarray}
\mathbf{X}^T\mathbf{X} &amp;=&amp; \mathbf{V}\boldsymbol{\Delta}\mathbf{U}^T \mathbf{U} \boldsymbol{\Delta} \mathbf{V}^T \\
&amp;=&amp;\mathbf{V}\boldsymbol{\Delta}^2 \mathbf{V}^T
\end{eqnarray}\]</span></p>
<p>If we rewrite the expression <span class="math display">\[\begin{eqnarray}
\mathbf{X}^T\mathbf{X}\mathbf{V} &amp;=&amp;\mathbf{V}\boldsymbol{\Delta}^2 \mathbf{V}^T\mathbf{V}
\mathbf{X}^T\mathbf{X}\mathbf{V}\\ &amp;=&amp;\mathbf{V}\boldsymbol{\Delta}^2
\end{eqnarray}\]</span></p>
<p>So, if the data are centered, the SVD can be used to perform a spectral decomposition of the sample covariance matrix where the right singular vectors correspond to the eigen vectors of the covariance matrix and the eigenvalues are the squared singular values!</p>
<p>Similarly the left singular values can be used to estimate the covariance matrix of the rows of <span class="math inline">\(\mathbf{X}\)</span>. So in our notation covariance between subjects.</p>
<p><span class="math display">\[\begin{eqnarray}
\mathbf{X}\mathbf{X}^T &amp;=&amp;\mathbf{U}\boldsymbol{\Delta}^2 \mathbf{U}^T
\end{eqnarray}\]</span></p>
<p>This link is for instance very useful for recommender systems, i.e. to propose movies based on the subjects with whom you correlate. We will also exploit this when we discuss on PCA.</p>
</div>
<div id="svd-and-inverse-of-a-matrix" class="section level1">
<h1><span class="header-section-number">5</span> SVD and inverse of a matrix</h1>
<p>A linear system of equations with <span class="math inline">\(n\)</span> equations and <span class="math inline">\(n\)</span> unknowns <span class="math display">\[
\mathbf{A}_{n\times n} \boldsymbol{\beta} = \mathbf{b}
\]</span> can be solved by <span class="math display">\[
\boldsymbol{\beta} = \mathbf{A}_{n\times n}^{-1} \mathbf{b}
\]</span></p>
<p>A unique solution exists if A is full rank.</p>
<p>Note, that a singular value decomposition of the square matrix <span class="math inline">\(\mathbf{A}=\mathbf{V}\boldsymbol{\Delta}\mathbf{V}^T\)</span> enables the inverse to be written as</p>
<p><span class="math display">\[
\mathbf{A}^{-1} = \mathbf{V}\boldsymbol{\Delta}^{-1}\mathbf{V}^T
\]</span></p>
<p>indeed <span class="math display">\[
\mathbf{A}^{-1} \mathbf{A} = \mathbf{V}\boldsymbol{\Delta}^{-1}\mathbf{V}^T\mathbf{V}\boldsymbol{\Delta}\mathbf{V}^T = \mathbf{I}
\]</span></p>
<p>Note, that the SVD generalizes this to systems of under (n&lt;p, fat short matrices) and over determined systems (n&gt;p tall skinny matrices):</p>
<p>Let <span class="math display">\[\begin{eqnarray}
\mathbf{A} = \mathbf{U}\boldsymbol{\Delta}\mathbf{V}^T
\end{eqnarray}\]</span></p>
<p>and we want to solve <span class="math display">\[\begin{eqnarray}
\mathbf{A} \boldsymbol{\beta} &amp;=&amp; \mathbf{b}\\
\mathbf{U}\boldsymbol{\Delta}\mathbf{V}^T \boldsymbol{\beta} &amp;=&amp; \mathbf{b}\\
\mathbf{U}^T\mathbf{U}\boldsymbol{\Delta}\mathbf{V}^T \boldsymbol{\beta} &amp;=&amp; \mathbf{U}^T\mathbf{b}\\
\boldsymbol{\Delta}\mathbf{V}^T \boldsymbol{\beta} &amp;=&amp; \mathbf{U}^T\mathbf{b}\\
\boldsymbol{\Delta}^{-1}\boldsymbol{\Delta}\mathbf{V}^T \boldsymbol{\beta} &amp;=&amp; \boldsymbol{\Delta}^{-1}\mathbf{U}^T\mathbf{b}\\
\mathbf{V}\mathbf{V}^T \boldsymbol{\beta} &amp;=&amp; \mathbf{V}\boldsymbol{\Delta}^{-1}\mathbf{U}^T\mathbf{b}\\
\boldsymbol{\beta} &amp;=&amp; \mathbf{V}\boldsymbol{\Delta}^{-1}\mathbf{U}^T\mathbf{b}
\end{eqnarray}\]</span></p>
<p>Note, that for an overdetermined system <span class="math inline">\(n&gt;p\)</span> so <span class="math inline">\(r\leq p\)</span>. Generally, <span class="math inline">\(r=p\)</span> and <span class="math inline">\(\mathbf{V}\)</span> is thus a square matrix so both <span class="math inline">\(\mathbf{V}^T\mathbf{V}=\mathbf{I}\)</span> and <span class="math inline">\(\mathbf{V}\mathbf{V}^T=\mathbf{I}\)</span>. However, <span class="math inline">\(\mathbf{U}^T\mathbf{U}=\mathbf{I}\)</span> but <span class="math inline">\(\mathbf{U}\mathbf{U}^T\neq\mathbf{I}\)</span> because <span class="math inline">\(r&lt;n\)</span>.</p>
<p><span class="math inline">\(\mathbf{A}^\dagger=\mathbf{V}\boldsymbol{\Delta}^{-1}\mathbf{U}^T\)</span> is also referred to as the pseudo inverse and it enables us to solve under and overdetermined systems of equations.</p>
<p>Note, that for</p>
<ul>
<li>underdetermined systems there typically does not exist a unique solution</li>
<li>for overdetermined systems usually there does not exist an exact solution. We will focus on the latter in the next section where we explore the link between linear regression and SVD.</li>
</ul>
</div>
<div id="linear-regression-and-svd" class="section level1">
<h1><span class="header-section-number">6</span> Linear regression and SVD</h1>
<p>Suppose we have the linear regression problem with <span class="math inline">\(n&gt;p\)</span>:</p>
<p><span class="math display">\[\mathbf{Y}=\mathbf{X}\boldsymbol{\beta} + \boldsymbol{\epsilon}\]</span></p>
<p><span class="math inline">\(\mathbf{X}\)</span> is a tall skinny matrix with <span class="math inline">\(n &gt;&gt; p\)</span>.</p>
<p>We know that <span class="math display">\[
\hat{\boldsymbol{\beta}}=\left(\mathbf{X}^T \mathbf{X}\right)^{-1}\mathbf{X}^T\mathbf{Y}
\]</span></p>
<p>If we replace <span class="math inline">\(\mathbf{X}\)</span> by its SVD</p>
<p><span class="math display">\[\begin{eqnarray}
\hat{\boldsymbol{\beta}}&amp;=&amp;\left(\mathbf{V}\boldsymbol{\Delta}^2\mathbf{V}^T\right)^{-1}\mathbf{V}\boldsymbol{\Delta}\mathbf{U}^T\mathbf{Y}\\
\hat{\boldsymbol{\beta}}&amp;=&amp;\mathbf{V}\boldsymbol{\Delta}^{-2}\mathbf{V}^T\mathbf{V}\boldsymbol{\Delta}\mathbf{U}^T\mathbf{Y}\\
\hat{\boldsymbol{\beta}}&amp;=&amp;\mathbf{V}\boldsymbol{\Delta}^{-1}\mathbf{U}^T\mathbf{Y}
\end{eqnarray}\]</span></p>
<p>So the SVD also solves the linear regression problem by using the pseudoinverse! If we now think about the fit:</p>
<p><span class="math display">\[\begin{eqnarray}
\hat{\mathbf{Y}}&amp;=&amp;\mathbf{X}\hat{\boldsymbol{\beta}}\\
&amp;=&amp;\mathbf{U}\boldsymbol{\Delta}^{-1}\mathbf{V}^T\mathbf{V}\boldsymbol{\Delta}\mathbf{U}^T\mathbf{Y}\\
&amp;=&amp;\mathbf{U}\mathbf{U}^T\mathbf{Y}
\end{eqnarray}\]</span></p>
<ul>
<li><p>For an overdetermined system <span class="math inline">\(\mathbf{U}\mathbf{U}^T\)</span> is not equal to the unity matrix <span class="math inline">\(\mathbf{I}\)</span> (for an overdetermined system only <span class="math inline">\(\mathbf{U}^T\mathbf{U}=\mathbf{I}\)</span> because <span class="math inline">\(n&gt;r\)</span>).</p></li>
<li><p>So <span class="math inline">\(\hat{\mathbf{Y}}\neq \mathbf{Y}\)</span>. Hence, we typically do not have an exact solution.</p></li>
<li><p>Note, that <span class="math inline">\(\mathbf{U}\mathbf{U}^T\)</span> spans the same space as the columns of <span class="math inline">\(\mathbf{X}\)</span>, and will define the same <span class="math inline">\(p\)</span>-dimensional plane in the <span class="math inline">\(n\)</span> dimensional space <span class="math inline">\(\mathcal{R}^n\)</span>, e.g. cfr <span class="math inline">\(\mathbf{X}\left(\mathbf{X}^T\mathbf{X}\right)^{-1}\mathbf{X}^T\)</span>. So it projects <span class="math inline">\(\mathbf{Y}\)</span> in the column space of <span class="math inline">\(\mathbf{X}\)</span> and the errors will be orthogonal onto this plane.</p></li>
</ul>
<div id="example-prostate-dataset" class="section level2">
<h2><span class="header-section-number">6.1</span> Example prostate dataset</h2>
<div id="fit-with-lm" class="section level3">
<h3><span class="header-section-number">6.1.1</span> Fit with lm</h3>
<pre class="r"><code>prostate &lt;- read_csv(
  &quot;https://raw.githubusercontent.com/GTPB/PSLS20/master/data/prostate.csv&quot;,
  col_types = cols()
)
lm1 &lt;- lm(lpsa ~ lcavol + lweight + svi, prostate)</code></pre>
</div>
<div id="fit-with-svd" class="section level3">
<h3><span class="header-section-number">6.1.2</span> Fit with SVD</h3>
<pre class="r"><code>X &lt;- prostate[,c(1:2,5)]
X[,3] &lt;- as.double(X[,3]!=&quot;healthy&quot;)
X &lt;- cbind(Intercept=1,X)

svdX &lt;- svd(X)
betaSvd &lt;- svdX$v %*% diag(1/svdX$d) %*% t(svdX$u) %*% prostate$lpsa

cbind(lm1$coef,betaSvd)</code></pre>
<pre><code>##                   [,1]       [,2]
## (Intercept) -0.2680724 -0.2680724
## lcavol       0.5516386  0.5516386
## lweight      0.5085359  0.5085359
## sviinvasion  0.6661583  0.6661583</code></pre>
</div>
</div>
</div>
<div id="svd-and-multi-dimensional-scaling-mds" class="section level1">
<h1><span class="header-section-number">7</span> SVD and Multi-Dimensional Scaling (MDS)</h1>
<div id="example" class="section level2">
<h2><span class="header-section-number">7.1</span> Example</h2>
<p>In this section we will use a dataset on food consumption in the UK. The data originate from the UKs ‘Department for Environment, Food and Rural Affairs’ (DEFRA), showing the consumption in grams (per person, per week) of 17 different types of foodstuff measured and averaged in the four countries of the United Kingdom in 1997. We would like to explore the data and interpret how the food patterns of the different countries differ.</p>
<pre class="r"><code>uk &lt;- read_csv(
  &quot;https://raw.githubusercontent.com/statOmics/HDA2020/data/ukFoods.csv&quot;,
  col_types = cols()
)</code></pre>
<pre><code>## New names:
## * `` -&gt; ...1</code></pre>
<pre class="r"><code>knitr::kable(uk, caption = &quot;The full UK foods data table&quot;)</code></pre>
<table>
<caption>The full UK foods data table</caption>
<thead>
<tr class="header">
<th align="left">…1</th>
<th align="right">England</th>
<th align="right">Wales</th>
<th align="right">Scotland</th>
<th align="right">N.Ireland</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Cheese</td>
<td align="right">105</td>
<td align="right">103</td>
<td align="right">103</td>
<td align="right">66</td>
</tr>
<tr class="even">
<td align="left">Carcass_meat</td>
<td align="right">245</td>
<td align="right">227</td>
<td align="right">242</td>
<td align="right">267</td>
</tr>
<tr class="odd">
<td align="left">Other_meat</td>
<td align="right">685</td>
<td align="right">803</td>
<td align="right">750</td>
<td align="right">586</td>
</tr>
<tr class="even">
<td align="left">Fish</td>
<td align="right">147</td>
<td align="right">160</td>
<td align="right">122</td>
<td align="right">93</td>
</tr>
<tr class="odd">
<td align="left">Fats_and_oils</td>
<td align="right">193</td>
<td align="right">235</td>
<td align="right">184</td>
<td align="right">209</td>
</tr>
<tr class="even">
<td align="left">Sugars</td>
<td align="right">156</td>
<td align="right">175</td>
<td align="right">147</td>
<td align="right">139</td>
</tr>
<tr class="odd">
<td align="left">Fresh_potatoes</td>
<td align="right">720</td>
<td align="right">874</td>
<td align="right">566</td>
<td align="right">1033</td>
</tr>
<tr class="even">
<td align="left">Fresh_Veg</td>
<td align="right">253</td>
<td align="right">265</td>
<td align="right">171</td>
<td align="right">143</td>
</tr>
<tr class="odd">
<td align="left">Other_Veg</td>
<td align="right">488</td>
<td align="right">570</td>
<td align="right">418</td>
<td align="right">355</td>
</tr>
<tr class="even">
<td align="left">Processed_potatoes</td>
<td align="right">198</td>
<td align="right">203</td>
<td align="right">220</td>
<td align="right">187</td>
</tr>
<tr class="odd">
<td align="left">Processed_Veg</td>
<td align="right">360</td>
<td align="right">365</td>
<td align="right">337</td>
<td align="right">334</td>
</tr>
<tr class="even">
<td align="left">Fresh_fruit</td>
<td align="right">1102</td>
<td align="right">1137</td>
<td align="right">957</td>
<td align="right">674</td>
</tr>
<tr class="odd">
<td align="left">Cereals</td>
<td align="right">1472</td>
<td align="right">1582</td>
<td align="right">1462</td>
<td align="right">1494</td>
</tr>
<tr class="even">
<td align="left">Beverages</td>
<td align="right">57</td>
<td align="right">73</td>
<td align="right">53</td>
<td align="right">47</td>
</tr>
<tr class="odd">
<td align="left">Soft_drinks</td>
<td align="right">1374</td>
<td align="right">1256</td>
<td align="right">1572</td>
<td align="right">1506</td>
</tr>
<tr class="even">
<td align="left">Alcoholic_drinks</td>
<td align="right">375</td>
<td align="right">475</td>
<td align="right">458</td>
<td align="right">135</td>
</tr>
<tr class="odd">
<td align="left">Confectionery</td>
<td align="right">54</td>
<td align="right">64</td>
<td align="right">62</td>
<td align="right">41</td>
</tr>
</tbody>
</table>
<p>Note, that here the matrix is displayed with the p variables in the rows and the n experimental units (countries) in the columns. This is often done for high dimensional data where <span class="math inline">\(p&gt;&gt;n\)</span> because this makes it easier to look at to the raw data table. Note, that the svd calculates left and right singular vectors so it will also provide the correct solution, we just should look to the other set of singular vectors in order to get to the correct interpretation.</p>
</div>
<div id="motivation-1" class="section level2">
<h2><span class="header-section-number">7.2</span> Motivation</h2>
<p>The objective of Multidimensional Scaling (MDS) is to find a low-dimensional representation, say <span class="math inline">\(k\)</span>-dimensional, of <span class="math inline">\(n\)</span> data points such that the distances between the <span class="math inline">\(n\)</span> points in the <span class="math inline">\(k\)</span>-dimensional space is a good approximation of a given squared distance matrix, say <span class="math inline">\(\mathbf{D}_X\)</span>.</p>
<ul>
<li><p>The squared distance matrix <span class="math inline">\(\mathbf{D}_X\)</span> may be given without knowledge of the original observations (not even the dimensionality), or it may be computed from a given set of <span class="math inline">\(n\)</span> <span class="math inline">\(p\)</span>-dimensional data points.</p></li>
<li><p>Note that the distances between points in a <span class="math inline">\(k\)</span>-dimensional subspace coincide with the distances between these points in the larger <span class="math inline">\(p\)</span>-dimensional space.</p></li>
</ul>
<p>Use of MDS:</p>
<ul>
<li><p>A high dimensional data matrix <span class="math inline">\(\mathbf{X}\)</span> is given, and one wants to get a visual representation (in 2 or 3 dimensions) of the observations. In this graph each point represents an observation (row of data matrix). From this graph one wants points close to one another to be similar, and observations far away from one another to be dissimilar. Thus the distances between the <span class="math inline">\(n\)</span> points in the original <span class="math inline">\(p\)</span>-dimensional space should be well preserved in the 2 or 3 dimensional space.</p></li>
<li><p>In some applications the researcher only has knowledge of the similarity (or dissimilarity) between observations. For example, food products can be evaluated by a taste panel and a dissimilarity matrix can be completed. This dissimilarity matrix shows for each pair of food products their dissimilarity (numerical values provided by taste panel, but not objectively quantified). Given this dissimilarity matrix, a 2 or 3 dimensional graph could be helpful if the distances between the points (food products) in this graph are monotonically related to the dissimilarities provided by the taste panel. Food products close to one another in this graph, taste similarly.</p></li>
<li><p>Here we discuss the “metric” MDS, which actually requires the Euclidean distances between observations. However, the method works also well if the matrix <span class="math inline">\(\mathbf{D}_X\)</span> contains dissimilarities rather than squared Euclidean distances.</p></li>
</ul>
<hr />
<p>In this chapter we assume that the data matrix <span class="math inline">\(\mathbf{X}\)</span> is column-centered (i.e. each column has mean zero).</p>
<p>Centering can be accomplished by multiplying the original data matrix <span class="math inline">\(\mathbf{X}\)</span> with the <span class="math inline">\(n \times n\)</span> <span class="math inline">\(\mathbf{centering\ matrix}\)</span> <span class="math display">\[
   \mathbf{H} = \mathbf{I} - \frac{1}{n} \mathbf{1}\mathbf{1}^T ,
 \]</span> in which <span class="math inline">\(\mathbf{1}\)</span> is an <span class="math inline">\(n\)</span>-vector with all entries equal to 1. Hence, <span class="math inline">\(\mathbf{H}\mathbf{X}\)</span> is the column-centered data matrix.</p>
<p>We will assume that <span class="math inline">\(\mathbf{X}\)</span> is already column-centered, and therefore <span class="math inline">\(\mathbf{H}\mathbf{X}=\mathbf{X}\)</span>.</p>
<p>(Note, that the matrix <span class="math inline">\(\mathbf{1}\mathbf{1}^T\)</span> is an <span class="math inline">\(n\times n\)</span> matrix with all entries set to 1. )</p>
<hr />
<p>We will need the following interesting relationship between the <strong>Gram matrix</strong> <span class="math inline">\(\mathbf{X}\mathbf{X}^T\)</span> and the distance matrix.</p>
<ul>
<li>For an <span class="math inline">\(n\times p\)</span> data matrix <span class="math inline">\(\mathbf{X}\)</span>, the matrix <span class="math inline">\(\mathbf{D}_X\)</span> with squared distances has elements <span class="math display">\[
    (\mathbf{x}_{i}-\mathbf{x}_{j})^T(\mathbf{x}_{i}-\mathbf{x}_{j}) = \Vert \mathbf{x}_i\Vert^2 - 2 \mathbf{x}^T_i\mathbf{x}_j + \Vert \mathbf{x}_j\Vert.^2
 \]</span></li>
</ul>
<p>-The <span class="math inline">\(n\times n\)</span> squared distance matrix can then be written as <span class="math display">\[
     \mathbf{D}_X = \mathbf{N} - 2\mathbf{X}\mathbf{X}^T + \mathbf{N}^T ,
   \]</span> with <span class="math inline">\(\mathbf{N}\)</span> the <span class="math inline">\(n \times n\)</span> matrix with <span class="math inline">\(i\)</span>th row filled with <span class="math inline">\(\Vert \mathbf{x}_i\Vert^2\)</span>.</p>
<ul>
<li><p>Note that the elements of <span class="math inline">\(\mathbf{N}\)</span> can also be found on the diagonal of <span class="math inline">\(\mathbf{XX}^T\)</span>.</p></li>
<li><p>Given the structure of the <span class="math inline">\(\mathbf{H}\)</span> and <span class="math inline">\(\mathbf{N}\)</span> matrices, it is easy to verify that <span class="math display">\[
    -\frac{1}{2}\mathbf{H}\mathbf{D}_X\mathbf{H} = \mathbf{X}\mathbf{X}^T.
 \]</span> This gives an important relation between the distance matrix and the Gram matrix. We will use the notation <span class="math inline">\(\mathbf{G}_X = -\frac{1}{2}\mathbf{H}\mathbf{D}_X\mathbf{H}\)</span>.</p></li>
<li><p>The <span class="math inline">\(n \times n\)</span> Gram matrix <span class="math inline">\(\mathbf{X}\mathbf{X}^T\)</span> equals <span class="math display">\[
  \begin{pmatrix}
\mathbf{x}_1^T \\
\vdots  \\
\mathbf{x}_n^T
  \end{pmatrix}
  \begin{pmatrix}
 \mathbf{x}_1 \ldots \mathbf{x}_n
  \end{pmatrix}
\]</span> and has thus on its <span class="math inline">\((i,j)\)</span>th position the inner product <span class="math display">\[
\mathbf{x}_i^T\mathbf{x}_j= \Vert \mathbf{x}_i\Vert\Vert \mathbf{x}_j\Vert \cos&lt;\mathbf{x}_i,\mathbf{x}_j&gt; .
\]</span></p></li>
<li><p>On the diagonal we find <span class="math inline">\(\mathbf{x}_i^T\mathbf{x}_i=\Vert \mathbf{x}_i\Vert^2\)</span>, the squared norm of the <span class="math inline">\(i\)</span>th observation.</p></li>
<li><p>The relation <span class="math inline">\(-\frac{1}{2}\mathbf{H}\mathbf{D}_X\mathbf{H} = \mathbf{X}\mathbf{X}^T\)</span> tells us that the distance matrix and the Gram matrix contain the same information. The distances, however, are in most situations easier to interpret.</p></li>
</ul>
<hr />
</div>
<div id="link-with-the-svd" class="section level2">
<h2><span class="header-section-number">7.3</span> Link with the SVD</h2>
<p>Note, that we have shown that we can rewrite <span class="math inline">\(\mathbf{X}\mathbf{X}^T\)</span> using the SVD:</p>
<p><span class="math display">\[
\mathbf{X}\mathbf{X}^T = \mathbf{U}\boldsymbol{\Delta}^2\mathbf{U}^T
\]</span></p>
<p>Because the truncated SVD of <span class="math inline">\(\mathbf{X}\)</span> minimises the Frobenius norm <span class="math inline">\(\Vert \mathbf{X}-\mathbf{X}_k\Vert_F^2\)</span>, it this has an important consequence:</p>
<ul>
<li><p>Let <span class="math inline">\(\mathbf{D}_X\)</span> denote the <span class="math inline">\(n \times n\)</span> matrix with the squared Euclidian distances between the <span class="math inline">\(n\)</span> data points <span class="math inline">\(\mathbf{x}_i\)</span> in the original <span class="math inline">\(p\)</span>-dimensional space.</p></li>
<li><p>Let <span class="math inline">\(\mathbf{D}_{Zk}\)</span> denote the <span class="math inline">\(n \times n\)</span> matrix with the squared Euclidian distances between the <span class="math inline">\(n\)</span> transformed data points <span class="math inline">\(\mathbf{z}_{k,i}\)</span> in the reduced <span class="math inline">\(k\)</span>-dimensional space.</p></li>
</ul>
<p>Then, it can be shown that the truncated SVD also minimises <span class="math display">\[
   \Vert \mathbf{D}_X - \mathbf{D}_{Zk} \Vert_F^2.
 \]</span></p>
<p>Or in other words: The n points <span class="math inline">\(\mathbf{z}_{k,i}\)</span> in the k-dimensional subspace spanned by the columns of <span class="math inline">\(\mathbf{V}_k\)</span> are the best approximation of the <span class="math inline">\(n\)</span> original points <span class="math inline">\(\mathbf{x}_i\)</span> in the original p-dimensional space in the sense that the Euclidean distances between the n original points are best approximated by the Euclidean distances between the n transformed points, among all possible k-dimensional linear subspaces.</p>
<hr />
<ul>
<li><p>If <span class="math inline">\(\mathbf{X}\)</span> is known, we can readily obtain the k-dimensional projection by the SVD of <span class="math inline">\(\mathbf{X}\)</span></p></li>
<li><p>If we only know the distance matrix <span class="math inline">\(\mathbf{D}\)</span></p>
<ol style="list-style-type: decimal">
<li>We can readily obtain the Gram matrix <span class="math display">\[-\frac{1}{2}\mathbf{H}\mathbf{D}_X\mathbf{H} = \mathbf{X}\mathbf{X}^T\]</span></li>
<li>The truncated SVD of the squared and symmetric Gram matrix <span class="math display">\[\mathbf{U}_k\boldsymbol{\Delta}_k^\prime\mathbf{U}_k^T\]</span></li>
<li>from which also can obtain <span class="math display">\[\mathbf{Z}_k=\mathbf{U}_k\boldsymbol{\Delta}_k,\]</span> with <span class="math inline">\(\boldsymbol{\Delta}_k= \mathbf{\Delta}_k^{\prime \frac{1}{2}}\)</span></li>
</ol></li>
</ul>
</div>
<div id="example-1" class="section level2">
<h2><span class="header-section-number">7.4</span> Example</h2>
<pre class="r"><code>X &lt;- as.matrix(t(uk[,-1]))
n &lt;- nrow(X)
H &lt;- diag(n) - matrix(1/n,nrow=n,ncol=n)
X &lt;- H%*%X
svdUk &lt;- svd(X)

k &lt;- 2
Uk &lt;- svdUk$u[,1:k]
Dk &lt;- diag(svdUk$d[1:k])
Zk &lt;- Uk%*%Dk
rownames(Zk) &lt;- colnames(uk)[-1]
colnames(Zk) &lt;- paste0(&quot;Z&quot;,1:k)
Zk</code></pre>
<pre><code>##                   Z1          Z2
## England   -144.99315    2.532999
## Wales     -240.52915  224.646925
## Scotland   -91.86934 -286.081786
## N.Ireland  477.39164   58.901862</code></pre>
<pre class="r"><code>Zk %&gt;%
  as.data.frame %&gt;%
  ggplot(aes(x=Z1,y=Z2,label=rownames(Zk))) +
  geom_point(size = 3) +
  geom_text(nudge_x = 50)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<ul>
<li><p>The graph suggests that Wales and England are quite similar in terms of food consumption, and North Ireland seem to have a very different food consumption pattern.</p></li>
<li><p>Also note that England is close to the origin, meaning that the food consumption pattern is close to the average pattern in the UK.</p></li>
<li><p>A few questions remain:</p>
<ul>
<li>How well can the 17-dimensional data be represented in a 2-dimensional subspace?</li>
<li>How can we interpret the distances (differences) between the data points in terms of the original 17 variables?</li>
</ul></li>
</ul>
</div>
<div id="the-biplot" class="section level2">
<h2><span class="header-section-number">7.5</span> The biplot</h2>
<p>The biplot is a single 2-dimensional graph which displays the information in both <span class="math inline">\(\mathbf{Z}_2=\mathbf{U}_2\boldsymbol{\Delta}_2\)</span> and <span class="math inline">\(\mathbf{V}_2\)</span>.</p>
<p>The plot of <span class="math inline">\(\mathbf{Z}_2\)</span> has been discussed previously (e.g. best approximation of distances).</p>
<p>The name “bi”plot refers to the plotting of two parts of the SVD (<span class="math inline">\(\mathbf{Z}\)</span> and <span class="math inline">\(\mathbf{V}\)</span>) in a single graph.</p>
<p>From the geometrical interpretation of the SVD we know that <span class="math inline">\(\mathbf{Z}_2\)</span> is the orthogonal projection of <span class="math inline">\(\mathbf{X}\)</span> on <span class="math inline">\(\mathbf{V}_2\)</span> the basis spanned by the first two singular values. Thus for the <span class="math inline">\(i^\text{th}\)</span> individual we get <span class="math display">\[
\mathbf{z}_{2,i}= \mathbf{x}_i \left[\begin{array}{cc}\mathbf{v}_1&amp;\mathbf{v}_2\end{array}\right]
\]</span></p>
<p>We also know that we can approximate <span class="math inline">\(\mathbf{X}\)</span> by <span class="math inline">\(\mathbf{X}_2\)</span> which equals:</p>
<p><span class="math display">\[\begin{align}
  \mathbf{X}_2 &amp;= \mathbf{Z_2}\mathbf{V}_2^T\\
  &amp;= \mathbf{Z_2}\left[\begin{array}{c} \mathbf{v}_1^T\\
      \mathbf{v}_2^T\end{array}\right]
  = \mathbf{Z_2}
    \left[
      \begin{array}{ccc}\tilde{\mathbf{v}}_{2,1} \ldots \tilde{\mathbf{v}}_{2,p}\end{array}
    \right]
\end{align}\]</span></p>
<p>with <span class="math inline">\(\mathbf{v}_1\)</span> and <span class="math inline">\(\mathbf{v}_2\)</span> the first two right singular vector and <span class="math inline">\(\tilde{\mathbf{v}}_j\)</span> the j<span class="math inline">\(^\text{th}\)</span> column of the matrix <span class="math inline">\(\mathbf{V}_2^T\)</span>.</p>
<ul>
<li>This basically shows us that the orthogonal projection of <span class="math inline">\(\mathbf{z}_{2,i}\)</span> for subject/experimental unit i on <span class="math inline">\(\tilde{\mathbf{v}}_{2,j}\)</span> gives us the approximation of the value for j<span class="math inline">\(^\text{th}\)</span> variable that was observed for the <span class="math inline">\(i^\text{th}\)</span> experimental unit, i.e. <span class="math inline">\(x_{2,ij}\)</span>. <span class="math display">\[x_{2,ij}=\mathbf{z}_{2,i}^T\tilde{\mathbf{v}}_{2,j}\]</span></li>
</ul>
<div id="uk-example" class="section level3">
<h3><span class="header-section-number">7.5.1</span> UK example</h3>
<div id="biplot" class="section level4">
<h4><span class="header-section-number">7.5.1.1</span> Biplot</h4>
<pre class="r"><code>Vk &lt;- svdUk$v[,1:k]
rownames(Vk) &lt;- uk[[1]]
colnames(Vk) &lt;- colnames(Zk)
scaleFactor &lt;- mean(svdUk$d[1:k])

diyBiplot &lt;- ggplot() +
  geom_point(
    data=Zk %&gt;% as.data.frame,
    aes(x=Z1,y=Z2),
    size = 3) +
  geom_text(
    data=Zk %&gt;% as.data.frame,
    aes(x=Z1,y=Z2,label=rownames(Zk)),
    nudge_x = 50) +
  geom_segment(
    data=Vk %&gt;% as.data.frame,
    aes(x=0, y=0, xend=Z1*scaleFactor, yend=Z2*scaleFactor),
    arrow=arrow(length=unit(0.4,&quot;cm&quot;)),
    alpha=0.25) +
  geom_text(
    data=Vk %&gt;% as.data.frame,
    aes(x=Z1*scaleFactor, y=Z2*scaleFactor, label=rownames(Vk)),
    alpha=0.5,
    size=3)

diyBiplot</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<pre class="r"><code>biplot(Zk,Vk)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-28-2.png" width="672" /></p>
<p>The R code shows two ways of constructing a biplot: the first method starts from the SVD of <span class="math inline">\(\mathbf{X}\)</span> and plots the p vectors <span class="math inline">\(\tilde{\mathbf{v}}_{2,j}\)</span> as arrows. Note that we used a scaling factor to give the arrows a convenient length in the graph (not too small, not too large); it does not affect the interpretation. The second way of obtaining the biplot is simply by using the R built-in function biplot.</p>
</div>
<div id="illustration-of-projection" class="section level4">
<h4><span class="header-section-number">7.5.1.2</span> Illustration of projection</h4>
<p>We project <span class="math inline">\(\mathbf{z}_{2,i}\)</span> for N.Ireland on Fresh_potatoes.</p>
<p><img src="svd_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<pre class="r"><code>rownames(X) &lt;- rownames(Zk)
colnames(X) &lt;- rownames(Vk)
X[,&quot;Fresh_potatoes&quot;]</code></pre>
<pre><code>##   England     Wales  Scotland N.Ireland 
##    -78.25     75.75   -232.25    234.75</code></pre>
<pre class="r"><code>Zk[&quot;N.Ireland&quot;,]%*%Vk[&quot;Fresh_potatoes&quot;,]</code></pre>
<pre><code>##          [,1]
## [1,] 233.7418</code></pre>
<p>We observe that N. Ireland has a consumption in Fresh_potatoes that is 234.75 above the average and this is well approximated by the projection 233.74.</p>
<p>Also note that</p>
<ul>
<li><p>The origin corresponds to the sample average of the 17-dimensional observations in the data matrix</p></li>
<li><p>England is close to the origin and thus one could say that the food consumption in England is as the average in the UK</p></li>
<li><p>Projecting the <span class="math inline">\(\mathbf{Z}_2\)</span> coordinates for North Ireland orthogonally onto the vector <span class="math inline">\(\tilde{\mathbf{v}}_{2,j}\)</span> of fresh potatoes, we get a large and positive <span class="math inline">\(x_{2,ij}\)</span>. Hence, people in N. Ireland tend to eat more fresh potatoes than on average in the UK.</p></li>
<li><p>We can do the same for the other vectors.</p></li>
</ul>
</div>
</div>
<div id="further-interpretation-of-the-biplot" class="section level3">
<h3><span class="header-section-number">7.5.2</span> Further interpretation of the Biplot</h3>
<p>From <span class="math inline">\(\mathbf{x}_{k,i}^T = \mathbf{z}_{k,i}^T\mathbf{V}_k^T\)</span> we learnt that the original data can be (approximately) reconstructed from the <span class="math inline">\(\mathbf{z}_{k,i}\)</span>.</p>
<p>We now show how the dimensions of <span class="math inline">\(\mathbf{Z}_k\)</span> (columns or variables) can be interpreted. Remember, <span class="math display">\[
  \mathbf{z}_{k,i}^T = \mathbf{x}_i^T\mathbf{V}_k = \left(\mathbf{x}_i^T \mathbf{v}_1 , \mathbf{x}_i^T \mathbf{v}_2 , \ldots , \mathbf{x}_i^T \mathbf{v}_k\right).
 \]</span></p>
<p>The <span class="math inline">\(j\)</span>th column of <span class="math inline">\(\mathbf{Z}_k\)</span> can be written as <span class="math display">\[
   \mathbf{z}_{k,j} = \mathbf{X}\mathbf{v}_j,
 \]</span></p>
<p>An individual element of <span class="math inline">\(\mathbf{Z}_k\)</span> can be written as <span class="math display">\[
   z_{k,ij} = \mathbf{x}_i^T\mathbf{v}_j,
 \]</span></p>
<p>which is a linear combination of the observations on the <span class="math inline">\(p\)</span> variables in <span class="math inline">\(\mathbf{x}_i\)</span>, with coefficients given by the <span class="math inline">\(p\)</span> elements in <span class="math inline">\(\mathbf{v}_j\)</span>. Understanding the elements in <span class="math inline">\(\mathbf{v}_j\)</span> will give us insight into the interpretation of the <span class="math inline">\(j\)</span>th dimension of <span class="math inline">\(\mathbf{Z}_k\)</span>.</p>
</div>
</div>
<div id="illustration-uk-food" class="section level2">
<h2><span class="header-section-number">7.6</span> Illustration Uk food</h2>
<pre class="r"><code>p1 &lt;- ggplot() +
  geom_bar(
    aes( x=rownames(Vk), y=Vk[,1]),
    stat=&quot;identity&quot;) +
  xlab(&quot;V1&quot;) +
  ylab(&quot;contribution&quot;) +
  coord_flip()

p2 &lt;-
ggplot() +
  geom_bar(
    aes( x=rownames(Vk), y=Vk[,2]),
    stat=&quot;identity&quot;) +
  xlab(&quot;V2&quot;) +
  ylab(&quot;contribution&quot;) +
  coord_flip()

grid.arrange(p1,p2,ncol=2)</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
<p>In giving an interpretation to the elements in <span class="math inline">\(\mathbf{v}_1\)</span> and <span class="math inline">\(\mathbf{v}_2\)</span>, we ignore the elements close to zero (this is a subjective decision; later we see more objective methods).</p>
<p>For <span class="math inline">\(\mathbf{v}_1\)</span> (1st dimension of <span class="math inline">\(\mathbf{Z}_2\)</span>):</p>
<ul>
<li><p>contrast of soft drinks and fresh potatoes versus fresh fruit and alcoholic drinks</p></li>
<li><p>a large value of <span class="math inline">\(z_{i1}\)</span> can result from eating many fresh potatoes and drinking a lot of soft drinks, but eating only few fresh fruit and drinking not much alcoholic drinks</p></li>
<li><p>a small value of <span class="math inline">\(z_{i1}\)</span> can result from eating few fresh potatoes and drinking only few soft drinks, but eating a lot of fresh fruit and drinking much alcoholic drinks</p></li>
</ul>
<p>For <span class="math inline">\(\mathbf{v}_2\)</span> (2nd dimension of <span class="math inline">\(\mathbf{Z}_2\)</span>):</p>
<ul>
<li><p>contrast of soft drinks versus fresh potatoes</p></li>
<li><p>a large value of <span class="math inline">\(z_{i2}\)</span> can result from eating many fresh potatoes, but drinking not much soft drinks</p></li>
<li><p>a small value of <span class="math inline">\(z_{i2}\)</span> can result from eating few fresh potatoes, but drinking much soft drinks .</p></li>
</ul>
<hr />
<p>The elements in v1 and v2 are also shown in the biplot.</p>
<pre class="r"><code>grid.arrange(p1, p2, diyBiplot, ncol=2, layout_matrix = rbind(c(1,2),c(3,3)))</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
<p>From the graph we see e.g. that N. Ireland has a high score for the first dimension. Now that we can give an interpretation to the dimension, we conclude that in Northern Ireland people eat relatively much fresh potatoes and drink many soft drinks, but they do not drink much alcoholic drinks and eat not much fresh fruit. We had already come to these findings by projecting N. Ireland on the vectors of these four food products. This comes to no surprise: both interpretations arise from the same data set and its SVD, and so no contradictory results should arise. Other conclusions can be found in a similar fashion.</p>
<p>We have derived the interpretation of the first dimension from the barplot of the elements of <span class="math inline">\(\mathbf{v}_1\)</span>. However, there is actually no need to make a separate plot to read the elements of <span class="math inline">\(\mathbf{v}_1\)</span>; they can also be read from projecting the vectors in the biplot onto the first dimension (i.e. basis vector of the first dimension). For example, fresh potatoes is in the 7th column of <span class="math inline">\(\mathbf{X}\)</span> and thus in the biplot its vector is <span class="math inline">\(\tilde{\mathbf{v}}_{2,7}\)</span>; it is a 2-dimensional vector (2-dimensional biplot is shown). In the space of the biplot (i.e. the column space of <span class="math inline">\(\mathbf{Z}_2\)</span>), the first basis vector is given by <span class="math inline">\((1,0)\)</span>. Projecting <span class="math inline">\(\tilde{\mathbf{v}}_{2,7}^T\)</span> orthogonally onto <span class="math inline">\((1,0)\)</span> gives <span class="math display">\[
  \tilde{\mathbf{v}}_{2,7}^T  \begin{pmatrix} 1 \\ 0 \end{pmatrix} = (v_{71} , v_{72}) \begin{pmatrix} 1 \\ 0 \end{pmatrix} = v_{71}
\]</span> which is the seventh element of the first right-singular vector of <span class="math inline">\(\mathbf{X}\)</span>, which is thus the bar of fresh potatoes in the barplot of the first dimension.</p>
</div>
</div>
<div id="svd-and-principal-component-analysis-pca" class="section level1">
<h1><span class="header-section-number">8</span> SVD and principal component analysis (PCA)</h1>
<ul>
<li><p>PCA is basically a SVD</p></li>
<li><p>PCA adds another layer of interpretation</p></li>
<li><p>PCA comes with its own terminology</p></li>
<li><p>One of the most widely used algorithms for dimension reduction and data exploration of multivariate and high dimensional data.</p></li>
<li><p>It is motivated from the decomposition of the Variance covariance matrix of the data</p></li>
</ul>
<div id="variance-covariance-matrix" class="section level2">
<h2><span class="header-section-number">8.1</span> Variance covariance matrix</h2>
<ul>
<li>For a given centered data matrix <span class="math inline">\(\mathbf{X}\)</span> the <span class="math inline">\(p\times p\)</span> covariance matrix can be estimated by <span class="math display">\[
\boldsymbol{\Sigma}_X = \frac{1}{n-1}\mathbf{X}^T\mathbf{X} =\frac{1}{n-1}\sum_{i=1}^n \mathbf{x}_i\mathbf{x}_i^T,
  \]</span> i.e. the <span class="math inline">\((i,j)\)</span>th element is given by (column means are zero) <span class="math display">\[
\frac{1}{n-1}\sum_{m=1}^n x_{mi}x_{mj}=\frac{1}{n-1}\sum_{m=1}^n (x_{mi}-\bar{x}_i)(x_{mj}-\bar{x}_j).
  \]</span></li>
</ul>
<p>Note, that when we forget to write the factor <span class="math inline">\(1/(n-1)\)</span> all the derivations still hold. It is only a proportionality factor and it does not affect the interpretation.</p>
<hr />
</div>
<div id="conventional-derivation-of-pca" class="section level2">
<h2><span class="header-section-number">8.2</span> Conventional derivation of PCA</h2>
<p>PCA is usually introduced as follows.</p>
<p>Let <span class="math display">\[
  y_i=\mathbf{x}_i^T\mathbf{a}
\]</span> with <span class="math inline">\(\mathbf{a}\)</span> a <span class="math inline">\(p\)</span>-vector of constants. Hence <span class="math inline">\(y_i\)</span> is a linear combination (or transformation) of <span class="math inline">\(\mathbf{x}_i\)</span>.</p>
<p>PCA aims at finding <span class="math inline">\(\mathbf{a}\)</span> such that the sample variance among the <span class="math inline">\(n\)</span> <span class="math inline">\(y_i\)</span>’s is maximal, with <span class="math display">\[\begin{eqnarray*}
  \frac{1}{n-1}\sum_{i=1}^n (y_i - \bar{y})^2 =  \frac{1}{n-1}\sum_{i=1}^n y_i ^2 \\
    &amp;=&amp; \frac{1}{n-1}\sum_{i=1}^n (\mathbf{x}_i^T\mathbf{a})^2 = \frac{1}{n-1} \mathbf{a}^T \left(\sum_{i=1}^n \mathbf{x}_i\mathbf{x}_i^T\right) \mathbf{a} \\
    &amp;=&amp; \frac{1}{n-1} \mathbf{a}^T\mathbf{X}^T\mathbf{X}\mathbf{a} = \mathbf{a}^T\boldsymbol{\Sigma}_X\mathbf{a}
\end{eqnarray*}\]</span> in which <span class="math inline">\(\boldsymbol{\Sigma}_X= \frac{1}{n-1}\mathbf{X}^T\mathbf{X}\)</span> is the sample covariance matrix of <span class="math inline">\(\mathbf{X}\)</span>.</p>
<div id="problem-for-optimisation" class="section level3">
<h3><span class="header-section-number">8.2.1</span> Problem for optimisation</h3>
<p>Finding <span class="math inline">\(\mathbf{a}\)</span> that maximises <span class="math display">\[
  \text{var}[y]  = \mathbf{a}^T\boldsymbol{\Sigma}_X\mathbf{a}
\]</span> has a trivial solution (set all elements of <span class="math inline">\(\mathbf{a}\)</span> equal to <span class="math inline">\(\infty\)</span>). To avoid the trivial solution, the solution must satisfy a restriction, e.g. <span class="math display">\[
  \Vert \mathbf{a}\Vert^2 = \mathbf{a}^T\mathbf{a}=1.
\]</span></p>
<p>The solution of the constrained maximisation problem may be formulated as <span class="math display">\[
  \mathbf{a} = \text{ArgMax}_{b:\Vert b\Vert^2=1} \mathbf{b}^T\boldsymbol{\Sigma}_X\mathbf{b}.
\]</span> By introducing a Lagrange multiplier <span class="math inline">\(\lambda\)</span>, we get an unconstrained maximisation problem, <span class="math display">\[
  \mathbf{a} = \text{ArgMax}_{b} \left(\mathbf{b}^T\boldsymbol{\Sigma}_X\mathbf{b}-\lambda(\mathbf{b}^T\mathbf{b}-1)\right).
\]</span></p>
<hr />
<p>Note that,</p>
<ul>
<li><p>If the constraint is linear, then the constrained optimisation problem (here: maximisation) may be replaced by an unconstrained optimisation problem of the same criterion but with an ``penalty term’’ added. This method is due to Lagrange. The penalty term vanishes when the constraint is satisfied.</p></li>
<li><p>If the constraint is satisfied, <span class="math inline">\(\mathbf{b}^T\mathbf{b}=\Vert \mathbf{b}\Vert^2=1\)</span> and thus <span class="math inline">\(\mathbf{b}^T\mathbf{b}-1=0\)</span> and the ``penalty’’ term in the unconstrained criterion vanishes.</p></li>
<li><p>The Lagrange multiplier <span class="math inline">\(\lambda\)</span> is to be considered as an extra parameter that may have to be estimated from the data.</p></li>
</ul>
<hr />
<p>The solution of <span class="math display">\[
  \mathbf{a} = \text{ArgMax}_{b} \left(\mathbf{b}^T\boldsymbol{\Sigma}_X\mathbf{b}-\lambda(\mathbf{b}^T\mathbf{b}-1)\right)
\]</span> is obtained by differentiating <span class="math inline">\(\mathbf{b}^T\boldsymbol{\Sigma}_X\mathbf{b}-\lambda(\mathbf{b}^T\mathbf{b}-1)\)</span> w.r.t. <span class="math inline">\(\mathbf{b}\)</span>, equating it to zero and solving for <span class="math inline">\(\mathbf{b}\)</span>. <span class="math display">\[\begin{eqnarray*}
 \frac{\partial}{\partial \mathbf{b}} \left(\mathbf{b}^T\boldsymbol{\Sigma}_X\mathbf{b}-\lambda(\mathbf{b}^T\mathbf{b}-1)\right)
    &amp;=&amp; 0 \\
    2\boldsymbol{\Sigma}_X\mathbf{b} -2\lambda\mathbf{b}
    &amp;=&amp; 0.
\end{eqnarray*}\]</span></p>
<p>Hence, we need the solution of <span class="math display">\[
  \boldsymbol{\Sigma}_X\mathbf{b} = \lambda\mathbf{b}.
\]</span></p>
<p>This equation has <span class="math inline">\(r\)</span> solutions:</p>
<ul>
<li><p><span class="math inline">\(\mathbf{b}=\mathbf{e}_j\)</span>: the <span class="math inline">\(j\)</span>th eigenvector of <span class="math inline">\(\boldsymbol{\Sigma}_X\)</span></p></li>
<li><p><span class="math inline">\(\lambda=\lambda_j\)</span>: the <span class="math inline">\(j\)</span>th eigenvalue of <span class="math inline">\(\boldsymbol{\Sigma}_X\)</span>.</p></li>
</ul>
<p>The eigenvectors are orthonormal, i.e. <span class="math inline">\(\mathbf{e}_i^T\mathbf{e}_j=1\)</span> if <span class="math inline">\(i=j\)</span> and <span class="math inline">\(\mathbf{e}_i^T\mathbf{e}_j=0\)</span> otherwise.</p>
<hr />
<p>Consider the following calculations, with <span class="math inline">\(\mathbf{b}=\mathbf{e}_j\)</span>, the <span class="math inline">\(j\)</span>the eigenvector of <span class="math inline">\(\boldsymbol{\Sigma}_X\)</span>. <span class="math display">\[\begin{eqnarray*}
  \text{var}[y]
    &amp;=&amp; \mathbf{e}_j^T\boldsymbol{\Sigma}_X\mathbf{e}_j \\
    &amp;=&amp; \mathbf{e}_j^T(\boldsymbol{\Sigma}_X\mathbf{e}_j) \\
    &amp;=&amp; \mathbf{e}_j^T \left(\lambda_j \mathbf{e}_j\right) \\
    &amp;=&amp; \lambda_j\mathbf{e}_j^T\mathbf{e}_j \\
    &amp;=&amp; \lambda_j.
\end{eqnarray*}\]</span> By convention the eigenvectors/eigenvalues are ordered so that <span class="math display">\[
  \lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_r.
\]</span> Hence, the first eigenvector <span class="math inline">\(\mathbf{e}_1\)</span> gives the largest variance <span class="math inline">\(\lambda_1\)</span>. Hence, this is the solution we were looking for.</p>
<hr />
<p>We now switch notation and from now onwards we denote <span class="math inline">\(y\)</span> by <span class="math inline">\(z\)</span>.</p>
<p>The observations on the first principal component (PC) are then given by <span class="math display">\[
    z_{i1} = \mathbf{x}_i^T\mathbf{e}_1.
\]</span></p>
<p>In PCA terminology they are referred to as the <strong>scores</strong> of the first PC. The elements in the eigenvector <span class="math inline">\(\mathbf{e}_i\)</span> that make up the transformation are known as the <strong>loadings</strong> of the first PC.</p>
<p>The first PC is thus a new variable (construct) that has the largest variance among all linear transformations of the original variables.</p>
<p>Variability between observations is considered as informative to understand differences between the observations.</p>
<hr />
<p>The equation <span class="math display">\[
  \boldsymbol{\Sigma}_X\mathbf{b} = \lambda\mathbf{b}
\]</span> has <span class="math inline">\(r=\text{rank}(\boldsymbol{\Sigma}_X)\)</span> solutions. The eigenvectors are orthonormal, i.e. <span class="math display">\[
  \forall i\neq j: \mathbf{e}_i^T \mathbf{e}_j = 0 \text{ and } i=j: \mathbf{e}_i^T \mathbf{e}_j = 1
\]</span> Hence (for <span class="math inline">\(i\neq j\)</span>) <span class="math display">\[
  \text{cov}\left[\mathbf{x}^T\mathbf{e}_i,\mathbf{x}^T\mathbf{e}_j\right] = \mathbf{e}_i^T\text{var}[\mathbf{x}]\mathbf{e}_j = \mathbf{e}_i^T\boldsymbol{\Sigma}_X\mathbf{e}_j = \mathbf{e}_i^T\left(\lambda_j\mathbf{e}_j\right) = \lambda_j \mathbf{e}_i^T\mathbf{e}_j = 0
\]</span></p>
<p>If <span class="math inline">\(z_{j}=\mathbf{x}_i^T\mathbf{e}_j\)</span> denotes the <span class="math inline">\(j\)</span>th PC, then <span class="math display">\[
  \text{cov}\left[z_i,z_j\right]=\text{cov}\left[\mathbf{x}^T\mathbf{e}_i,\mathbf{x}^T\mathbf{e}_j\right] =0 \text{ if } i\neq j
\]</span> <span class="math display">\[
  \text{var}\left[z_j\right] = \lambda_j .
\]</span> We say that the <span class="math inline">\(j\)</span>th PC maximises the variance among all linear transformations such that it is uncorrelated with the previous PCs.</p>
<hr />
</div>
<div id="interpretation-of-pca" class="section level3">
<h3><span class="header-section-number">8.2.2</span> Interpretation of PCA</h3>
<p>A PCA is a transformation of the original <span class="math inline">\(p\)</span> variables to <span class="math inline">\(r\)</span> PCs such that</p>
<ul>
<li><p>the first PC has largest variance, equal to first eigenvalue of <span class="math inline">\(\boldsymbol{\Sigma}_X\)</span></p></li>
<li><p>the next PCs have decreasing variances (decreasing information content)</p></li>
<li><p>all PCs are mutually uncorrelated (no information-overlap).</p></li>
</ul>
<hr />
</div>
</div>
<div id="link-with-svd" class="section level2">
<h2><span class="header-section-number">8.3</span> Link with SVD</h2>
<p>If we write the eigen value decomposition in matrix form: <span class="math display">\[
\boldsymbol{\Sigma}_X\mathbf{
  B} = \mathbf{B}\boldsymbol{\Lambda}.
\]</span></p>
<p>with <span class="math inline">\(\boldsymbol{\Lambda}\)</span> is a diagonal matrix with diagonal elements <span class="math inline">\([\lambda_i]_{ii}\)</span>.</p>
<p>We recognise an expression that we have seen when discussing the link between the SVD and the sample covariance matrix</p>
<p><span class="math display">\[\begin{eqnarray}
\mathbf{X}^T\mathbf{X}\mathbf{V} &amp;=&amp;\mathbf{V}\boldsymbol{\Delta}^2
\end{eqnarray}\]</span></p>
<ul>
<li>So, the SVD can be used to solve the spectral decomposition (eigen value eigen vector) problem and the eigen vectors coincide with the right singular vectors and the eigen values are the singular values squared!</li>
</ul>
</div>
<div id="conservation-of-variance" class="section level2">
<h2><span class="header-section-number">8.4</span> Conservation of variance</h2>
<ul>
<li><p>The total variance in a data set <span class="math inline">\(\mathbf{X}\)</span> is given by the sum of the variances of the variables, <span class="math display">\[
  \sigma^2_{\text{tot}} = \sum_{j=1}^p \text{var}\left[X_j\right] = \text{trace}(\boldsymbol{\Sigma}_X)
\]</span></p></li>
<li><p>For a symmetric matrix it holds that <span class="math display">\[
 \text{trace}(\boldsymbol{\Sigma}_X) = \sum_{j=1}^r \lambda_r.
  \]</span></p></li>
<li><p>Since <span class="math inline">\(\lambda_r=\text{var}\left[Z_j\right]\)</span>, we find <span class="math display">\[
 \sigma^2_{\text{tot}} = \sum_{j=1}^p \text{var}\left[X_j\right]= \sum_{j=1}^r \text{var}\left[Z_j\right].
  \]</span></p></li>
</ul>
<p><span class="math inline">\(\longrightarrow\)</span> Thus no information is lost by the PCA transformation from the original <span class="math inline">\(p\)</span>-dimensional space to the <span class="math inline">\(r\)</span>-dimensional PCA space.</p>
<hr />
</div>
<div id="choosing-the-number-of-dimensions" class="section level2">
<h2><span class="header-section-number">8.5</span> Choosing the number of dimensions</h2>
<p>For PCA the reasoning is usually based on the relative variance of a PC, <span class="math display">\[
   \frac{\text{var}\left[Z_j\right]}{\sigma^2_{\text{tot}}} = \frac{\lambda_j}{\sum_{i=1}^r \lambda_i} =\frac{\delta_j^2}{\sum_{i=1}^r \delta_i^2} .
\]</span> If the first <span class="math inline">\(k\)</span> PCs are selected for further use, then they represent <span class="math display">\[
  100 \times  \frac{\sum_{j=1}^k \lambda_j}{\sum_{i=1}^r \lambda_i} \%
  = 100 \times  \frac{\sum_{j=1}^k \delta^2_j}{\sum_{i=1}^r \delta_i^2} \%
\]</span> of the total variance (or information) of the original data set <span class="math inline">\(\mathbf{X}\)</span>.</p>
<div id="uk-example-1" class="section level3">
<h3><span class="header-section-number">8.5.1</span> UK example</h3>
<p>A scree plot is often used to look at the eigenvalues. Here it is shown for the UK consumption data.</p>
<pre class="r"><code>n &lt;- nrow(X)
r &lt;- ncol(svdUk$v)
totVar &lt;- sum(svdUk$d^2)/(n-1)
vars &lt;- data.frame(comp=1:4,var=svdUk$d^2/(n-1)) %&gt;%
  mutate(propVar=var/totVar,cumVar=cumsum(var/totVar))

pVar1 &lt;- vars %&gt;%
  ggplot(aes(x=comp:r,y=var)) +
  geom_point() +
  geom_line() +
  xlab(&quot;Component&quot;) +
  ylab(&quot;Variance&quot;)

pVar2 &lt;- vars %&gt;%
  ggplot(aes(x=comp:r,y=propVar)) +
  geom_point() +
  geom_line() +
  xlab(&quot;Component&quot;) +
  ylab(&quot;Proportion of Total Variance&quot;)

pVar3 &lt;- vars %&gt;%
  ggplot(aes(x=comp:r,y=cumVar)) +
  geom_point() +
  geom_line() +
  xlab(&quot;Component&quot;) +
  ylab(&quot;Cum. prop. of tot. var.&quot;)

grid.arrange(pVar1, pVar2, pVar3, nrow=1)</code></pre>
<pre><code>## Warning in comp:r: numerical expression has 4 elements: only the first used

## Warning in comp:r: numerical expression has 4 elements: only the first used

## Warning in comp:r: numerical expression has 4 elements: only the first used

## Warning in comp:r: numerical expression has 4 elements: only the first used

## Warning in comp:r: numerical expression has 4 elements: only the first used

## Warning in comp:r: numerical expression has 4 elements: only the first used

## Warning in comp:r: numerical expression has 4 elements: only the first used

## Warning in comp:r: numerical expression has 4 elements: only the first used

## Warning in comp:r: numerical expression has 4 elements: only the first used</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<p>From these graphs we may conclude that with using k = 2 dimensions, more than 95% of the total variance is retained.</p>
<hr />
</div>
<div id="choosing-the-number-of-dimensions-svd" class="section level3">
<h3><span class="header-section-number">8.5.2</span> Choosing the number of dimensions SVD</h3>
<p>More generally, scree plots are also informative for the SVD.</p>
<p>The motivation comes from <span class="math display">\[
    \text{Min}_{A: \text{rank}(A)=k} \Vert \mathbf{X} - \mathbf{A}\Vert_F^2 = \Vert \mathbf{X} - \mathbf{X}_k\Vert_F^2 = \sum_{j=k+1}^r\delta_{j}^2 = \sum_{j=k+1}^r\lambda_{j}.
  \]</span> This is known as the <strong>approximation error</strong> of the matrix <span class="math inline">\(\mathbf{X}_k\)</span>.</p>
<p>Hence, <span class="math display">\[
    \frac{\sum_{j=1}^k\delta_j^2}{\sum_{j=1}^r \delta_j^2}  =\frac{\sum_{j=1}^k\lambda_{j}}{\sum_{j=1}^r\lambda_{j}}
  \]</span> still makes sense as a relative quality measure for the SVD in general (including matrix approximation and MDS).</p>
</div>
<div id="rules-of-thumb-to-select-number-of-dimensions" class="section level3">
<h3><span class="header-section-number">8.5.3</span> Rules of thumb to select number of dimensions</h3>
<p>Select k such that</p>
<ul>
<li><p>at least 80% of the total variance is retained in the PC space, or, equivalently, at most 20% relative approximation error</p></li>
<li><p>adding more dimensions does not add more information (in a relative sense); this can often be visually detected as the “knee” or “elbow” in the scree plot</p></li>
<li><p>none of the dimensions has a variance smaller than the variance of one of the p original variables (this rule is typically only used when the variables are first standardised - see later).</p></li>
</ul>
</div>
</div>
<div id="covariance-vs-correlation-matrix" class="section level2">
<h2><span class="header-section-number">8.6</span> Covariance vs Correlation Matrix</h2>
<div id="direction-of-largest-variability" class="section level3">
<h3><span class="header-section-number">8.6.1</span> Direction of largest variability</h3>
<p>Now that we know how the PCs are constructed, we can give an additional interpretation to the first eigenvector / right-singular vector of <span class="math inline">\(\boldsymbol{\Sigma}_X\)</span>.</p>
<ul>
<li><p>The first eigenvector of <span class="math inline">\(\boldsymbol{\Sigma}_X\)</span> is the direction in the original <span class="math inline">\(p\)</span>-dimensional space of the largest variability.</p></li>
<li><p>The second eigenvector of <span class="math inline">\(\boldsymbol{\Sigma}_X\)</span> is the direction in the original <span class="math inline">\(p\)</span>-dimensional space of the second largest variability, among all directions orthogonal to the first eigenvector</p></li>
</ul>
<div id="iris-example" class="section level4">
<h4><span class="header-section-number">8.6.1.1</span> Iris example</h4>
<p>The iris dataset in R contains information on leaves of iris flowers from different species. Here, we will focus on the setosa species and on the sepal length and sepal width.</p>
<pre class="r"><code>irisSetosa &lt;- iris %&gt;%
  filter(Species == &quot;setosa&quot;) %&gt;%
  dplyr::select(&quot;Sepal.Length&quot;,&quot;Sepal.Width&quot;)

nIris &lt;- nrow(irisSetosa)
hIris &lt;- diag(nIris) - matrix(1/nIris, nIris, nIris)
irisX &lt;- irisSetosa %&gt;%
  as.matrix
irisX &lt;- hIris %*% irisX

irisSvd &lt;- svd(irisX)

pIris &lt;- irisX %&gt;%
  as.data.frame %&gt;%
  ggplot(aes(x=Sepal.Length,y=Sepal.Width)) +
  geom_point()

pIris &lt;- pIris +
  geom_segment(
    aes(
      x = 0,
      y = 0,
      xend = -irisSvd$v[1,1]*irisSvd$d[1]/sqrt(nIris-1),
      yend = -irisSvd$v[2,1]*irisSvd$d[1]/sqrt(nIris-1)
      ),
      arrow = arrow(length=unit(0.4,&quot;cm&quot;))
    ) +
  geom_segment(
    aes(
      x = 0,
      y = 0,
      xend = irisSvd$v[1,2]*irisSvd$d[2]/sqrt(nIris-1),
      yend = irisSvd$v[2,2]*irisSvd$d[2]/sqrt(nIris-1)
      ),
    arrow = arrow(length=unit(0.4,&quot;cm&quot;))
    ) +
  geom_text(
    aes(
      x = -irisSvd$v[1,1]*irisSvd$d[1]/sqrt(nIris-1)*1.2,
      y = -irisSvd$v[2,1]*irisSvd$d[1]/sqrt(nIris-1)*1.2,
      label=&quot;e1&quot;
      )
    ) +
  geom_text(
    aes(
      x = irisSvd$v[1,2]*irisSvd$d[2]/sqrt(nIris-1)*1.2,
      y = irisSvd$v[2,2]*irisSvd$d[2]/sqrt(nIris-1)*1.2,
      label=&quot;e2&quot;
      )
    ) +
  xlim(-1, 1) +
  ylim(-1,1)

pIris</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_point).</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
</div>
</div>
<div id="covariance-versus-correlation-matrix" class="section level3">
<h3><span class="header-section-number">8.6.2</span> Covariance versus correlation matrix</h3>
<p>So far we have worked with</p>
<ul>
<li><p>the column-centered data matrix <span class="math inline">\(\mathbf{X}\)</span></p></li>
<li><p>the SVD of <span class="math inline">\(\mathbf{X}\)</span> and <span class="math inline">\(\boldsymbol{\Sigma}_X\propto \mathbf{X}^T\mathbf{X}\)</span> (the covariance matrix).</p></li>
</ul>
<p>In some situations it is better to start from the standardised variables:</p>
<ul>
<li>substract from each element in <span class="math inline">\(\mathbf{X}\)</span> the column-mean</li>
<li>divide each centered element in <span class="math inline">\(\mathbf{X}\)</span> by the column-specific standard deviation</li>
</ul>
<p>Thus each element <span class="math inline">\(x_{ij}\)</span> is replaced with <span class="math display">\[
     \frac{x_{ij}-\bar{x}_j}{s_j} ,
  \]</span> with <span class="math inline">\(\bar{x}_j\)</span> and <span class="math inline">\(s_j\)</span> the column mean and column standard deviation.</p>
<ul>
<li>In matrix notation, the standardisation, starting from the centered matrix <span class="math inline">\(\mathbf{X}\)</span> is computed as <span class="math display">\[
  \mathbf{X}\mathbf{S}^{\prime-1}
  \]</span> where <span class="math inline">\(\mathbf{S}^\prime\)</span> is a diagonal matrix with the column-specific standard deviations.</li>
</ul>
<hr />
<div id="iris-example-1" class="section level4">
<h4><span class="header-section-number">8.6.2.1</span> Iris Example</h4>
<pre class="r"><code>var(irisX)</code></pre>
<pre><code>##              Sepal.Length Sepal.Width
## Sepal.Length   0.12424898  0.09921633
## Sepal.Width    0.09921633  0.14368980</code></pre>
<pre class="r"><code>Sprime &lt;- diag(sqrt(diag(var(irisX))))
Xs &lt;- irisX%*%solve(Sprime)
var(Xs)</code></pre>
<pre><code>##           [,1]      [,2]
## [1,] 1.0000000 0.7425467
## [2,] 0.7425467 1.0000000</code></pre>
<p>Much faster to use the scale function. By default center=TRUE and scale=TRUE.</p>
<pre class="r"><code>Xs &lt;- irisSetosa %&gt;% scale
var(Xs)</code></pre>
<pre><code>##              Sepal.Length Sepal.Width
## Sepal.Length    1.0000000   0.7425467
## Sepal.Width     0.7425467   1.0000000</code></pre>
<p>Show problem of different units:</p>
<ul>
<li>Sepal length in cm</li>
<li>Sepal width in mm</li>
</ul>
<pre class="r"><code>irisX2 &lt;- irisX
irisX2[,2] &lt;- irisX2[,2]*10

pIris2 &lt;- irisX2 %&gt;%
  as.data.frame %&gt;%
  ggplot(aes(x=Sepal.Length,y=Sepal.Width)) +
  geom_point()

irisSvd2 &lt;- svd(irisX2)

pIris2 &lt;- pIris2 +
  geom_segment(
    aes(
      x = 0,
      y = 0,
      xend = irisSvd2$v[1,1]*irisSvd2$d[1]/sqrt(nIris-1),
      yend = irisSvd2$v[2,1]*irisSvd2$d[1]/sqrt(nIris-1)
      ),
      arrow = arrow(length=unit(0.4,&quot;cm&quot;))
    ) +
  geom_segment(
    aes(
      x = 0,
      y = 0,
      xend = irisSvd2$v[1,2]*irisSvd2$d[2]/sqrt(nIris-1),
      yend = irisSvd2$v[2,2]*irisSvd2$d[2]/sqrt(nIris-1)
      ),
    arrow = arrow(length=unit(0.4,&quot;cm&quot;))
    ) +
  geom_text(
    aes(
      x = irisSvd2$v[1,1]*irisSvd2$d[1]/sqrt(nIris-1)*1.2,
      y = irisSvd2$v[2,1]*irisSvd2$d[1]/sqrt(nIris-1)*1.2,
      label=&quot;e1&quot;
      )
    ) +
  geom_text(
    aes(
      x = irisSvd2$v[1,2]*irisSvd2$d[2]/sqrt(nIris-1)*1.2,
      y = irisSvd2$v[2,2]*irisSvd2$d[2]/sqrt(nIris-1)*1.2,
      label=&quot;e2&quot;
      )
    ) +
  xlim(-10, 10) +
  ylim(-10,10)

grid.arrange(pIris, pIris2)</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_point).

## Warning: Removed 1 rows containing missing values (geom_point).</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
<p>Top: original matrix – Bottom: second column of <span class="math inline">\(\mathbf{X}\)</span> multiplied by 10 (e.g. moving from cm to mm).</p>
<p>Directions of maximal variability are affected by the units of the variables.</p>
<hr />
</div>
</div>
<div id="recommendations" class="section level3">
<h3><span class="header-section-number">8.6.3</span> Recommendations</h3>
<p>When to use correlation and when covariance?</p>
<ul>
<li><p>use correlation when columns of <span class="math inline">\(\mathbf{X}\)</span> are expressed in different units</p></li>
<li><p>use covariance when columns of <span class="math inline">\(\mathbf{X}\)</span> are expressed in the same units.</p></li>
</ul>
<p>There may be exceptions.</p>
<hr />
</div>
</div>
<div id="pca-and-the-multivariate-normal-distribution" class="section level2">
<h2><span class="header-section-number">8.7</span> PCA and the Multivariate Normal Distribution</h2>
<p>The density function of a multivariate normal distribution (MVN) is given by <span class="math display">\[
  f(\mathbf{x}) = (2\pi)^{-p/2}\vert \boldsymbol{\Sigma}\vert^{-1/2} \exp\left( -\frac{1}{2} (\mathbf{x}-\boldsymbol{\mu})^T \boldsymbol{\Sigma}^{-1} (\mathbf{x}-\boldsymbol{\mu})\right) ,
\]</span> where</p>
<ul>
<li><p><span class="math inline">\(\boldsymbol{\mu}\)</span> is the multivariate mean vector (<span class="math inline">\(p\)</span>-dimensional). The <span class="math inline">\(j\)</span>th element is <span class="math inline">\(\mu_j = \text{E}\left[X_j\right]\)</span></p></li>
<li><p><span class="math inline">\(\boldsymbol{\Sigma}\)</span> is the <span class="math inline">\(p \times p\)</span> covariance matrix. The <span class="math inline">\((i,j)\)</span>th element is <span class="math inline">\(\sigma_{ij}=\text{cov}\left[X_i, X_j\right]\)</span>.</p></li>
</ul>
<hr />
<p>To get a better understanding of the MVN we focus on the exponential which has the factor <span class="math display">\[
    (\mathbf{x}-\boldsymbol{\mu})^T \boldsymbol{\Sigma}^{-1} (\mathbf{x}-\boldsymbol{\mu})
\]</span> This factor</p>
<ul>
<li><p>is the only factor in the density function that depends on <span class="math inline">\(\mathbf{x}\)</span></p></li>
<li><p>is a <span class="math inline">\(\mathbf{quadratic}\)</span> form</p></li>
<li><p>is constant in points <span class="math inline">\(\mathbf{x}\)</span> with constant density <span class="math inline">\(f(\mathbf{x})\)</span>.</p></li>
</ul>
<hr />
<p>Consider <span class="math inline">\(p=2\)</span> (bivariate normal). Then, all <span class="math inline">\(\mathbf{x} \in \mathbb{R}^2\)</span> for which <span class="math display">\[
    (\mathbf{x}-\boldsymbol{\mu})^T \boldsymbol{\Sigma}^{-1} (\mathbf{x}-\boldsymbol{\mu}) = \text{constant } c^2
\]</span> lie on an ellipse with center <span class="math inline">\(\boldsymbol{\mu}\)</span>.</p>
<p>These ellipses are known as <strong>constant density ellipses</strong>.</p>
<div id="iris-example-2" class="section level3">
<h3><span class="header-section-number">8.7.1</span> iris example</h3>
<pre class="r"><code>pIris +
  stat_ellipse() +
  stat_ellipse(level=.68) +
  stat_ellipse(level=.1)</code></pre>
<pre><code>## Warning: Removed 1 rows containing non-finite values (stat_ellipse).

## Warning: Removed 1 rows containing non-finite values (stat_ellipse).

## Warning: Removed 1 rows containing non-finite values (stat_ellipse).</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_point).</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-38-1.png" width="672" /></p>
<hr />
<p>Now plug in the SVD of <span class="math inline">\(\boldsymbol{\Sigma}=\mathbf{VDV}^T\)</span>, <span class="math display">\[\begin{eqnarray*}
   (\mathbf{x}-\boldsymbol{\mu})^T \boldsymbol{\Sigma}^{-1} (\mathbf{x}-\boldsymbol{\mu}) &amp;=&amp; c^2\\
   (\mathbf{x}-\boldsymbol{\mu})^T \mathbf{VD}^{-1}\mathbf{V}^T (\mathbf{x}-\boldsymbol{\mu}) &amp;=&amp; c^2
\end{eqnarray*}\]</span></p>
<p>Note that <span class="math inline">\(\mathbf{x}-\boldsymbol{\mu}\)</span> is the centered <span class="math inline">\(\mathbf{x}\)</span>. Without loss of generality, take <span class="math inline">\(\boldsymbol{\mu}=\mathbf{0}\)</span>. Hence, <span class="math display">\[\begin{eqnarray*}
   \mathbf{x}^T \mathbf{VD}^{-1}\mathbf{V}^T \mathbf{x} &amp;=&amp; c^2    \\
   \left(\mathbf{x}^T\mathbf{V}\right) \mathbf{D}^{-1} \left(\mathbf{x}^T\mathbf{V}\right)^T &amp;=&amp; c^2 \\
   \sum_{j=1}^p (\mathbf{x}^T\mathbf{v}_j)^2  / \delta_j &amp;=&amp; c^2\\
   \sum_{j=1}^p (z_j)^2  / (c^2\delta_j) &amp;=&amp; 1.
\end{eqnarray*}\]</span> The last equation is the equation of an ellipse with axes parallel to the basis of <span class="math inline">\((z_1,\ldots, z_p)\)</span> and with half axis lengths <span class="math inline">\(c\sqrt{\lambda_j}=c\delta_j\)</span> with <span class="math inline">\(\lambda_j\)</span> the <span class="math inline">\(j\)</span>th eigenvalue of <span class="math inline">\(\boldsymbol{\Sigma}\)</span>.</p>
<hr />
<pre class="r"><code>pIris +
  stat_ellipse() +
  stat_ellipse(level=.68) +
  stat_ellipse(level=.1)</code></pre>
<pre><code>## Warning: Removed 1 rows containing non-finite values (stat_ellipse).

## Warning: Removed 1 rows containing non-finite values (stat_ellipse).

## Warning: Removed 1 rows containing non-finite values (stat_ellipse).</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_point).</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-39-1.png" width="672" /></p>
<p>This graphs shows <span class="math inline">\(n=50\)</span> data points on <span class="math inline">\(p=2\)</span> dimensions. The two ellipses are constant density ellipses for three different values of <span class="math inline">\(c\)</span> (i.e. three different constant densities). The inner ellipse corresponds to the largest constant density and the outer to the smallest constant density. The arrows show the two eigenvectors / singular vectors and they are scaled according to the sqrt of the eigen values and they form the axes of the constant density ellipses. It is clear that the first axis is pointing to the larger variance.</p>
</div>
</div>
<div id="biplot-1" class="section level2">
<h2><span class="header-section-number">8.8</span> Biplot</h2>
<ul>
<li>Because of the close connection between PCA and the SVD, the biplot as discussed before is still meaningful, with the first axis pointing into the direction of largest variance.</li>
</ul>
</div>
<div id="ovarian-cancer-example" class="section level2">
<h2><span class="header-section-number">8.9</span> Ovarian Cancer Example</h2>
<p>The ovarian cancer data set consists of proteomics data for 216 patients, 121 of whom have ovarian cancer, and 95 of whom do not. For each subject, the expression of 4000 spectral features is assessed. The first 121 rows consist of data for the cancer patients.</p>
<div id="importing-the-data" class="section level3">
<h3><span class="header-section-number">8.9.1</span> Importing the data</h3>
<pre class="r"><code>ovarian &lt;- read_csv(
  &quot;https://raw.githubusercontent.com/statOmics/HDA2020/data/ovarian.csv&quot;,
  col_names = FALSE,
  col_types = cols()
)
grid.arrange(
  qplot(1:4000,
    ovarian[1,] %&gt;% unlist,
    geom=&quot;line&quot;,
    ylab=&quot;centered intensity&quot;,
    xlab=&quot;&quot;,main=&quot;cancer&quot;,
    ylim=range(ovarian[c(1,2,200,201),])),
  qplot(1:4000,
    ovarian[2,] %&gt;% unlist,
    geom=&quot;line&quot;,
    ylab=&quot;centered intensity&quot;,
    xlab=&quot;&quot;,main=&quot;cancer&quot;,
    ylim=range(ovarian[c(1,2,200,201),])),
  qplot(1:4000,
    ovarian[200,] %&gt;% unlist,
    geom=&quot;line&quot;,
    ylab=&quot;centered intensity&quot;,
    xlab=&quot;&quot;,main=&quot;Normal&quot;,
    ylim=range(ovarian[c(1,2,200,201),])),
  qplot(1:4000,
    ovarian[200,] %&gt;% unlist,
    geom=&quot;line&quot;,
    ylab=&quot;centered intensity&quot;,
    xlab=&quot;&quot;,main=&quot;Normal&quot;,
    ylim=range(ovarian[c(1,2,200,201),])),
  ncol=1
  )</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-40-1.png" width="672" /></p>
<p>Centering</p>
<pre class="r"><code>ovarian &lt;-  scale(ovarian, scale=FALSE)
grid.arrange(
  qplot(1:4000,
    ovarian[1,],
    geom=&quot;line&quot;,
    ylab=&quot;centered intensity&quot;,
    xlab=&quot;&quot;,main=&quot;cancer&quot;,
    ylim=range(ovarian[c(1,2,200,201),])),
  qplot(1:4000,
    ovarian[2,],
    geom=&quot;line&quot;,
    ylab=&quot;centered intensity&quot;,
    xlab=&quot;&quot;,main=&quot;cancer&quot;,
    ylim=range(ovarian[c(1,2,200,201),])),
  qplot(1:4000,
    ovarian[200,],
    geom=&quot;line&quot;,
    ylab=&quot;centered intensity&quot;,
    xlab=&quot;&quot;,main=&quot;Normal&quot;,
    ylim=range(ovarian[c(1,2,200,201),])),
  qplot(1:4000,
    ovarian[201,],
    geom=&quot;line&quot;,
    ylab=&quot;centered intensity&quot;,
    xlab=&quot;&quot;,main=&quot;Normal&quot;,
    ylim=range(ovarian[c(1,2,200,201),])),
  ncol=1
  )</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-41-1.png" width="672" /></p>
</div>
<div id="svd-analysis" class="section level3">
<h3><span class="header-section-number">8.9.2</span> SVD Analysis</h3>
<pre class="r"><code>svdOvarian &lt;- svd(ovarian)

nOvarian &lt;- nrow(ovarian)
r &lt;- ncol(svdOvarian$v)

totVar &lt;- sum(svdOvarian$d^2)/(nOvarian-1)
vars &lt;- data.frame(comp=1:r,var=svdOvarian$d^2/(nOvarian-1)) %&gt;%
  mutate(propVar=var/totVar,cumVar=cumsum(var/totVar))

pVar2 &lt;- vars %&gt;%
  ggplot(aes(x=comp:r,y=propVar)) +
  geom_point() +
  geom_line() +
  xlab(&quot;Component&quot;) +
  ylab(&quot;Proportion of Total Variance&quot;)

pVar3 &lt;- vars %&gt;%
  ggplot(aes(x=comp:r,y=cumVar)) +
  geom_point() +
  geom_line() +
  xlab(&quot;Component&quot;) +
  ylab(&quot;Cum. prop. of tot. var.&quot;)

grid.arrange(pVar2, pVar3, nrow=1)</code></pre>
<pre><code>## Warning in comp:r: numerical expression has 216 elements: only the first used

## Warning in comp:r: numerical expression has 216 elements: only the first used

## Warning in comp:r: numerical expression has 216 elements: only the first used

## Warning in comp:r: numerical expression has 216 elements: only the first used

## Warning in comp:r: numerical expression has 216 elements: only the first used

## Warning in comp:r: numerical expression has 216 elements: only the first used</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-42-1.png" width="672" /></p>
<p>We see that we can explain a lot of the variability using a few PC’s!</p>
<pre class="r"><code>Zk &lt;- svdOvarian$u[,1:6]%*%diag(svdOvarian$d[1:6])
colnames(Zk) &lt;- paste0(&quot;Z&quot;,1:6)
Vk &lt;- svdOvarian$v[,1:6]
colnames(Vk) &lt;- paste0(&quot;V&quot;,1:6)
reduced &lt;- data.frame(Zk,cancer=c(rep(1,121),rep(2,95)))

pOv1 &lt;- reduced %&gt;%
  ggplot(aes(x=Z1,y=Z2,col=cancer)) +
  geom_point()  +
  theme(legend.position = &quot;none&quot;)

pOv2 &lt;- Vk %&gt;%
  as.data.frame %&gt;%
  ggplot(aes(x=1:4000,y=V1)) +
  geom_line() +
  xlab(&quot;&quot;)

pOv3 &lt;- Vk %&gt;%
  as.data.frame %&gt;%
  ggplot(aes(x=1:4000,y=V2)) +
  geom_line() +
  xlab(&quot;&quot;)

grid.arrange(pOv1,pOv2,pOv3,layout_matrix = rbind(c(1,3),c(2,NA)))</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-43-1.png" width="672" /></p>
<p>Reconstruction of profiles:</p>
<pre class="r"><code>i &lt;- 1
pOv4 &lt;- qplot(1:4000,
  ovarian[i,],
  geom=&quot;line&quot;,
  ylab=&quot;centered intensity&quot;,
  xlab=&quot;&quot;,main=&quot;Cancer&quot;,
  ylim=range(ovarian[c(1,2,200,201),]))

pOv5 &lt;- qplot(1:4000,
  Vk[,1:2] %*%Zk[i,1:2],
  geom=&quot;line&quot;,
  ylab=&quot;centered intensity&quot;,
  xlab=&quot;&quot;,main=&quot;Reconstructed&quot;,
  ylim=range(ovarian[c(1,2,200,201),]))



grid.arrange(
  pOv1 +
    annotate(&quot;point&quot;, x = reduced[i,1], y = reduced[i,2], colour = &quot;red&quot;,cex=3),
  pOv2,
  pOv3,
  pOv4,
  pOv5,
  layout_matrix = rbind(c(1,2,3),c(4,5,NA)))</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-44-1.png" width="672" /></p>
<pre class="r"><code>i &lt;- 3
pOv4 &lt;- qplot(1:4000,
  ovarian[i,],
  geom=&quot;line&quot;,
  ylab=&quot;centered intensity&quot;,
  xlab=&quot;&quot;,main=&quot;Cancer&quot;,
  ylim=range(ovarian[c(1,2,200,201),]))

pOv5 &lt;- qplot(1:4000,
  Vk[,1:2] %*%Zk[i,1:2],
  geom=&quot;line&quot;,
  ylab=&quot;centered intensity&quot;,
  xlab=&quot;&quot;,main=&quot;Reconstructed&quot;,
  ylim=range(ovarian[c(1,2,200,201),]))



grid.arrange(
  pOv1 +
    annotate(&quot;point&quot;, x = reduced[i,1], y = reduced[i,2], colour = &quot;red&quot;,cex=3),
  pOv2,
  pOv3,
  pOv4,
  pOv5,
  layout_matrix = rbind(c(1,2,3),c(4,5,NA)))</code></pre>
<p><img src="svd_files/figure-html/unnamed-chunk-45-1.png" width="672" /></p>
</div>
</div>
</div>
<div id="acknowledgement" class="section level1 unnumbered">
<h1>Acknowledgement</h1>
<ul>
<li>Olivier Thas for sharing his materials of Analysis of High Dimensional Data 2019-2020, which I used as the starting point for this chapter.</li>
</ul>
</div>
<div id="session-info" class="section level1 unnumbered">
<h1>Session info</h1>
<details>
<p><summary>Session info</summary></p>
<pre><code>## [1] &quot;2021-10-04 14:06:08 UTC&quot;</code></pre>
<pre><code>## ─ Session info ───────────────────────────────────────────────────────────────
##  setting  value                       
##  version  R version 4.1.1 (2021-08-10)
##  os       macOS Catalina 10.15.7      
##  system   x86_64, darwin17.0          
##  ui       X11                         
##  language (EN)                        
##  collate  en_US.UTF-8                 
##  ctype    en_US.UTF-8                 
##  tz       UTC                         
##  date     2021-10-04                  
## 
## ─ Packages ───────────────────────────────────────────────────────────────────
##  ! package     * version    date       lib source                          
##  P assertthat    0.2.1      2019-03-21 [?] CRAN (R 4.1.0)                  
##  P backports     1.2.1      2020-12-09 [?] CRAN (R 4.1.0)                  
##  P bit           4.0.4      2020-08-04 [?] CRAN (R 4.1.0)                  
##  P bit64         4.0.5      2020-08-30 [?] CRAN (R 4.1.0)                  
##  P bitops        1.0-7      2021-04-24 [?] standard (@1.0-7)               
##  P bmp           0.3        2017-09-11 [?] CRAN (R 4.1.0)                  
##  P broom         0.7.9      2021-07-27 [?] CRAN (R 4.1.0)                  
##  P bslib         0.3.0      2021-09-02 [?] CRAN (R 4.1.0)                  
##  P cellranger    1.1.0      2016-07-27 [?] CRAN (R 4.1.0)                  
##  P cli           3.0.1      2021-07-17 [?] CRAN (R 4.1.0)                  
##  P codetools     0.2-18     2020-11-04 [?] CRAN (R 4.1.1)                  
##  P colorspace    2.0-2      2021-06-24 [?] CRAN (R 4.1.0)                  
##  P crayon        1.4.1      2021-02-08 [?] CRAN (R 4.1.0)                  
##  P curl          4.3.2      2021-06-23 [?] CRAN (R 4.1.0)                  
##  P DBI           1.1.1      2021-01-15 [?] CRAN (R 4.1.0)                  
##  P dbplyr        2.1.1      2021-04-06 [?] CRAN (R 4.1.0)                  
##  P digest        0.6.28     2021-09-23 [?] CRAN (R 4.1.0)                  
##  P downloader  * 0.4        2015-07-09 [?] CRAN (R 4.1.0)                  
##  P dplyr       * 1.0.7      2021-06-18 [?] CRAN (R 4.1.0)                  
##  P ellipsis      0.3.2      2021-04-29 [?] standard (@0.3.2)               
##  P emo           0.0.0.9000 2021-10-04 [?] Github (hadley/emo@3f03b11)     
##  P evaluate      0.14       2019-05-28 [?] CRAN (R 4.1.0)                  
##  P fansi         0.5.0      2021-05-25 [?] CRAN (R 4.1.0)                  
##  P farver        2.1.0      2021-02-28 [?] CRAN (R 4.1.0)                  
##  P fastmap       1.1.0      2021-01-25 [?] CRAN (R 4.1.0)                  
##  P forcats     * 0.5.1      2021-01-27 [?] CRAN (R 4.1.0)                  
##  P fs            1.5.0      2020-07-31 [?] CRAN (R 4.1.0)                  
##  P generics      0.1.0      2020-10-31 [?] CRAN (R 4.1.0)                  
##  P ggmap       * 3.0.0      2019-02-05 [?] CRAN (R 4.1.0)                  
##  P ggplot2     * 3.3.5      2021-06-25 [?] CRAN (R 4.1.0)                  
##  P glue          1.4.2      2020-08-27 [?] CRAN (R 4.1.0)                  
##  P gridExtra   * 2.3        2017-09-09 [?] CRAN (R 4.1.0)                  
##  P gtable        0.3.0      2019-03-25 [?] CRAN (R 4.1.0)                  
##  P haven         2.4.3      2021-08-04 [?] CRAN (R 4.1.0)                  
##  P highr         0.9        2021-04-16 [?] CRAN (R 4.1.0)                  
##  P hms           1.1.1      2021-09-26 [?] CRAN (R 4.1.0)                  
##  P htmltools     0.5.2      2021-08-25 [?] CRAN (R 4.1.0)                  
##  P httr          1.4.2      2020-07-20 [?] CRAN (R 4.1.0)                  
##  P igraph        1.2.6      2020-10-06 [?] CRAN (R 4.1.0)                  
##  P imager      * 0.42.10    2021-06-10 [?] CRAN (R 4.1.0)                  
##  P jpeg          0.1-9      2021-07-24 [?] CRAN (R 4.1.0)                  
##  P jquerylib     0.1.4      2021-04-26 [?] CRAN (R 4.1.0)                  
##  P jsonlite      1.7.2      2020-12-09 [?] CRAN (R 4.1.0)                  
##  P knitr         1.33       2021-04-24 [?] CRAN (R 4.1.0)                  
##  P labeling      0.4.2      2020-10-20 [?] CRAN (R 4.1.0)                  
##  P lattice       0.20-45    2021-09-22 [?] CRAN (R 4.1.0)                  
##  P lifecycle     1.0.1      2021-09-24 [?] CRAN (R 4.1.0)                  
##  P lubridate     1.7.10     2021-02-26 [?] CRAN (R 4.1.0)                  
##  P magrittr    * 2.0.1      2020-11-17 [?] CRAN (R 4.1.0)                  
##  P MASS          7.3-54     2021-05-03 [?] CRAN (R 4.1.1)                  
##  P modelr        0.1.8      2020-05-19 [?] CRAN (R 4.1.0)                  
##  P munsell       0.5.0      2018-06-12 [?] CRAN (R 4.1.0)                  
##  P pillar        1.6.3      2021-09-26 [?] CRAN (R 4.1.0)                  
##  P pixmap      * 0.4-12     2021-01-29 [?] CRAN (R 4.1.0)                  
##  P pkgconfig     2.0.3      2021-10-04 [?] Github (r-lib/pkgconfig@b81ae03)
##  P plyr          1.8.6      2020-03-03 [?] CRAN (R 4.1.0)                  
##  P png           0.1-7      2013-12-03 [?] CRAN (R 4.1.0)                  
##  P purrr       * 0.3.4      2020-04-17 [?] CRAN (R 4.1.0)                  
##  P R6            2.5.1      2021-08-19 [?] CRAN (R 4.1.0)                  
##  P Rcpp          1.0.7      2021-07-07 [?] CRAN (R 4.1.0)                  
##  P readbitmap    0.1.5      2018-06-27 [?] CRAN (R 4.1.0)                  
##  P readr       * 2.0.1      2021-08-10 [?] CRAN (R 4.1.1)                  
##  P readxl        1.3.1      2019-03-13 [?] CRAN (R 4.1.0)                  
##  P renv          0.14.0     2021-07-21 [?] CRAN (R 4.1.0)                  
##  P reprex        2.0.1      2021-08-05 [?] CRAN (R 4.1.0)                  
##  P RgoogleMaps   1.4.5.3    2020-02-12 [?] CRAN (R 4.1.0)                  
##  P rjson         0.2.20     2018-06-08 [?] CRAN (R 4.1.0)                  
##  P rlang         0.4.11     2021-04-30 [?] CRAN (R 4.1.0)                  
##  P rmarkdown     2.10       2021-08-06 [?] CRAN (R 4.1.1)                  
##  P rstudioapi    0.13       2020-11-12 [?] CRAN (R 4.1.0)                  
##  P rvest         1.0.1      2021-07-26 [?] CRAN (R 4.1.0)                  
##  P sass          0.4.0      2021-05-12 [?] CRAN (R 4.1.0)                  
##  P scales        1.1.1      2020-05-11 [?] CRAN (R 4.1.0)                  
##  P sessioninfo   1.1.1      2018-11-05 [?] CRAN (R 4.1.0)                  
##  P sp            1.4-5      2021-01-10 [?] CRAN (R 4.1.0)                  
##  P stringi       1.7.4      2021-08-25 [?] CRAN (R 4.1.0)                  
##  P stringr     * 1.4.0      2019-02-10 [?] CRAN (R 4.1.0)                  
##  P tibble      * 3.1.5      2021-09-30 [?] CRAN (R 4.1.0)                  
##  P tidyr       * 1.1.4      2021-09-27 [?] CRAN (R 4.1.0)                  
##  P tidyselect    1.1.1      2021-04-30 [?] standard (@1.1.1)               
##  P tidyverse   * 1.3.1      2021-04-15 [?] CRAN (R 4.1.0)                  
##  P tiff          0.1-8      2021-03-31 [?] CRAN (R 4.1.0)                  
##  P tzdb          0.1.2      2021-07-20 [?] CRAN (R 4.1.0)                  
##  P utf8          1.2.2      2021-07-24 [?] CRAN (R 4.1.0)                  
##  P vctrs         0.3.8      2021-04-29 [?] standard (@0.3.8)               
##  P vroom         1.5.4      2021-08-05 [?] CRAN (R 4.1.1)                  
##  P withr         2.4.2      2021-04-18 [?] CRAN (R 4.1.0)                  
##  P xfun          0.25       2021-08-06 [?] CRAN (R 4.1.1)                  
##  P xml2          1.3.2      2020-04-23 [?] CRAN (R 4.1.0)                  
##  P yaml          2.2.1      2020-02-01 [?] CRAN (R 4.1.0)                  
## 
## [1] /Users/runner/work/HDDA21/HDDA21/renv/library/R-4.1/x86_64-apple-darwin17.0
## [2] /private/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/RtmpXRMiFS/renv-system-library
## 
##  P ── Loaded and on-disk path mismatch.</code></pre>
</details>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiMi4gU2luZ3VsYXIgVmFsdWUgRGVjb21wb3NpdGlvbiIKYXV0aG9yOiAiTGlldmVuIENsZW1lbnQiCmRhdGU6ICJzdGF0T21pY3MsIEdoZW50IFVuaXZlcnNpdHkgKGh0dHBzOi8vc3RhdG9taWNzLmdpdGh1Yi5pbykiCi0tLQoKIyBJbnRyb2R1Y3Rpb24KCiMjIE1vdGl2YXRpb24KClRoZSBTVkQgaXMgb25lIG9mIHRoZSBtb3N0IHdlbGwgdXNlZCBhbmQgZ2VuZXJhbCBwdXJwb3NlIHRvb2xzIGZyb20gbGluZWFyIGFsZ2VicmEgZm9yIGRhdGEgcHJvY2Vzc2luZyEKCk1ldGhvZG9sb2dpY2FsbHkKCi0gRGltZW5zaW9uIHJlZHVjdGlvbiAoZS5nLiBpbWFnZXMsIGdlbmUgZXhwcmVzc2lvbiBkYXRhLCBtb3ZpZSBwcmVmZXJlbmNlcykKLSBVc2VkIGFzIGEgZmlyc3Qgc3RlcCBpbiBtYW55IGRhdGEgcmVkdWN0aW9uIGFuZCBtYWNoaW5lIGxlYXJuaW5nIGFwcHJvYWNoZXMKLSBUYXlsb3IgYSBjb29yZGluYXRlIHN5c3RlbSBiYXNlZCBvbiB0aGUgZGF0YSB3ZSBoYXZlCi0gU29sdmUgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgZm9yIG5vbi1zcXVhcmUgbWF0cmljZXM6IGUuZy4gbGluZWFyIHJlZ3Jlc3Npb24KLSBCYXNpcyBmb3IgcHJpbmNpcGFsIGNvbXBvbmVudCBhbmFseXNpcyAoUENBKSBhbmQgbXVsdGlkaW1lbnNpb25hbCBzY2FsaW5nIChNRFMpLgogIC0gUENBIGlzIG9uZSBvZiB0aGUgbW9zdCB3aWRlbHkgdXNlZCBtZXRob2RzIHRvIHN0dWR5IGhpZ2ggZGltZW5zaW9uYWwgZGF0YSBhbmQgdG8gdW5kZXJzdGFuZCB0aGVtIGluIHRlcm1zIG9mIHRoZWlyICBkb21pbmFudCBwYXR0ZXJucyBhbmQgY29ycmVsYXRpb25zCgpBcHBsaWNhdGlvbnM6CgotIEF0IHRoZSBoZWFydCBvZiBzZWFyY2ggZW5naW5lczogR29vZ2xlCi0gQmFzaXMgb2YgbWFueSBmYWNpYWwgcmVjb2duaXRpb24gbWV0aG9kczogZS5nLiBGYWNlYm9vawotIFJlY29tbWVuZGVyIHN5c3RlbXMgc3VjaCBhcyBBbWF6b24gYW5kIE5ldGZsaXgKLSBBIHN0YW5kYXJkIHRvb2wgZm9yIGRhdGEgZXhwbG9yYXRpb24gYW5kIGRpbWVuc2lvbiByZWR1Y3Rpb24gaW4gR2Vub21pY3MKCiMjIERpc2NsYWltZXIKCldoZW4geW91IHdhbnQgdG8gcnVuIHRoZSBzY3JpcHQgeW91IHdpbGwgaGF2ZSB0byBjb21tZW50IG91dCB0aGUgZXZhbD1GQUxTRSBzdGF0ZW1lbnQgaW4gc29tZSBSIGNodW5rcy4gQmVjYXVzZSB0aGUgU1ZEIHRha2VzIGEgd2hpbGUgb24gdGhlIGZhY2VzIGV4YW1wbGUgd2Ugc2F2ZSB0aGUgc3ZkIGZvciBsYXRlciB1c2UuIFNvIHlvdSBoYXZlIHRvIGNvbW1lbnQgdGhlIGV2YWw9RkFMU0Ugc3RhdGVtZW50IGluIHRoaXMgY2h1bmsgd2hlbiB5b3UgcnVuIHRoZSBzY3JpcHQgZm9yIHRoZSBmaXJzdCB0aW1lLgoKIyMgRGF0YQoKLSBFeHRlbmRlZCBZYWxlIEZhY2UgRGF0YWJhc2UgQgotIENyb3BwZWQgYW5kIGFsaWduZWQgaW1hZ2VzIG9mIDM4IGluZGl2aWR1YWxzIHVuZGVyIDY0IGxpZ2h0aW5nIGNvbmRpdGlvbnMuCi0gRWFjaCBpbWFnZSBpcyAxOTIgcGl4ZWxzIHRhbGwgYW5kIDE2OCBwaXhlbHMgd2lkZS4KLSBFYWNoIG9mIHRoZSBmYWNpYWwgaW1hZ2VzIGluIG91ciBsaWJyYXJ5IHdpbGwgYmUgcmVzaGFwZWQgaW50byBhIGxhcmdlIHZlY3RvciB3aXRoIDE5MiDDlyAxNjggPSAzMiAyNTYgZWxlbWVudHMuCi0gV2Ugd2lsbCB1c2UgdGhlIDY0IGltYWdlcyBvZiAzNiBwZW9wbGUgdG8gYnVpbGQgb3VyIG1vZGVscwoKYGBge3IgbGlicmFyaWVzLCBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFLCBzaWxlbnQ9VFJVRX0KbGlicmFyeShwaXhtYXApCmxpYnJhcnkodGlkeXZlcnNlKQpsaWJyYXJ5KGdyaWRFeHRyYSkKbGlicmFyeShncmlkKQpsaWJyYXJ5KGdnbWFwKQpsaWJyYXJ5KGRvd25sb2FkZXIpCmxpYnJhcnkoaW1hZ2VyKQpgYGAKCmBgYHtyIGRvd25sb2FkLWRhdGEsIHdhcm5pbmc9RkFMU0UsIG1lc3NhZ2U9RkFMU0V9CiMjIERvd25sb2FkIGFuZCB1bnppcCBkYXRhCmlmKCFkaXIuZXhpc3RzKCJyYXctZGF0YSIpKSBkaXIuY3JlYXRlKCJyYXctZGF0YSIpCmRvd25sb2FkKAogICJodHRwczovL2dpdGh1Yi5jb20vc3RhdE9taWNzL0hEQTIwMjAvcmF3L2RhdGEveWFsZWZhY2VzX2Nyb3BwZWQuemlwIiwKICBkZXN0ZmlsZSA9ICJyYXctZGF0YS95YWxlZmFjZXNfY3JvcHBlZC56aXAiLCBtb2RlID0gIndiIiwgcXVpZXQgPSBUUlVFCikKdW56aXAgKCJyYXctZGF0YS95YWxlZmFjZXNfY3JvcHBlZC56aXAiLCBleGRpciA9ICIuL3Jhdy1kYXRhIikKCmRpciA8LSAiLi9yYXctZGF0YS9Dcm9wcGVkWWFsZSIKYGBgCgpgYGB7ciwgd2FybmluZz1GQUxTRX0KcGVvcGxlIDwtIGxpc3QuZmlsZXMoZGlyKQpwZW9wbGUyIDwtIHNhcHBseShwZW9wbGUsCiAgZnVuY3Rpb24oeCkgbGlzdC5maWxlcygKICAgIHBhc3RlMChkaXIsIi8iLHgpLAogICAgZnVsbC5uYW1lcz1UUlVFCiAgICApCiAgKQoKZmFjZXNMaXN0IDwtIGxhcHBseShwZW9wbGUyLCBmdW5jdGlvbih4KSByZWFkLnBubSh4KSkKCiBncmlkLmFycmFuZ2UoCiAgZ3JvYnM9bGFwcGx5KGZhY2VzTGlzdFsxKygwOjM1KSo2NF0sCiAgICAgZnVuY3Rpb24oeCkgZ2V0Q2hhbm5lbHMoeCkgJT4lCiAgICAgICAgZ2dpbWFnZSguLGNvb3JkX2VxdWFsPVRSVUUpCiAgICAgICAgKSwKICBuY29sPTYpCmBgYAoKCiMjIE1ldGhvZAoKTGV0ICRcbWF0aGJme1h9JCBiZSBhbiAkblx0aW1lcyBwJCBtYXRyaXggZS5nLgoKLSBnZW5lIGV4cHJlc3Npb24gb2YgJHA9NDAgMDAwJCBnZW5lcyBmb3IgJG49MzAkIHN1YmplY3RzCi0gbiA9IDEwMCAwMDAgMDAwIHdlYnBhZ2VzIGluZGV4ZWQgd2l0aCBwIHNlYXJjaCB0ZXJtcywgb3IKLSAkbiQgaW1hZ2VzIGVhY2ggc3RvcmVkIGFzIGEgJHA9MzIgMjU2JCB2ZWN0b3Igd2l0aCB0aGUgaW50ZW5zaXR5IG9mIGVhY2ggcGl4ZWwKCjwhLS0gTmVlZCAiZW1vIiBwYWNrYWdlIGZvciBlbW9qaXMsIGluc3RhbGwgd2l0aCAtLT4KPCEtLSBgZGV2dG9vbHM6Omluc3RhbGxfZ2l0aHViKCJoYWRsZXkvZW1vIilgIC0tPgoKX19Ob3RlOl9fIHRoZSBlbW9qaSBjaGFyYWN0ZXJzIHdpbGwgbm90IGJlIHZpc2libGUgaW4gdGhlIFBERiBvdXRwdXQuCgpcW1g9ClxsZWZ0W1xiZWdpbnthcnJheX17Y2NjfQotJlxtYXRoYmZ7eH1fezF9XlQgJi0gXFwKXHZkb3RzJlx2ZG90cyZcdmRvdHNcXAotJlxtYXRoYmZ7eH1fe2l9XlQgJi0gXFwKXHZkb3RzJlx2ZG90cyZcdmRvdHNcXAotJlxtYXRoYmZ7eH1fe259XlQgJi0gXFwKXGVuZHthcnJheX1ccmlnaHRdX3tuIFx0aW1lcyBwfQpcYmVnaW57YXJyYXl9e2N9CmByIHNldC5zZWVkKDEpO2Vtbzo6amkoImJlYXV0eSIpYFxcXFwKYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgiY29wIilgXFwKXFwKYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgiYmxvbmRlIilgXFwKXGVuZHthcnJheX0KXF0KClRoZSBkYXRhIG1hdHJpeCAgJFxtYXRoYmZ7WH0kIGNhbiBiZSBkZWNvbXBvc2VkIHdpdGggdGhlIFNWRCBpbnRvIDMgbWF0cmljZXM6CgpcWwpcbWF0aGJme1h9PVxtYXRoYmZ7VX1fe25cdGltZXMgbn1cYm9sZHN5bWJvbHtcRGVsdGF9X3tuXHRpbWVzIHB9XG1hdGhiZntWfV5UX3twIFx0aW1lcyBwfQpcXQoKLSBhbiBvcnRob25vcm1hbCBtYXRyaXggJFxtYXRoYmZ7VX1fe25cdGltZXMgbn0kIHdpdGggbGVmdCBzaW5ndWxhciB2ZWN0b3JzOiAkXG1hdGhiZnt1fV9qXlQgXG1hdGhiZnt1fV9rPTEkIGlmICRrPWokIGFuZCAkXG1hdGhiZnt1fV9qXlQgXG1hdGhiZnt1fV9rPTAkIGlmICRqXG5lcSBrJCwgaS5lLgpcWyBcbWF0aGJme1V9XlRcbWF0aGJme1V9PVxtYXRoYmZ7SX1cXQoKLSBhIG1hdHJpeCAkXGJvbGRzeW1ib2x7XERlbHRhfV97blx0aW1lcyBwfSQgd2l0aCBvbmx5IHNpbmd1bGFyIHZhbHVlczogdGhlIHNpbmd1bGFyIHZhbHVlcyAkXGRlbHRhX2kkIGFyZSB0aGUgb25seSBub24temVybyBlbGVtZW50cyBvZiB0aGUgbWF0cml4IGFuZCBhcmUgb24gdGhlIGRpYWdvbmFsIGVsZW1lbnQgJFtcYm9sZHN5bWJvbHtcRGVsdGF9XV97aWl9JC4gVGhleSBhcmUgYWxzbyBvcmdhbmlzZWQgc28gdGhhdCAkXGRlbHRhXzEgPiBcZGVsdGFfMiA+IFxsZG90cyA+IFxkZWx0YV9yJC4KCi0gYW4gb3J0aG9ub3JtYWwgbWF0cml4ICRcbWF0aGJme1Z9X3twXHRpbWVzIHB9JCB3aXRoIHJpZ2h0IHNpbmd1bGFyIHZlY3RvcnM6ICRcbWF0aGJme3Z9X2peVCBcbWF0aGJme3Z9X2s9MSQgaWYgJGs9aiQgYW5kICRcbWF0aGJme3Z9X2peVCBcbWF0aGJme3Z9X2s9MCQgaWYgJGpcbmVxIGskIG90aGVyd2lzZSwgaS5lLgpcWyBcbWF0aGJme1Z9XlRcbWF0aGJme1Z9PVxtYXRoYmZ7SX1cXQoKCk5vdGUsIHRoYXQgdGhlcmUgYXJlIG9ubHkgJHIkIG5vbi16ZXJvIHNpbmd1bGFyIHZhbHVlcywgd2l0aCAkciQgdGhlIHJhbmsgb2YgbWF0cml4ICRYJDogJHIgXGxlcSBcdGV4dHttaW59KG4scCkkLiBTbyB3ZSBoYXZlICRrPTEgXGxkb3RzIHIkIG5vbi16ZXJvIHNpbmd1bGFyIHZhbHVlcy4gSGVuY2UsIHdlIGNhbiBhbHNvIHJld3JpdGUgdGhlIGFwcHJveGltYXRpb24gYnkgcmVzdHJpY3RpbmcgdXMgdG8gdGhlIHJhbmsgb2YgbWF0cml4ICRcbWF0aGJme1h9JC4gSW5kZWVkLCB0aGUgbiB0aW1lcyBwIG1hdHJpeCAkXGJvbGRzeW1ib2xcRGVsdGEkIG9ubHkgY29udGFpbnMgJHIkIG5vbi16ZXJvIGRpYWdvbmFsIGVsZW1lbnRzIQoKLSBTbwpcWwpcbWF0aGJme1h9PVxtYXRoYmZ7VX1fe25cdGltZXMgcn1cYm9sZHN5bWJvbHtcRGVsdGF9X3tyXHRpbWVzIHJ9XG1hdGhiZntWfV5UX3twIFx0aW1lcyByfQpcXQoKClxbClxsZWZ0W1xiZWdpbnthcnJheX17Y2NjfQotJlxtYXRoYmZ7eH1fezF9XlQgJi0gXFwKXHZkb3RzJlx2ZG90cyZcdmRvdHNcXAotJlxtYXRoYmZ7eH1fe2l9XlQgJi0gXFwKXHZkb3RzJlx2ZG90cyZcdmRvdHNcXAotJlxtYXRoYmZ7eH1fe259XlQgJi0gXFwKXGVuZHthcnJheX1ccmlnaHRdX3tuIFx0aW1lcyBwfQo9ClxsZWZ0W1xiZWdpbnthcnJheX17Y2NjfQpcbWlkJiZcbWlkXFwKXG1hdGhiZnt1fV8xJlxsZG90cyZcbWF0aGJme3V9X3JcXApcbWlkJiZcbWlkClxlbmR7YXJyYXl9XHJpZ2h0XV97biBcdGltZXMgcn0KXGxlZnRbXGJlZ2lue2FycmF5fXtjY2N9ClxkZWx0YV8xXFwKJlxkZG90cyZcXAomJlxkZWx0YV9yXFwKXGVuZHthcnJheX1ccmlnaHRdX3tyIFx0aW1lcyByfQpcbGVmdFtcYmVnaW57YXJyYXl9e2NjY30KXG1pZCYmXG1pZFxcClxtYXRoYmZ7dn1fMSZcbGRvdHMmXG1hdGhiZnt2fV9yXFwKXG1pZCYmXG1pZFxcClxlbmR7YXJyYXl9ClxyaWdodF1eVF97cCBcdGltZXMgcn0KXF0KCkFsc28gbm90ZSB0aGF0ClxbClxtYXRoYmZ7Vn1eVD1cbGVmdFtcYmVnaW57YXJyYXl9e2NjY30KLSZcbWF0aGJme3Z9X3sxfV5UICYtIFxcClx2ZG90cyZcdmRvdHMmXHZkb3RzXFwKLSZcbWF0aGJme3Z9X3tyfV5UICYtIFxcClxlbmR7YXJyYXl9XHJpZ2h0XV97ciBcdGltZXMgcH0KXF0KCgotIEZvciBoaWdoIGRpbWVuc2lvbmFsIGRhdGEgJHA+Pj5uJCAkXHJpZ2h0YXJyb3ckICRcdGV4dHttYXh9KHIpPW4kIGFuZAoKLSBlcXVpdmFsZW50bHkgZm9yIG11bHRpdmFyaWF0ZSBkYXRhIHdpdGggJG4+cCQgJFxyaWdodGFycm93JCAkXHRleHR7bWF4fShyKT1wJAoKCldlIGNhbiBhbHNvIHJld3JpdGUgdGhlIGRlY29tcG9zaXRpb24gdXNpbmcgdGhlIHByb3BlcnRpZXMgb2YgbWF0cml4IG11bHRpcGxpY2F0aW9uCgpcYmVnaW57ZXFuYXJyYXl9ClxtYXRoYmZ7WH0gJj0mIFxkZWx0YV8xXGxlZnRbClxiZWdpbnthcnJheX17Y30KXG1pZFxcClxtYXRoYmZ7dX1fMVxcClxtaWQKXGVuZHthcnJheX0KXHJpZ2h0XQpcYmVnaW57YXJyYXl9e2N9ClxsZWZ0WwpcYmVnaW57YXJyYXl9e2NjY30KLSYKXG1hdGhiZnt2fV8xXlQmCi0KXGVuZHthcnJheX0KXHJpZ2h0XVxcXHF1YWRcXFxxdWFkClxlbmR7YXJyYXl9CisgXGxkb3RzICsKXGRlbHRhX3JcbGVmdFsKXGJlZ2lue2FycmF5fXtjfQpcbWlkXFwKXG1hdGhiZnt1fV9yXFwKXG1pZApcZW5ke2FycmF5fQpccmlnaHRdClxiZWdpbnthcnJheX17Y30KXGxlZnRbClxiZWdpbnthcnJheX17Y2NjfQotJgpcbWF0aGJme3Z9X3JeVCYKLQpcZW5ke2FycmF5fQpccmlnaHRdXFxccXVhZFxcXHF1YWQKXGVuZHthcnJheX1cXApcbWF0aGJme1h9ICY9JiBcc3VtX3trPTF9XnIgXGRlbHRhX2tcbWF0aGJme3V9X2tcbWF0aGJme3Z9X2teVApcZW5ke2VxbmFycmF5fQoKLSBCZWNhdXNlIGJvdGggJFxtYXRoYmZ7VX0kIGFuZCAkXG1hdGhiZntWfSQgYXJlIG9ydGhvbm9ybWFsIGFsbCB0aGVpciAkciQgdmVjdG9ycyBhcmUgaGF2aW5nIHVuaXQgbGVuZ3RoIGFuZCB0aGV5IGFyZSB0aHVzIHJlc2hhcGVkIGJ5IHRoZSBzaW5ndWxhciB2YWx1ZXMuCgotIEhlbmNlLCB0aGUgc2luZ3VsYXIgdmFsdWVzIGRldGVybWluZSB0aGUgaW1wb3J0YW5jZSBvZiB0aGUgcmFuayBvbmUgbWF0cmljZXMgJFxkZWx0YV9rXG1hdGhiZnt1fV9rXG1hdGhiZnt2fV9rXlQkIGluIHRoZSByZWNvbnN0cnVjdGlvbiBvZiB0aGUgbWF0cml4ICRcbWF0aGJme1h9JCBhbmQgdGhleSBhcmUgb3JkZXJlZCBzbyB0aGF0ICRcZGVsdGFfMSA+IFxsZG90cyA+IFxkZWx0YV9yJC4KCk5vdGUsIHRoYXQgZm9yIHN5bW1ldHJpYyBtYXRyaWNlcyAkXG1hdGhiZntYfSQgJFxsb25ncmlnaHRhcnJvdyQgJFxtYXRoYmZ7VX0gPSBcbWF0aGJme1Z9JC4KCiMjIEludGVycHJldGF0aW9uIG9mIHNpbmd1bGFyIHZlY3RvcnM6IGZhY2UgZXhhbXBsZQoKIyMjIENvbnZlcnQgaW1hZ2VzIHRvIHZlY3RvcnMKMS4gQ29udmVydCBpbWFnZXMgdG8gdmVjdG9ycyBhbmQgc3RvcmUgdGhlbSBhcyBhIG1hdHJpeAogICAgLSBXZSB1c2UgYW4gYHNhcHBseWAgbG9vcCB0byBsb29wIG92ZXIgYWxsIGZhY2VzCiAgICAtIFdlIGV4dHJhY3QgdGhlIGdyZXkgaW50ZW5zaXRpZXMgZnJvbSB0aGUgcGljdHVyZXMKICAgIC0gV2UgY29udmVydCB0aGUgbWF0cml4IGluIGEgbG9uZyBza2lubnkgdmVjdG9yIChgY2ApCiAgICAtIFdlIHRyYW5zcG9zZSB0aGUgcmVzdWx0aW5nIG1hdHJpeCBmcm9tIHNhcHBseQpgYGB7cn0KYWxsRmFjZXNNeCA8LSBzYXBwbHkoZmFjZXNMaXN0LAogICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih4KQogICAgICAgICAgICAgICAgICAgICAgICBnZXRDaGFubmVscyh4KSAlPiUgYwogICAgICAgICAgICAgICAgICAgICApICU+JSB0CmRpbShhbGxGYWNlc014KQpgYGAKClNhdmUgbWVtb3J5IGJ5IHJlbW92aW5nIGZhY2VzTGlzdCBvYmplY3QKYGBgCnJtKGZhY2VzTGlzdCkKZ2MoKQpgYGAKCkhlbmNlIHdlIG9idGFpbiBhIG1hdHJpeCBmb3IgbiA9IGByIG5yb3coYWxsRmFjZXNNeClgIGltYWdlcyB3aXRoIHAgPSBgciBuY29sKGFsbEZhY2VzTXgpYCBpbnRlbnNpdGllcyBmb3IgZWFjaCBwaXhlbCBvZiBhbiBpbWFnZS4KCkJlZm9yZSB3ZSBkbyB0aGUgc3ZkIHdlIHR5cGljYWxseSBjZW50ZXIgdGhlIGRhdGEgYnkgc3Vic3RyYWN0aW5nIHRoZSBhdmVyYWdlIG9mIHRoZSBjb2x1bW5zLCBpLmUuIHRoZSBhdmVyYWdlIGZhY2UuCgpXZSB3aWxsIG9ubHkgd29yayB3aXRoIHRoZSBmaXJzdCAzNiBwZW9wbGU6ICRuID0gMzYgXHRpbWVzIDY0ID0gYHIgMzYqNjRgJCBwaWN0dXJlcy4KCmBgYHtyfQphbGxGYWNlc0NlbnRlcmVkTXggPC0gYWxsRmFjZXNNeFsxOigzNio2NCksXQptZWFuRmFjZSA8LSBjb2xNZWFucyhhbGxGYWNlc0NlbnRlcmVkTXgpCgphbGxGYWNlc014Q2VudGVyZWQgPC0gYWxsRmFjZXNDZW50ZXJlZE14IC0KICBtYXRyaXgoMSwgbnJvdz1ucm93KGFsbEZhY2VzQ2VudGVyZWRNeCksIG5jb2w9MSkgJSolIG1hdHJpeChtZWFuRmFjZSxucm93PTEpCmBgYAoKIyMjIFZpc3VhbGlzYXRpb24gb2YgbWVhbiBpbWFnZQpgYGB7cn0KcGxvdEZhY2VWZWN0b3IgPC0gZnVuY3Rpb24oZmFjZVZlY3Rvcixucm93PTE5MixuY29sPTE2OCkgewogIG1hdHJpeChmYWNlVmVjdG9yLG5yb3c9bnJvdyxuY29sPW5jb2wpICU+JQogIGdnaW1hZ2UoKQp9CgptZWFuRmFjZSAlPiUKICBwbG90RmFjZVZlY3RvcgpgYGAKCiMjIyBTVkQKCiMjIyMgUGVyZm9ybSBTVkQgaW4gUgoKMS4gV2UgYWRvcHQgc3ZkIG9uIHRoZSBjZW50ZXJlZCBtYXRyaXgKMi4gV2UgY2FjaGUgdGhlIHJlc3VsdCBiZWNhdXNlIHRoZSBjYWxjdWxhdGlvbiB0YWtlcyAxMCBtaW51dGVzLgoKYGBge3IgcnVuLVNWRCwgY2FjaGU9VFJVRX0KZmFjZVN2ZCA8LSBzdmQoYWxsRmFjZXNNeENlbnRlcmVkKQpgYGAKCjwhLS0gYGBge3IsIGV2YWw9RkFMU0V9IC0tPgo8IS0tICMjIFJ1biB0aGlzIGNvZGUgbWFudWFsbHkgdG8gc3RvcmUgdGhlIFNWRCBmb3IgbGF0ZXIgcmUtdXNlIC0tPgo8IS0tIHNhdmVSRFMoZmFjZVN2ZCwgZmlsZSA9ICJmYWNlU3ZkLnJkcyIpIC0tPgo8IS0tIGBgYCAtLT4KCjwhLS0gYGBge3IsIGV2YWw9RkFMU0V9IC0tPgo8IS0tICMjIFJ1biB0aGlzIGNvZGUgbWFudWFsbHkgdG8gcmVsb2FkIHRoZSBTVkQgcmVzdWx0IC0tPgo8IS0tIGZhY2VTdmQgPC0gcmVhZFJEUygiZmFjZVN2ZC5yZHMiKSAtLT4KPCEtLSBgYGAgLS0+CgoKCiMjIyMgU1ZECgpEaW1lbnNpb25zIG9mICRcbWF0aGJme1V9JCwgJFxtYXRoYmZ7Vn0kPwoKYGBge3J9Cm4gPC0gbnJvdyhhbGxGYWNlc0NlbnRlcmVkTXgpCnAgPC0gbmNvbChhbGxGYWNlc0NlbnRlcmVkTXgpCmRpbShmYWNlU3ZkJHUpCmRpbShmYWNlU3ZkJHYpCmBgYAoKSW5kZWVkLCBmb3IgdGhlIGZhY2UgZXhhbXBsZSAkbjxwJCBzbyAkcj1uJAoKQ2hlY2sgb3J0aG9nb25hbGl0eT8KCldlIGRvIG5vdCBkbyBpdCBmb3IgYWxsIHZlY3RvcnMgYmVjYXVzZSBpdCB0YWtlcyB0b28gbG9uZy4KRmlyc3QgbGVmdCBlaWdlbiB2ZWN0b3IgYW5kIHNlY29uZCBsZWZ0IGVpZ2VudmVjdG9yLgpIYXBwZW5zIGluICRcbWF0aGJme1V9XlRcbWF0aGJme1V9JApgYGB7cn0KdChmYWNlU3ZkJHVbLDFdKSUqJWZhY2VTdmQkdVssMV0KdChmYWNlU3ZkJHVbLDFdKSUqJWZhY2VTdmQkdVssMl0KdChmYWNlU3ZkJHVbLDJdKSUqJWZhY2VTdmQkdVssMl0KYGBgClNvIHdlIHNlZSB0aGF0IHRoZSBsZWZ0IGVpZ2VudmVjdG9ycyBhcmUgb3J0aG9ub3JtYWwuCgpXZSBjaGVjayBpZiBpdCBhbHNvIGhvbGRzIGZvciB0aGUgcm93cyBpLmUuICRcbWF0aGJme1V9XG1hdGhiZntVfV5UJApgYGB7cn0KdChmYWNlU3ZkJHVbMSxdKSUqJWZhY2VTdmQkdVsxLF0KdChmYWNlU3ZkJHVbMixdKSUqJWZhY2VTdmQkdVsxLF0KdChmYWNlU3ZkJHVbMixdKSUqJWZhY2VTdmQkdVsyLF0KYGBgCldlIGFsc28gc2VlIHRoYXQgdGhlIHJvd3Mgb2YgJFxtYXRoYmZ7VX0kIGFyZSBvcnRob25vcm1hbC4KCmBgYHtyfQp0KGZhY2VTdmQkdlssMV0pJSolZmFjZVN2ZCR2WywxXQp0KGZhY2VTdmQkdlssMV0pJSolZmFjZVN2ZCR2WywyXQp0KGZhY2VTdmQkdlssMl0pJSolZmFjZVN2ZCR2WywyXQpgYGAKU28gd2Ugc2VlIHRoYXQgdGhlIHJpZ2h0IGVpZ2VudmVjdG9ycyBhcmUgb3J0aG9ub3JtYWwuCgpgYGB7cn0KdChmYWNlU3ZkJHZbMSxdKSUqJWZhY2VTdmQkdlsxLF0KdChmYWNlU3ZkJHZbMSxdKSUqJWZhY2VTdmQkdlsyLF0KdChmYWNlU3ZkJHZbMixdKSUqJWZhY2VTdmQkdlsyLF0KYGBgCgpUaGlzLCBob3dldmVyIGRvZXMgbm90IGhvbGQgZm9yIHRoZSByb3dzIG9mICRcbWF0aGJme1Z9JC4KVGhpcyBpcyBiZWNhdXNlIHRoZSBtYXRyaXggJFxtYXRoYmZ7Vn0kIG5vIGxvbmdlciBpcyBhIHNxdWFyZSBtYXRyaXghICRyPW4kIGFuZCAkcjxwJCEKCiMjIyMgVmlzdWFsaXplIHJpZ2h0IGVpZ2VudmVjdG9ycyAkXG1hdGhiZntWfSQKYGBge3J9CmdyaWQuYXJyYW5nZSgKIGdyb2JzPWFwcGx5KAogICBmYWNlU3ZkJHZbLDE6MzZdLAogICAyLAogICBwbG90RmFjZVZlY3RvcgogICApCiApCmBgYAoKLSBIZW5jZSwgdGhlIHJpZ2h0IHNpbmd1bGFyIHZlY3RvcnMgKGluICRcbWF0aGJme1Z9JCBvZiAkXG1hdGhiZntYfT1cbWF0aGJme1V9XGJvbGRzeW1ib2x7XERlbHRhfVxtYXRoYmZ7Vn0kKSBhcmUgYWxzbyBmYWNlcyBhbmQgd2UgY2FuIHRodXMgcmVjb25zdHJ1Y3QgdGhlIG9yaWdpbmFsIGZhY2VzIGJ5IGxpbmVhciBjb21iaW5hdGlvbnMgb2YgdGhlIGVpZ2VuIGZhY2VzLgoKLSBUaGUgZmlyc3QgZWlnZW4gZmFjZXMgYXJlIG1vc3QgaW1wb3J0YW50IHRvIGNhcHR1cmUgb3ZlcmFsbCBwYXR0ZXJucyBpbiB0aGUgbWF0cml4LgoKLSBIZXJlIGl0IGFyZSBtYWlubHkgY2hhcmFjdGVyaXN0aWNzIGFuZCBzaGFkb3dzIHRoYXQgYXJlIGltcG9ydGFudCBmb3IgYWxsIGZhY2VzLgoKLSBGcm9tIGVpZ2VuIGZhY2UgNSBvbndhcmRzIHdlIHN0YXJ0IHRvIHNlZSBzcGVjaWZpYyBmZWF0dXJlcy4KCi0gSW4gdGhpcyBjYXNlOiAkbiA8IHAkLCBzbyAkciA9IG4kLgoKXFsKXG1hdGhiZntYfV97blx0aW1lcyBwfT1cbWF0aGJme1V9X3tuIFx0aW1lcyBufVxib2xkc3ltYm9se1xEZWx0YX1fe25cdGltZXMgbn1cbWF0aGJme1Z9X3twXHRpbWVzIG59XlQKXF0KClxbClxiZWdpbnthcnJheX17Y2NjY2N9ClxsZWZ0W1xiZWdpbnthcnJheX17Y2NjfQotJlxtYXRoYmZ7eH1fezF9XlQgJi0gXFwKXHZkb3RzJlx2ZG90cyZcdmRvdHNcXAotJlxtYXRoYmZ7eH1fe2l9XlQgJi0gXFwKXHZkb3RzJlx2ZG90cyZcdmRvdHNcXAotJlxtYXRoYmZ7eH1fe259XlQgJi0gXFwKXGVuZHthcnJheX1ccmlnaHRdX3tuIFx0aW1lcyBwfQpcYmVnaW57YXJyYXl9e2N9CmByIHNldC5zZWVkKDEpO2Vtbzo6amkoImJlYXV0eSIpYFxcXFwKYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgiY29wIilgXFwKXFwKYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgiYmxvbmRlIilgXFwKXGVuZHthcnJheX0KJj0mClxiZWdpbnthcnJheX17Y30KXHF1YWRcXApcbGVmdFtcYmVnaW57YXJyYXl9e2NjY30KXG1pZCYmXG1pZFxcClxtYXRoYmZ7dX1fMSZcbGRvdHMmXG1hdGhiZnt1fV9uXFwKXG1pZCYmXG1pZApcZW5ke2FycmF5fVxyaWdodF1fe24gXHRpbWVzIG59XFwKXHF1YWQgXFwKXGVuZHthcnJheX0KXGJlZ2lue2FycmF5fXtjfQpccXVhZFxcClxsZWZ0W1xiZWdpbnthcnJheX17Y2NjfQpcZGVsdGFfMVxcCiZcZGRvdHMmXFwKJiZcZGVsdGFfblxcClxlbmR7YXJyYXl9XHJpZ2h0XV97biBcdGltZXMgbn1cXApccXVhZFxcClxlbmR7YXJyYXl9ClxiZWdpbnthcnJheX17Y30KXHF1YWQKXGxlZnRbXGJlZ2lue2FycmF5fXtjY2N9ClxtaWQmJlxtaWRcXApcbWF0aGJme3Z9XzEmXGxkb3RzJlxtYXRoYmZ7dn1fblxcClxtaWQmJlxtaWRcXApcZW5ke2FycmF5fQpccmlnaHRdXlRfe3AgXHRpbWVzIG59XFwKXGJlZ2lue2FycmF5fXtjY2N9CmByIHNldC5zZWVkKDEpO2Vtbzo6amkoImZlYXIiKWAmXHF1YWQmYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgibWVoIilgClxlbmR7YXJyYXl9ClxlbmR7YXJyYXl9ClxlbmR7YXJyYXl9ClxdCgotIE9yIHVwb24gdHJhbnNwb3NpbmcgdGhlIG1hdHJpeCAkXG1hdGhiZntWfSQKClxbClxiZWdpbnthcnJheX17Y2NjY2N9ClxsZWZ0W1xiZWdpbnthcnJheX17Y2NjfQotJlxtYXRoYmZ7eH1fezF9XlQgJi0gXFwKXHZkb3RzJlx2ZG90cyZcdmRvdHNcXAotJlxtYXRoYmZ7eH1fe2l9XlQgJi0gXFwKXHZkb3RzJlx2ZG90cyZcdmRvdHNcXAotJlxtYXRoYmZ7eH1fe259XlQgJi0gXFwKXGVuZHthcnJheX1ccmlnaHRdX3tuIFx0aW1lcyBwfQpcYmVnaW57YXJyYXl9e2N9CmByIHNldC5zZWVkKDEpO2Vtbzo6amkoImJlYXV0eSIpYFxcXFwKYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgiY29wIilgXFwKXFwKYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgiYmxvbmRlIilgXFwKXGVuZHthcnJheX0KJj0mClxsZWZ0W1xiZWdpbnthcnJheX17Y2NjfQpcbWlkJiZcbWlkXFwKXG1hdGhiZnt1fV8xJlxsZG90cyZcbWF0aGJme3V9X25cXApcbWlkJiZcbWlkClxlbmR7YXJyYXl9XHJpZ2h0XV97biBcdGltZXMgbn0KXGxlZnRbXGJlZ2lue2FycmF5fXtjY2N9ClxkZWx0YV8xXFwKJlxkZG90cyZcXAomJlxkZWx0YV9yXFwKXGVuZHthcnJheX1ccmlnaHRdX3tuIFx0aW1lcyBufQpcbGVmdFtcYmVnaW57YXJyYXl9e2NjY30KLSZcbWF0aGJme3Z9X3sxfV5UICYtIFxcClx2ZG90cyZcdmRvdHMmXHZkb3RzXFwKLSZcbWF0aGJme3Z9X3twfV5UICYtIFxcClxlbmR7YXJyYXl9XHJpZ2h0XV97biBcdGltZXMgcH0KXGJlZ2lue2FycmF5fXtjfQpgciBzZXQuc2VlZCgxKTtlbW86OmppKCJmZWFyIilgXFwKXFwKYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgibWVoIilgClxlbmR7YXJyYXl9ClxlbmR7YXJyYXl9ClxdCgojIyMjIFJlY29uc3RydWN0aW9uIG9mIGZhY2VzIHZpYSBsaW5lYXIgY29tYmluYXRpb24gb2YgZWlnZW4gZmFjZXMuCgpJbiBsZWZ0IHNpbmd1bGFyIHZlY3RvcnMgJHVfe2lqfSQgd2UgcXVhbnRpZnkgdGhlIGNvbnRyaWJ1dGlvbiBvZiB0aGUgJGpeXHRleHR7dGh9JCBlaWdlbmZhY2UgaW4gdGhlIHJlY29uc3RydWN0aW9uIG9mIGZhY2UgJGkkIGFuZCB3ZSByZXNjYWxlIHRoZSBpbXBvcnRhbmNlIG9mIGVhY2ggZWlnZW4gZmFjZSBieSBpdHMgY29ycmVzcG9uZGluZyBlaWdlbiB2YWx1ZSAkXGRlbHRhX2okLgoKXFsKXGxlZnRbXGJlZ2lue2FycmF5fXtjY2N9Ci0mXG1hdGhiZnt4fV97MX1eVCAmLSBcXApcdmRvdHMmXHZkb3RzJlx2ZG90c1xcCi0mXG1hdGhiZnt4fV97aX1eVCAmLSBcXApcdmRvdHMmXHZkb3RzJlx2ZG90c1xcCi0mXG1hdGhiZnt4fV97bn1eVCAmLSBcXApcZW5ke2FycmF5fVxyaWdodF1fe24gXHRpbWVzIHB9ClxiZWdpbnthcnJheX17Y30KYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgiYmVhdXR5IilgXFxcXApgciBzZXQuc2VlZCgxKTtlbW86OmppKCJjb3AiKWBcXApcXApgciBzZXQuc2VlZCgxKTtlbW86OmppKCJibG9uZGUiKWBcXApcZW5ke2FycmF5fSA9ClxkZWx0YV8xXGxlZnRbClxiZWdpbnthcnJheX17Y30KXG1pZFxcClxtYXRoYmZ7dX1fMVxcClxtaWQKXGVuZHthcnJheX0KXHJpZ2h0XQpcYmVnaW57YXJyYXl9e2N9ClxsZWZ0WwpcYmVnaW57YXJyYXl9e2NjY30KLSYKXG1hdGhiZnt2fV8xXlQmCi0KXGVuZHthcnJheX0KXHJpZ2h0XVxcXHF1YWRcXFxxdWFkClxlbmR7YXJyYXl9ClxiZWdpbnthcnJheX17Y30KYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgiZmVhciIpYApcXFxxdWFkXFxccXVhZApcZW5ke2FycmF5fQorIFxsZG90cyArClxkZWx0YV9yXGxlZnRbClxiZWdpbnthcnJheX17Y30KXG1pZFxcClxtYXRoYmZ7dX1fclxcClxtaWQKXGVuZHthcnJheX0KXHJpZ2h0XQpcYmVnaW57YXJyYXl9e2N9ClxsZWZ0WwpcYmVnaW57YXJyYXl9e2NjY30KLSYKXG1hdGhiZnt2fV9yXlQmCi0KXGVuZHthcnJheX0KXHJpZ2h0XVxcXHF1YWRcXFxxdWFkClxlbmR7YXJyYXl9ClxiZWdpbnthcnJheX17Y30KYHIgc2V0LnNlZWQoMSk7ZW1vOjpqaSgibWVoIilgClxcXHF1YWRcXFxxdWFkClxlbmR7YXJyYXl9ClxdCgpJZiB3ZSB0cnVuY2F0ZSB0aGUgZWlnZW4gZmFjZXMgc2F5IGF0ICRrPHIkIHdlIGNhbiBhcHByb3hpbWF0ZSBmYWNlcyB1c2luZyBhIGxpbWl0ZWQgbnVtYmVyIG9mIGVpZ2VuIGZhY2VzIQoKYGBge3IgZmlnLmNhcD0nYXBwcm94aW1hdGlvbiB3aXRoIDI1ICh0b3AgbGVmdCksICAxMDAgKHRvcCByaWdodCkgYW5kIDUwMCAoYm90dG9tIGxlZnQpIGVpZ2VuZmFjZXMgYW5kIG9yaWdpbmFsIGZhY2UgKGJvdHRvbSByaWdodCwgb3Igd2l0aCBhbGwgZWlnZW5mYWNlcyknfQphcHByb3hpbWF0ZUZhY2UgPC0gZnVuY3Rpb24obWVhbkZhY2UsZmFjZVN2ZCxrKXsKICByZWNvbnN0cnVjdCA8LSAobWVhbkZhY2UgKyBmYWNlU3ZkJHVbMSwxOmtdICUqJQogICAgZGlhZyhmYWNlU3ZkJGRbMTprXSkgJSolCiAgdChmYWNlU3ZkJHZbLDE6a10pICU+JQogIGMpCn0KCmFwcHJveEhscCA8LSBzYXBwbHkoCiAgICAgIGMoMjUsMTAwLDUwMCksCiAgICAgIGFwcHJveGltYXRlRmFjZSwKICAgICAgbWVhbkZhY2U9bWVhbkZhY2UsCiAgICAgIGZhY2VTdmQ9ZmFjZVN2ZCkKCmdyaWQuYXJyYW5nZSgKIGdyb2JzPWFwcGx5KAogICBjYmluZCgKICAgICBhcHByb3hIbHAsCiAgICAgYWxsRmFjZXNNeENlbnRlcmVkWzEsXSttZWFuRmFjZQogICApLAogICAyLAogICBwbG90RmFjZVZlY3RvcgogICApCiApCgpgYGAKCiMgU1ZEIGFzIGEgTWF0cml4IEFwcHJveGltYXRpb24gTWV0aG9kCgotIFdlIGhhdmUgc2VlbiB0aGF0IHdlIGNhbiB1c2UgdGhlIHRydW5jdGVkIFNWRCB0byBhcHByb3hpbWF0ZSBtYXRyaXggJFxtYXRoYmZ7WH0kIGJ5ICRcdGlsZGV7XG1hdGhiZntYfX0kLCB3aXRoICRrPHIkIGFuZApcWwpcdGlsZGV7XG1hdGhiZntYfX09XG1hdGhiZntVfV97blx0aW1lcyBrfVxib2xkc3ltYm9se1xEZWx0YX1fe2tcdGltZXMga31cbWF0aGJme1Z9X3twIFx0aW1lcyBrfV5UClxdCi0gSXQgY2FuIGJlIHNob3duIHRoYXQgKipTVkQ6IG9wdGltYWwgYXBwcm94aW1hdGlvbioqCgogIC0gTGV0ICRcbWF0aGJme1h9JCBiZSBhbiAkblx0aW1lcyBwJCBtYXRyaXggb2YgcmFuayAkclxsZXEgXG1pbihuLHApJCwgYW5kIGxldCAkXG1hdGhiZntBfSQgZGVub3RlIGFuICRuIFx0aW1lcyBwJCBtYXRyaXggb2YgcmFuayAka1xsZXEgciQsIHdpdGggZWxlbWVudHMgZGVub3RlZCBieSAkYV97aWp9JC4KCiAgLSBUaGUgbWF0cml4ICRcbWF0aGJme0F9JCBvZiByYW5rICRrXGxlcSByJCB0aGF0IG1pbmltaXNlcyB0aGUgRnJvYmVuaXVzIG5vcm0KICBcWwogICAgXHZlcnRcdmVydFxtYXRoYmZ7WH0tXG1hdGhiZntBfVx2ZXJ0XHZlcnReMl9cdGV4dHtmcn09XHN1bV97aT0xfV5uXHN1bV97aj0xfV5wICh4X3tpan0tYV97aWp9KV4yCiAgXF0KICBpcyBnaXZlbiBieSB0aGUgdHJ1bmNhdGVkIFNWRAogIFxbCiAgICAgXG1hdGhiZntYfV9rID0gXHN1bV97aj0xfV5rIFxkZWx0YV9qIFxtYXRoYmZ7dX1falxtYXRoYmZ7dn1fal5ULgogIFxdCgogIC0gVGhlIHRydW5jYXRlZCBTVkQgaGFzICRrIDwgciQgdGVybXMuIEhlbmNlLCBnZW5lcmFsbHkgJFxtYXRoYmZ7WH1fayQgZG9lcyBub3QgY29pbmNpZGUgd2l0aCAkXG1hdGhiZntYfSQuIEl0IGlzIGNvbnNpZGVyZWQgYXMgYW4gYXBwcm94aW1hdGlvbi4KCiAgLSBOb3RlLCB0aGF0IHRoZSB0cnVuY2F0ZWQgU1ZEIHRodXMgYXBwcm94aW1hdGVzIHRoZSBtYXRyaXggYnkgbWluaW1pc2luZyBhIGtpbmQgb2Ygc3VtIG9mIGxlYXN0IHNxdWFyZWQgZXJyb3JzIGJldHdlZW4gdGhlIGVsZW1lbnRzIG9mIG1hdHJpeCAkXG1hdGhiZntYfSQgYW5kICRcbWF0aGJme0F9JCBhbmQgdGhhdAoKICAtIHRoZSB0cnVuY2F0ZWQgU1ZEICRcbWF0aGJme1h9X2skIGlzIHRoZSBiZXN0IHJhbmstayBhcHByb3hpbWF0aW9uIG9mICRcbWF0aGJme1h9JCBpbiB0ZXJtcyBvZiB0aGlzCkZyb2Jlbml1cyBub3JtLgoKICAtIEFsc28sIG5vdGUgdGhhdCB1cG9uIHRydW5jYXRpb24KICBcW1xtYXRoYmZ7Vn1eVF97cFx0aW1lcyBrfSBcbWF0aGJme1Z9X3twXHRpbWVzIGt9ID0gXG1hdGhiZntJfV97a1x0aW1lcyBrfVxdCiAgXFtcbWF0aGJme1V9XlRfe25cdGltZXMga30gXG1hdGhiZntVfV97blx0aW1lcyBrfSA9IFxtYXRoYmZ7SX1fe2tcdGltZXMga31cXQoKICAtIEJ1dCwgdGhhdApcW1xtYXRoYmZ7Vn1fe3BcdGltZXMga30gXG1hdGhiZntWfV97cFx0aW1lcyBrfV5UIFxuZXEgXG1hdGhiZntJfV97cFx0aW1lcyBwfSEhIVxdClxbXG1hdGhiZntVfV97blx0aW1lcyBrfSBcbWF0aGJme1V9X3tuXHRpbWVzIGt9XlQgXG5lcSBcbWF0aGJme0l9X3tuXHRpbWVzIG59ISEhXF0KCi0tLQoKClNvbWUgKippbmZvcm1hbCBzdGF0ZW1lbnQqKiBhYm91dCB0aGUgdHJ1bmNhdGVkIFNWRAogIFxbCiAgICAgXG1hdGhiZntYfV9rID0gXHN1bV97aj0xfV5rIFxkZWx0YV9qIFxtYXRoYmZ7dX1falxtYXRoYmZ7dn1fal5ULgogIFxdCgogLSBJdCBjYW4gYmUgY29uc2lkZXJlZCBhcyBhIHdlaWdodGVkIHN1bSBvZiBtYXRyaWNlcyAkXG1hdGhiZnt1fV9qXG1hdGhiZnt2fV9qXlQkLCB3aXRoIHdlaWdodHMgJFxkZWx0YV9qJC4KCgogLSBUaGUgdGVybXMgYXJlIG9yZGVyZWQgd2l0aCBkZWNyZWFzaW5nIHdlaWdodHMgJFxkZWx0YV8xXGdlcSBcZGVsdGFfMiBcZ2VxIFxjZG90cyBcZ2VxIFxkZWx0YV9rID4wJC4KCgogLSBUaGUgbWF0cmljZXMgJFxtYXRoYmZ7dX1falxtYXRoYmZ7dn1fal5UJCBhcmUgb2YgZXF1YWwgIm1hZ25pdHVkZSIgKGNvbnN0cnVjdGVkIGZyb20gbm9ybWFsaXNlZCB2ZWN0b3JzKS4KCiAtIFRydW5jYXRpb24gYXQgJGskIHJlc3VsdHMgaW4gJGskICRcZGVsdGFfaiQncywgJGtcdGltZXMgbiQgZWxlbWVudHMgaW4gdGhlICRcbWF0aGJme3V9X2okIGFuZCAkayBcdGltZXMgcCQgZWxlbWVudHMgaW4gdGhlICRcbWF0aGJme3Z9X2okLiBIZW5jZSBhIHRvdGFsIG9mICRrK2tuK2twPWsoMStuK3ApJCBlbGVtZW50cyAodXN1YWxseSBtdWNoIHNtYWxsZXIgdGhhbiAkbnAkKS4gKE5vdGUgdGhhdCByZXN0cmljdGlvbnMgYXBwbHkgdG8gJFxtYXRoYmZ7dX1faiQgYW5kICRcbWF0aGJme3Z9X2okOyBoZW5jZSBldmVuIGxlc3MgaW5kZXBlbmRlbnQgZWxlbWVudHMpLgoKICRcbG9uZ3JpZ2h0YXJyb3ckICoqZGF0YSBjb21wcmVzc2lvbioqCgojIyBFeGFtcGxlIDE6IEltYWdlIGNvbXByZXNzaW9uCgojIyMgUGFpbnRpbmcgTW9uZHJpYWFuOiBDb21wb3NpdGlvbl9Oby5JSUkgd2l0aCByZWQsIGJsdWUsIHllbGxvdyBhbmQgYmxhY2sgKDE5MjkpLgoKLSBIYXZlIGEgbG9vayBhdCB0aGlzIHBhaW50aW5nIG9mIE1vbmRyaWFhbiAoMTg3MiAtLSAxOTQ0KSwgaGVyZSBzaG93biBpbiBibGFjay1hbmQtd2hpdGUuCgojIyMjIExvYWQgdGhlIG9yaWdpbmFsIHBhaW50aW5nCgoxLiBmZXRjaCBpbWFnZSBmcm9tIHRoZSB3ZWIKMi4gY29udmVydCBpbnRvIGdyZXlzY2FsZQozLiBwbG90CjQuIHNhdmUgYXMgTWF0cml4CgpgYGB7cn0KbW9uZHJpYWFuIDwtIGxvYWQuaW1hZ2UoImh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvdGh1bWIvYS9hYy9QaWV0X01vbmRyaWFuXy1fQ29tcG9zaXRpb25fTm8uX0lJSSUyQ193aXRoX3JlZCUyQ19ibHVlJTJDX3llbGxvd19hbmRfYmxhY2slMkNfMTkyOS5qcGcvMTkyMHB4LVBpZXRfTW9uZHJpYW5fLV9Db21wb3NpdGlvbl9Oby5fSUlJJTJDX3dpdGhfcmVkJTJDX2JsdWUlMkNfeWVsbG93X2FuZF9ibGFjayUyQ18xOTI5LmpwZyIpCm1vbmRyaWFhbiA8LSBncmF5c2NhbGUobW9uZHJpYWFuKQpwbG90KG1vbmRyaWFhbixheGVzPUZBTFNFKQpYIDwtIG1hdHJpeChhcy5kYXRhLmZyYW1lKG1vbmRyaWFhbilbLDNdLG5yb3c9bnJvdyhtb25kcmlhYW4pLG5jb2w9bmNvbChtb25kcmlhYW4pKQpgYGAKCi0gVGhpcyBwaWN0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhICRgciBucm93KG1vbmRyaWFhbilgIFx0aW1lcyBgciBuY29sKG1vbmRyaWFhbilgYCQgbWF0cml4ICRcbWF0aGJme1h9JCB3aXRoIGdyYXkgc2NhbGUgaW50ZW5zaXRpZXMgJFxpbiBbMCwxXSQuICgkXGFwcHJveCA0XHRpbWVzIDEwXjYkIGRhdGEgZW50cmllcykKCi0gV2Ugd2lsbCBoZXJlIG5vdCB0cmFuc2Zvcm0gdGhlIGltYWdlIGluIGEgdmVjdG9yLCBidXQgd2lsbCBsb29rIGF0IHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgU1ZEIHRvIGNvbXByZXNzIHRoaXMgaW1hZ2UuIFRoZSBTVkQgY2FuIGJlIGFwcGxpZWQgdG8gYW55IG1hdHJpeCEKCgojIyMjIFNpbmd1bGFyIHZhbHVlcwoKYGBge3J9Cm1vblN2ZCA8LSBzdmQoWCkKCnAxIDwtIGRhdGEuZnJhbWUoeD0xOmxlbmd0aChtb25TdmQkZCkseT1tb25TdmQkZCkgJT4lCiAgZ2dwbG90KGFlcyh4PXgseT15KSkgKwogIGdlb21fcG9pbnQoKSArCiAgeGxhYigiayIpICsKICB5bGFiKCJzaW5ndWxhciB2YWx1ZSIpCgpwMiA8LSBkYXRhLmZyYW1lKHg9MToxMCx5PW1vblN2ZCRkWzE6MTBdKSAlPiUKICBnZ3Bsb3QoYWVzKHg9eCx5PXkpKSArCiAgZ2VvbV9wb2ludCgpICsKICB4bGFiKCJrIikgKwogIHlsYWIoInNpbmd1bGFyIHZhbHVlIikKCmdyaWQuYXJyYW5nZShwMSxwMixucm93PTEpCmBgYAoKLSBUaGUgc2luZ3VsYXIgdmFsdWVzIGRlY2F5IHZlcnkgcXVpY2tseSEKCiMjIyMgRGF0YSBjb21wcmVzc2lvbgoKLSBXZSBtYWtlIHRoZSBwbG90IGZvciBhIHJlY29uc3RydWN0aW9uIHdpdGggMSBzaW5ndWxhciB2ZWN0b3IuIFRoaXMgbGVhZHMgdG8gYSBkYXRhIGNvbXByZXNzaW9uIG9mICQxLVxmcmFjeygxK2ByIG5yb3cobW9uZHJpYWFuKWArYHIgbmNvbChtb25kcmlhYW4pYCl9e2ByIG5yb3cobW9uZHJpYWFuKSBgXHRpbWVzIGByIG5jb2wobW9uZHJpYWFuKWB9JCA9IGByIDEwMCAtIHJvdW5kKCgxK25yb3cobW9uZHJpYWFuKStuY29sKG1vbmRyaWFhbikpLyhucm93KG1vbmRyaWFhbikqbmNvbChtb25kcmlhYW4pKSoxMDAsMSlgJS4gV2Ugb25seSB1c2UgMSBsZWZ0IHNpbmd1bGFyIHZlY3RvciAoYHIgbnJvdyhtb25kcmlhYW4pYCksIDEgZWlnZW4gdmFsdWUsIDEgcmlnaHQgc2luZ3VsYXIgdmVjdG9yIChgciBuY29sKG1vbmRyaWFhbilgKS4KCgpgYGB7cn0KayA8LSAxCmFwcHJveE1vbiA8LSBtb25TdmQkdVssMTprXSAlKiUKICBkaWFnKG1vblN2ZCRkWzE6a10sbmNvbD1rKSAlKiUKICB0KG1vblN2ZCR2WywxOmtdKQoKYXBwcm94TW9uW2FwcHJveE1vbiA8IDBdIDwtIDAKYXBwcm94TW9uW2FwcHJveE1vbiA+IDFdIDwtIDEKCmFzLmNpbWcoYXBwcm94TW9uKSAlPiUKICBwbG90KC4sbWFpbj1wYXN0ZTAoIkFwcHJveGltYXRpb24gd2l0aCAiLGssIiBzaW5ndWxhciB2ZWN0b3JzIiksYXhlcz1GQUxTRSkKYGBgCgotIFdlIG1ha2UgdGhlIHBsb3QgZm9yIGEgcmVjb25zdHJ1Y3Rpb24gd2l0aCAyIHNpbmd1bGFyIHZlY3Rvci4gVGhpcyBsZWFkcyB0byBhIGRhdGEgY29tcHJlc3Npb24gb2YgJDEtXGZyYWN7Mlx0aW1lcyAoMStgciBucm93KG1vbmRyaWFhbilgK2ByIG5jb2wobW9uZHJpYWFuKWApfXtgciBucm93KG1vbmRyaWFhbikgYFx0aW1lcyBgciBuY29sKG1vbmRyaWFhbilgfSQgPSBgciAxMDAgLSByb3VuZCgyKigxK25yb3cobW9uZHJpYWFuKStuY29sKG1vbmRyaWFhbikpLyhucm93KG1vbmRyaWFhbikqbmNvbChtb25kcmlhYW4pKSoxMDAsMSlgJS4gV2Ugb25seSB1c2UgMiBsZWZ0IHNpbmd1bGFyIHZlY3RvcnMKKDIgJFx0aW1lcyQgYHIgbnJvdyhtb25kcmlhYW4pYCksIDIgc2luZ3VsYXIgdmFsdWVzLCAyIHJpZ2h0IHNpbmd1bGFyIHZlY3RvcnMgKDIgJFx0aW1lcyQgYHIgbmNvbChtb25kcmlhYW4pYCkuCgpgYGB7cn0KayA8LSAyCmFwcHJveE1vbiA8LSBtb25TdmQkdVssMTprXSAlKiUKICBkaWFnKG1vblN2ZCRkWzE6a10sbmNvbD1rKSAlKiUKICB0KG1vblN2ZCR2WywxOmtdKQoKYXBwcm94TW9uW2FwcHJveE1vbiA8IDBdIDwtIDAKYXBwcm94TW9uW2FwcHJveE1vbiA+IDFdIDwtIDEKCmFzLmNpbWcoYXBwcm94TW9uKSAlPiUKICBwbG90KC4sbWFpbj1wYXN0ZTAoIkFwcHJveGltYXRpb24gd2l0aCAiLGssIiBzaW5ndWxhciB2ZWN0b3JzIiksYXhlcz1GQUxTRSkKYGBgCgoKYGBge3J9CnBhciAobWZyb3c9YygzLDMpKQpwYXIobWFyPWMoMSwyLDEsMSkpCmZvciAoayBpbiBjKDE6OCkpCnsKYXBwcm94TW9uIDwtIG1vblN2ZCR1WywxOmtdICUqJQogIGRpYWcobW9uU3ZkJGRbMTprXSxuY29sPWspICUqJQogIHQobW9uU3ZkJHZbLDE6a10pCgoKYXBwcm94TW9uW2FwcHJveE1vbiA8IDBdIDwtIDAKYXBwcm94TW9uW2FwcHJveE1vbiA+IDFdIDwtIDEKCgphcHByb3hNb24gJT4lCiAgYXMuY2ltZyAlPiUKICBwbG90KC4sbWFpbj1wYXN0ZTAoaywiIHNpbmd1bGFyIHZlY3RvcnMiKSxheGVzPUZBTFNFKQp9CnBsb3QoYXMuY2ltZyhYKSxtYWluPXBhc3RlMCgiT3JpZ2luYWwgaW1hZ2UiKSxheGVzPUZBTFNFKQpgYGAKCiMjIyBNb3JlIGNvbXBsZXggcGFpbnRpbmc6IENvbXBvc2l0aW9uIEEsIFBpZXQgTW9uZHJpYWFuCgojIyMjIExvYWQgdGhlIG9yaWdpbmFsIHBhaW50aW5nCgpgYGB7cn0KbW9uZHJpYWFuIDwtIGxvYWQuaW1hZ2UoImh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvdGh1bWIvYy9jMy9Db21wb3NpdGlvbl9BX2J5X1BpZXRfTW9uZHJpYW5fR2FsbGVyaWFfTmF6aW9uYWxlX2QlMjdBcnRlX01vZGVybmFfZV9Db250ZW1wb3JhbmVhLmpwZy8xOTIwcHgtQ29tcG9zaXRpb25fQV9ieV9QaWV0X01vbmRyaWFuX0dhbGxlcmlhX05hemlvbmFsZV9kJTI3QXJ0ZV9Nb2Rlcm5hX2VfQ29udGVtcG9yYW5lYS5qcGciKQptb25kcmlhYW4gPC0gZ3JheXNjYWxlKG1vbmRyaWFhbikKcGxvdChtb25kcmlhYW4sYXhlcz1GQUxTRSkKWCA8LSBtYXRyaXgoYXMuZGF0YS5mcmFtZShtb25kcmlhYW4pWywzXSxucm93PWRpbShtb25kcmlhYW4pWzFdLG5jb2w9ZGltKG1vbmRyaWFhbilbMl0pCmBgYAoKCiMjIyMgU2luZ3VsYXIgdmFsdWVzCgpgYGB7ciwgY2FjaGU9VFJVRX0KbW9uU3ZkIDwtIHN2ZChYKQpgYGAKCmBgYHtyfQpwMSA8LSBkYXRhLmZyYW1lKHg9MTpsZW5ndGgobW9uU3ZkJGQpLHk9bW9uU3ZkJGQpICU+JQogIGdncGxvdChhZXMoeD14LHk9eSkpICsKICBnZW9tX3BvaW50KCkgKwogIHhsYWIoImsiKSArCiAgeWxhYigic2luZ3VsYXIgdmFsdWUiKQoKcDIgPC0gZGF0YS5mcmFtZSh4PTE6MTAseT1tb25TdmQkZFsxOjEwXSkgJT4lCiAgZ2dwbG90KGFlcyh4PXgseT15KSkgKwogIGdlb21fcG9pbnQoKSArCiAgeGxhYigiayIpICsKICB5bGFiKCJzaW5ndWxhciB2YWx1ZSIpCgpncmlkLmFycmFuZ2UocDEscDIsbnJvdz0xKQpgYGAKCi0gVGhlIHNpbmd1bGFyIHZhbHVlcyBkZWNheSBhIGJpdCBzbG93ZXIuIFRoZSBwYWludGluZyBpcyBhIGJpdCBtb3JlIGNvbXBsZXguIE1vcmUgbGluZXMgYW5kIGNvbG9ycy4KCiMjIyMgRXZhbHVhdGUgZGF0YSBjb21wcmVzc2lvbgoKYGBge3J9CnBhciAobWZyb3c9YygzLDMpKQpwYXIobWFyPWMoMSwyLDEsMSkpCmZvciAoayBpbiBjKDEsc2VxKDMsMjEsMykpKQp7CmFwcHJveE1vbiA8LSBtb25TdmQkdVssMTprXSAlKiUKICBkaWFnKG1vblN2ZCRkWzE6a10sbmNvbD1rKSAlKiUKICB0KG1vblN2ZCR2WywxOmtdKQoKCmFwcHJveE1vblthcHByb3hNb24gPCAwXSA8LSAwCmFwcHJveE1vblthcHByb3hNb24gPiAxXSA8LSAxCgoKYXBwcm94TW9uICU+JQogIGFzLmNpbWcgJT4lCiAgcGxvdCguLG1haW49cGFzdGUwKGssIiBzaW5ndWxhciB2ZWN0b3JzIiksYXhlcz1GQUxTRSkKfQpwbG90KGFzLmNpbWcoWCksbWFpbj1wYXN0ZTAoIk9yaWdpbmFsIGltYWdlIiksYXhlcz1GQUxTRSkKYGBgCgojIyMgU2VsZiBwb3J0cmV0IFBpZXQgTW9uZHJpYWFuCgojIyMjIExvYWQgdGhlIHBhaW50aW5nCgpgYGB7cn0KbW9uZHJpYWFuIDwtIGxvYWQuaW1hZ2UoImh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvdGh1bWIvNi82Ni9Nb25kcmlhbl9aZWxmcG9ydHJldC5qcGcvMTkyMHB4LU1vbmRyaWFuX1plbGZwb3J0cmV0LmpwZyIpCm1vbmRyaWFhbiA8LSBncmF5c2NhbGUobW9uZHJpYWFuKQpwbG90KG1vbmRyaWFhbixheGVzPUZBTFNFKQpYIDwtIG1hdHJpeChhcy5kYXRhLmZyYW1lKG1vbmRyaWFhbilbLDNdLG5yb3c9ZGltKG1vbmRyaWFhbilbMV0sbmNvbD1kaW0obW9uZHJpYWFuKVsyXSkKYGBgCgojIyMjIFNpbmd1bGFyIHZhbHVlcwoKYGBge3IsIGNhY2hlPVRSVUV9Cm1vblN2ZCA8LSBzdmQoWCkKCnAxIDwtIGRhdGEuZnJhbWUoeD0xOmxlbmd0aChtb25TdmQkZCkseT1tb25TdmQkZCkgJT4lCiAgZ2dwbG90KGFlcyh4PXgseT15KSkgKwogIGdlb21fcG9pbnQoKSArCiAgeGxhYigiayIpICsKICB5bGFiKCJzaW5ndWxhciB2YWx1ZSIpCgpwMiA8LSBkYXRhLmZyYW1lKHg9MToxMCx5PW1vblN2ZCRkWzE6MTBdKSAlPiUKICBnZ3Bsb3QoYWVzKHg9eCx5PXkpKSArCiAgZ2VvbV9wb2ludCgpICsKICB4bGFiKCJrIikgKwogIHlsYWIoInNpbmd1bGFyIHZhbHVlIikKCmdyaWQuYXJyYW5nZShwMSxwMixucm93PTEpCmBgYAoKLSBUaGUgc2luZ3VsYXIgdmFsdWVzIGRlY2F5IG11Y2ggc2xvd2VyLiBUaGUgcGFpbnRpbmcgaXMgbW9yZSBjb21wbGV4LgoKIyMjIyBFdmFsdWF0ZSBjb21wcmVzc2lvbgoKYGBge3J9CnBhciAobWZyb3c9YygzLDMpKQpwYXIobWFyPWMoMSwyLDEsMSkpCmZvciAoayBpbiBjKDEsNSwxMCwyMCwzMCw0MCw1MCwxMDApKQp7CmFwcHJveE1vbiA8LSBtb25TdmQkdVssMTprXSAlKiUKICBkaWFnKG1vblN2ZCRkWzE6a10sbmNvbD1rKSAlKiUKICB0KG1vblN2ZCR2WywxOmtdKQoKCmFwcHJveE1vblthcHByb3hNb24gPCAwXSA8LSAwCmFwcHJveE1vblthcHByb3hNb24gPiAxXSA8LSAxCgoKYXBwcm94TW9uICU+JQogIGFzLmNpbWcgJT4lCiAgcGxvdCguLG1haW49cGFzdGUwKGssIiBzaW5ndWxhciB2ZWN0b3JzIiksYXhlcz1GQUxTRSkKfQpwbG90KGFzLmNpbWcoWCksbWFpbj1wYXN0ZTAoIk9yaWdpbmFsIGltYWdlIiksYXhlcz1GQUxTRSkKYGBgCgoKCkhlcmUgd2UgbmVlZCBhdCBsZWFzdCA0MCBzaW5ndWxhciB2ZWN0b3IuIFRoaXMgbGVhZHMgdG8gYSBkYXRhIGNvbXByZXNzaW9uIG9mICQxLVxmcmFjezQwXHRpbWVzICgxK2ByIG5yb3cobW9uZHJpYWFuKWArYHIgbmNvbChtb25kcmlhYW4pYCl9e2ByIG5yb3cobW9uZHJpYWFuKWAgXHRpbWVzIGByIG5jb2wobW9uZHJpYWFuKWB9JCA9IGByIDEwMCAtIHJvdW5kKDQwKigxK25yb3cobW9uZHJpYWFuKStuY29sKG1vbmRyaWFhbikpLyhucm93KG1vbmRyaWFhbikqbmNvbChtb25kcmlhYW4pKSoxMDAsMSlgJS4gV2Ugb25seSB1c2UgNDAgbGVmdCBzaW5ndWxhciB2ZWN0b3JzICgkNDAgXHRpbWVzIGByIG5yb3cobW9uZHJpYWFuKWAkKSwgNDAgc2luZ3VsYXIgdmFsdWVzLCA0MCByaWdodCBlaWdlbnMgdmVjdG9yICgkNDBcdGltZXMgYHIgbmNvbChtb25kcmlhYW4pYCQpLgoKIyBHZW9tZXRyaWMgaW50ZXJwcmV0YXRpb24KCldyaXRlIHRoZSAqKnRydW5jYXRlZCBTVkQqKiBhcwpcWwogIFxtYXRoYmZ7WH1fayA9IFxtYXRoYmZ7VX1fayBcYm9sZHN5bWJvbHtcRGVsdGF9X2sgXG1hdGhiZntWfV9rXlQgPSBcbWF0aGJme1p9X2sgXG1hdGhiZntWfV9rXlQKXF0Kd2l0aApcWwogIFxtYXRoYmZ7Wn1fayA9IFxtYXRoYmZ7VX1fayBcYm9sZHN5bWJvbHtcRGVsdGF9X2sKXF0KYW4gJG4gXHRpbWVzIGskIG1hdHJpeC4KCkVhY2ggb2YgdGhlICRuJCByb3dzIG9mICRcbWF0aGJme1p9X2skLCBzYXkgJFxtYXRoYmZ7en1eVF97ayxpfSQsIHJlcHJlc2VudHMgYSBwb2ludCBpbiBhICRrJC1kaW1lbnNpb25hbCBzcGFjZS4KCgpCZWNhdXNlIG9mIHRoZSBvcnRob25vcm1hbGl0eSBvZiB0aGUgc2luZ3VsYXIgdmVjdG9ycywgd2UgYWxzbyBoYXZlClxiZWdpbntlcW5hcnJheSp9CiAgXG1hdGhiZntYfV9rXG1hdGhiZntWfV9rICY9JiBcbWF0aGJme1p9X2sgXG1hdGhiZntWfV9rXlRcbWF0aGJme1Z9X2sgXFwKICBcbWF0aGJme1h9X2tcbWF0aGJme1Z9X2sgJj0mIFxtYXRoYmZ7Wn1fay4KXGVuZHtlcW5hcnJheSp9CgpUaHVzIHRoZSBtYXRyaXggJFxtYXRoYmZ7Vn1fayQgaXMgYSAqKnRyYW5zZm9ybWF0aW9uIG1hdHJpeCoqIHRoYXQgbWF5IGJlIHVzZWQgdG8gdHJhbnNmb3JtICRcbWF0aGJme1h9X2skIGludG8gJFxtYXRoYmZ7Wn1fayQsIGFuZCAkXG1hdGhiZntafV9rJCBpbnRvICRcbWF0aGJme1h9X2skLgoKLS0tCgpOb3RlIHRoYXQKCi0gVGhlIG1hdHJpeCAkXG1hdGhiZntWfV9rJCB0cmFuc2Zvcm1zIHRoZSAkcCQtZGltZW5zaW9uYWwgJFxtYXRoYmZ7WH1fayQgaW50byB0aGUgJGskLWRpbWVuc2lvbmFsICRcbWF0aGJme1p9X2skOiAkXG1hdGhiZntafV9rID0gXG1hdGhiZntYfV9rXG1hdGhiZntWfV9rJC4gTm90ZSwgaG93ZXZlciwgdGhhdCB0aGUgbWF0cml4ICRcbWF0aGJme1h9X2skIG11c3Qgbm90IG5lY2Vzc2FyaWx5IGJlIHVzZWQgZm9yIHRoaXMgdHJhbnNmb3JtYXRpb24sIGJlY2F1c2UgdGhlIFNWRCBvZiB0aGUgb3JpZ2luYWwgbWF0cml4ICRcbWF0aGJme1h9JCBhbHNvIGdpdmVzIGRpcmVjdGx5ICRcbWF0aGJme1p9X2sgPSBcbWF0aGJme1V9X2sgXGJvbGRzeW1ib2x7XERlbHRhfV9rJC4KCi0gVGhlIGludmVyc2UgdHJhbnNmb3JtYXRpb24gZnJvbSB0aGUgICRrJC1kaW1lbnNpb25hbCAkXG1hdGhiZntafV9rJCB0byB0aGUgJHAkLWRpbWVuc2lvbmFsICRcbWF0aGJme1h9X2skIGlzIGdpdmVuIGJ5IHRoZSB0cmFuc3Bvc2Ugb2YgJFxtYXRoYmZ7Vn1fayQ6ICRcbWF0aGJme1p9X2sgXG1hdGhiZntWfV9rXlQ9XG1hdGhiZntYfV9rJC4gT2Z0ZW4gaW52ZXJzZSB0cmFuc2Zvcm1hdGlvbnMgYXJlIGdpdmVuIGJ5IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4LCBidXQgdGhhbmtzIHRvIHRoZSBvcnRob25vcm1hbGl0eSBvZiB0aGUgY29sdW1ucyBvZiAkXG1hdGhiZntWfV9rJCwgd2UgZ2V0ICRcbWF0aGJme1Z9X2teVFxtYXRoYmZ7Vn1faz1cbWF0aGJme0l9JCwgYW5kIHRodXMgJFxtYXRoYmZ7Vn1fa15UJCBhY3RzIGFzIGFuIGludmVyc2UuCgotIFRoZSB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSAgJGskLWRpbWVuc2lvbmFsICRcbWF0aGJme1p9X2skIHRvIHRoZSAkcCQtZGltZW5zaW9uYWwgJFxtYXRoYmZ7WH1fayQgaXMgdHJhbnNmb3JtaW5nIHBvaW50cyBmcm9tIGEgbG93IGRpbWVuc2lvbmFsIHNwYWNlICgkayQpIHRvIGEgaGlnaCBkaW1lbnNpb25hbCBzcGFjZSAoJHAkKS4gWW91IG1heSBub3QgaW50ZXJwcmV0IHRoaXMgYXMgaWYgdGhpcyB0cmFuc2Zvcm1hdGlvbiBhZGRzIGluZm9ybWF0aW9uOyB0aGUgdHJhbnNmb3JtZWQgcG9pbnRzIGluICRcbWF0aGJme1h9X2skIHN0aWxsIGxpdmUgaW4gYSAkayQtZGltZW5zaW9uYWwgc3Vic3BhY2Ugb2YgdGhlIGxhcmdlciAkcCQtZGltZW5zaW9uYWwgc3BhY2U7IHRoZSBtYXRyaXggJFxtYXRoYmZ7WH1fayQgaXMgb25seSBvZiByYW5rICRrJCBhbmQgdGh1cyBjb250YWlucyBsZXNzIGluZm9ybWF0aW9uIHRoYW4gdGhlIG9yaWdpbmFsIGRhdGEgbWF0cml4ICRcbWF0aGJme1h9JCAoaWYgcmFuaygkXG1hdGhiZntYfSQpJD1yPmskKS4KCi0tLQoKTW9yZSBpbXBvcnRhbnRseSwgaXQgY2FuIGJlIHNob3duIHRoYXQgKHRoYW5rcyB0byBvcnRob25vcm1hbGl0eSBvZiAkXG1hdGhiZntWfSQpCiAgXFsKICAgICBcbWF0aGJme1h9XG1hdGhiZntWfV9rID0gXG1hdGhiZntafV9rLgogIFxdCiAgVGhpcyBmb2xsb3dzIGZyb20gKHcubC5nLiByYW5rKCRcbWF0aGJme1h9JCk9JHIkKQogIFxiZWdpbntlcW5hcnJheSp9CiAgICBcbWF0aGJme1h9XG1hdGhiZntWfV9rCiAgICAgICAmPSYgXG1hdGhiZntVRFZ9XlRcbWF0aGJme1Z9X2sgPSBcbWF0aGJme1VEfVxiZWdpbntwbWF0cml4fQogICAgICAgCSAgICAgICAgXG1hdGhiZnt2fV8xXlQgXFwKCSAgICAgICAgXHZkb3RzIFxcCgkgICAgICAgIFxtYXRoYmZ7dn1fcl5UCiAgICAgICAgICAgICAgIFxlbmR7cG1hdHJpeH0KICAgICAgICAgICAgICAgXGJlZ2lue3BtYXRyaXh9CiAgICAgICAgICAgICAgICAgXG1hdGhiZnt2fV8xIFxsZG90cyBcbWF0aGJme3Z9X2sKICAgICAgICAgICAgICAgXGVuZHtwbWF0cml4fSBcXAogICAgICAgJj0mIFxtYXRoYmZ7VURWfV5UXG1hdGhiZntWfV9rID0gXG1hdGhiZntVRH1cYmVnaW57cG1hdHJpeH0KICAgICAgICAgICAgICAgIDEgJiAwICYgXGxkb3RzICYgMCBcXAogICAgICAgICAgICAgICAgMCAmIDEgJiBcbGRvdHMgJiAwIFxcCiAgICAgICAgICAgICAgICBcdmRvdHMgJiBcdmRvdHMgJiBcZGRvdHMgJiAwIFxcCiAgICAgICAgICAgICAgICAwICYgMCAmIFxsZG90cyAmIDEgXFwKICAgICAgICAgICAgICAgIDAgJiAwICYgXGxkb3RzICYgMCBcXAogICAgICAgICAgICAgICAgXHZkb3RzICYgXHZkb3RzICYgXHZkb3RzICYgXHZkb3RzIFxcCiAgICAgICAgICAgICAgICAwICYgMCAmIFxsZG90cyAmIDAKICAgICAgICAgICAgICAgXGVuZHtwbWF0cml4fSBcCiAgICAgICAgICAgICAgID0gXG1hdGhiZntVfV9rXGJvbGRzeW1ib2x7XERlbHRhfV9rID0gXG1hdGhiZntafV9rCiAgXGVuZHtlcW5hcnJheSp9CgogIFRoZSAkcCBcdGltZXMgayQgbWF0cml4ICRcbWF0aGJme1Z9X2skIGFjdHMgYXMgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXg6IHRyYW5zZm9ybWluZyAkbiQgcG9pbnRzIGluIGEgJHAkIGRpbWVuc2lvbmFsIHNwYWNlIHRvICRuJCBwb2ludHMgaW4gYSAkayQgZGltZW5zaW9uYWwgc3BhY2UuCgotLS0KCldlIHRha2UgYSBjbG9zZXIgbG9vayBhdApcWwogIFxtYXRoYmZ7Wn1fayA9IFxtYXRoYmZ7WH1cbWF0aGJme1Z9X2sgPSBcYmVnaW57cG1hdHJpeH0KICAgXG1hdGhiZnt4fV8xXlQgXFwKICAgXHZkb3RzIFxcCiAgIFxtYXRoYmZ7eH1fbl5UCiAgXGVuZHtwbWF0cml4fSBcYmVnaW57cG1hdHJpeH0KICAgXG1hdGhiZnt2fV8xIFxsZG90cyBcbWF0aGJme3Z9X2sKICBcZW5ke3BtYXRyaXh9LgpcXQpUaGUgJGkkdGggcm93IChvYnNlcnZhdGlvbikgaW4gJFxtYXRoYmZ7Wn1fayQgZXF1YWxzClxbCiBcbWF0aGJme3p9X3trLGl9XlQgPSBcbWF0aGJme3h9X2leVFxtYXRoYmZ7Vn1fayA9IFxsZWZ0KFxtYXRoYmZ7eH1faV5UIFxtYXRoYmZ7dn1fMSAsIFxtYXRoYmZ7eH1faV5UIFxtYXRoYmZ7dn1fMiAsIFxsZG90cyAsIFxtYXRoYmZ7eH1faV5UIFxtYXRoYmZ7dn1fa1xyaWdodCkuClxdCgpIZW5jZSwgJFxtYXRoYmZ7en1fe2ssaX1eVCA9IFxtYXRoYmZ7eH1faV5UXG1hdGhiZntWfV9rJCBpcyB0aGUgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG9mICRcbWF0aGJme3h9X2kkIG9udG8gdGhlICRrJC1kaW1lbnNpb25hbCBzdWJzcGFjZSBzcGFubmVkIGJ5IHRoZSBjb2x1bW5zIG9mICRcbWF0aGJme1Z9X2skLgoKU1ZEIHRyYW5zZm9ybXMgZGF0YSBzZXQgdG8gbG93ZXIgZGltZW5zaW9uYWwgZGF0YSBzZXQ6ClRoZSBTVkQgdGh1cyBnaXZlcyBhIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSAkcCQgZGltZW5zaW9uYWwgZGF0YSB0byAka1xsZXEgciQgZGltZW5zaW9uYWwgZGF0YToKXFsKICBcbWF0aGJme1p9X2sgPSBcbWF0aGJme1h9XG1hdGhiZntWfV9rLgpcXQpUaGlzIGlzIGVzc2VudGlhbGx5IGEgZGltZW5zaW9uIHJlZHVjdGlvbi4KCi0tLS0KCk5vdGUgdGhhdCwKCi0gVGhlIHRyYW5zZm9ybWF0aW9uIGZyb20gJHAkLWRpbWVuc2lvbmFsICRcbWF0aGJme1h9JCB0byAkayQtZGltZW5zaW9uYWwgJFxtYXRoYmZ7Wn1fayQgaXMgaW1wb3J0YW50LiBJdCBzaG93cyB0aGF0IHRoZSAkbiQgcG9pbnRzIGluIHRoZSByb3dzIG9mICRcbWF0aGJme1p9X2skIGFyZSB0aGUgcmVzdWx0IG9mIHByb2plY3RpbmcgdGhlICRuJCBwb2ludHMgaW4gJFxtYXRoYmZ7WH0kIG9udG8gdGhlIGNvbHVtbnMgb2YgJFxtYXRoYmZ7Vn1fayQgKGkuZS4gdGhlIGZpcnN0ICRrJCBzaW5ndWxhciB2ZWN0b3JzIG9mICRcbWF0aGJme1h9JCkuIFdlIHNheSB0aGF0IHRoZSBzcGFjZSBvZiAkXG1hdGhiZntafV9rJCBpcyBzcGFubmVkIGJ5IHRoZSBjb2x1bW4gb2YgJFxtYXRoYmZ7Vn1fayQuCgotIFRoZSBwb2ludHMgKHJvd3MpIGluICRcbWF0aGJme1h9JCBsaXZlIGluIGEgJHAkLWRpbWVuc2lvbmFsIHNwYWNlIChvciByYW5rKCRcbWF0aGJme1h9JCkkPXIkIGlmICRyPHAkKSBhbmQgdGhleSBhcmUgdGh1cyBwcm9qZWN0ZWQgb250byBhIGxvd2VyIGRpbWVuc2lvbmFsIHNwYWNlLiBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIHRoZSBwcm9qZWN0aW9uICRcbWF0aGJme1h9X2tcbWF0aGJme1Z9X2s9XG1hdGhiZntafV9rJCwgYmVjYXVzZSB0aGUgcG9pbnRzIGluICRcbWF0aGJme1h9X2skIGxpdmUgaW4gYSAkayQtZGltZW5zaW9uYWwgc3Vic3BhY2Ugb2YgJFxtYXRoYmZ7WH0kLgoKLSBOb3RlIHRoYXQgd2l0aCAkazxyJCB0aGVyZSBpcyBubyB1bmlxdWUgdHJhbnNmb3JtYXRpb24gdG8gdHJhbnNmb3JtICRcbWF0aGJme1p9X2skIGJhY2sgdG8gJFxtYXRoYmZ7WH0kLiBPbiB0aGUgcHJldmlvdXMgc2xpZGUgd2Ugb25seSBlc3RhYmxpc2hlZCB0aGUgdHJhbnNmb3JtYXRpb24gJFxtYXRoYmZ7Wn1fayBcbWF0aGJme1Z9X2teVD1cbWF0aGJme1h9X2skLiBJbmRlZWQsIHN0YXJ0aW5nIGZyb20gJFxtYXRoYmZ7WH1cbWF0aGJme1Z9X2sgPSBcbWF0aGJme1p9X2skLCBhbmQgcmlnaHQtbXVsdGlwbHlpbmcgd2l0aCAkXG1hdGhiZntWfV9rXlQkIGRvZXMgbm90IGdpdmUgdGhlIGJhY2t0cmFuc2Zvcm1hdGlvbiwgYmVjYXVzZSAkXG1hdGhiZntWfV9rXG1hdGhiZntWfV9rXlQkIGlzIG5vdCB0aGUgaWRlbnRpdHkgbWF0cml4LgoKCiMgSW50ZXJwcmV0YXRpb24gb2YgU1ZEIGluIHRlcm1zIG9mIGNvcnJlbGF0aW9uIG1hdHJpY2VzCgpGb3IgYSBtYXRyaXggJFxtYXRoYmYgWCQgdGhlIHNhbXBsZSB2YXJpYW5jZSBjb3ZhcmlhbmNlIG1hdHJpeCBlc3RpbWF0b3IgaXMgJHBcdGltZXMgcCQgbWF0cml4CgpcYmVnaW57ZXFuYXJyYXl9ClxtYXRoYmZ7U30mPSZcZnJhY3sxfXtOLTF9KFxtYXRoYmZ7WH0tXGJhcntcbWF0aGJme1h9fSleVCAoXG1hdGhiZntYfS1cYmFye1xtYXRoYmZ7WH19KVxcCiY9JlxmcmFjezF9e04tMX1cbGVmdFtcbWF0aGJme1h9XlRcbWF0aGJme1h9IC0gXGJhcntcbWF0aGJme1h9fV5UXGJhcntcbWF0aGJme1h9fVxyaWdodF0KXGVuZHtlcW5hcnJheX0KClNvICRcbWF0aGJme1h9XlRcbWF0aGJme1h9JCBkZWZpbmVzIHVwIHRvIGEgY29uc3RhbnQgdGhlIHZhcmlhbmNlIGNvdmFyaWFuY2UgbWF0cml4IG9mICRcbWF0aGJme1h9JCEgV2hlbiB0aGUgbWF0cml4IGlzIGNvbHVtbiBjZW50ZXJlZCAkXG1hdGhiZntTfT1cZnJhY3sxfXtuLTF9XG1hdGhiZntYfV5UXG1hdGhiZntYfSQuCgpUaGUgc2FtZSBob2xkcyBmb3IgdGhlIHJvd3Mgb2YgJFxtYXRoYmZ7WH0kISBUaGUgY292YXJpYW5jZSBiZXR3ZWVuIHRoZSBzdWJqZWN0cyBjYW4gYmUgZXN0aW1hdGVkIGFzIFxbXG1hdGhiZntTfT1cZnJhY3sxfXtwLTF9XG1hdGhiZntYfVxtYXRoYmZ7WH1eVFxdIHVwb24gcm93IGNlbnRlcmluZy4KCk5vdGUsIHRoYXQKXGJlZ2lue2VxbmFycmF5fQpcbWF0aGJme1h9XlRcbWF0aGJme1h9ICY9JiBcbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhfVxtYXRoYmZ7VX1eVCBcbWF0aGJme1V9IFxib2xkc3ltYm9se1xEZWx0YX0gXG1hdGhiZntWfV5UIFxcCiY9JlxtYXRoYmZ7Vn1cYm9sZHN5bWJvbHtcRGVsdGF9XjIgXG1hdGhiZntWfV5UClxlbmR7ZXFuYXJyYXl9CgpJZiB3ZSByZXdyaXRlIHRoZSBleHByZXNzaW9uClxiZWdpbntlcW5hcnJheX0KXG1hdGhiZntYfV5UXG1hdGhiZntYfVxtYXRoYmZ7Vn0gJj0mXG1hdGhiZntWfVxib2xkc3ltYm9se1xEZWx0YX1eMiBcbWF0aGJme1Z9XlRcbWF0aGJme1Z9ClxtYXRoYmZ7WH1eVFxtYXRoYmZ7WH1cbWF0aGJme1Z9XFwgJj0mXG1hdGhiZntWfVxib2xkc3ltYm9se1xEZWx0YX1eMgpcZW5ke2VxbmFycmF5fQoKU28sIGlmIHRoZSBkYXRhIGFyZSBjZW50ZXJlZCwgdGhlIFNWRCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGEgc3BlY3RyYWwgZGVjb21wb3NpdGlvbiBvZiB0aGUgc2FtcGxlIGNvdmFyaWFuY2UgbWF0cml4IHdoZXJlIHRoZSByaWdodCBzaW5ndWxhciB2ZWN0b3JzIGNvcnJlc3BvbmQgdG8gdGhlIGVpZ2VuIHZlY3RvcnMgb2YgdGhlIGNvdmFyaWFuY2UgbWF0cml4IGFuZCB0aGUgZWlnZW52YWx1ZXMgYXJlIHRoZSBzcXVhcmVkIHNpbmd1bGFyIHZhbHVlcyEKClNpbWlsYXJseSB0aGUgbGVmdCBzaW5ndWxhciB2YWx1ZXMgY2FuIGJlIHVzZWQgdG8gZXN0aW1hdGUgdGhlIGNvdmFyaWFuY2UgbWF0cml4IG9mIHRoZSByb3dzIG9mICRcbWF0aGJme1h9JC4gU28gaW4gb3VyIG5vdGF0aW9uIGNvdmFyaWFuY2UgYmV0d2VlbiBzdWJqZWN0cy4KClxiZWdpbntlcW5hcnJheX0KXG1hdGhiZntYfVxtYXRoYmZ7WH1eVCAmPSZcbWF0aGJme1V9XGJvbGRzeW1ib2x7XERlbHRhfV4yIFxtYXRoYmZ7VX1eVApcZW5ke2VxbmFycmF5fQoKVGhpcyBsaW5rIGlzIGZvciBpbnN0YW5jZSB2ZXJ5IHVzZWZ1bCBmb3IgcmVjb21tZW5kZXIgc3lzdGVtcywgaS5lLiB0byBwcm9wb3NlIG1vdmllcyBiYXNlZCBvbiB0aGUgc3ViamVjdHMgd2l0aCB3aG9tIHlvdSBjb3JyZWxhdGUuIFdlIHdpbGwgYWxzbyBleHBsb2l0IHRoaXMgd2hlbiB3ZSBkaXNjdXNzIG9uIFBDQS4KCiMgU1ZEIGFuZCBpbnZlcnNlIG9mIGEgbWF0cml4CgpBIGxpbmVhciBzeXN0ZW0gb2YgZXF1YXRpb25zIHdpdGggJG4kIGVxdWF0aW9ucyBhbmQgJG4kIHVua25vd25zClxbClxtYXRoYmZ7QX1fe25cdGltZXMgbn0gXGJvbGRzeW1ib2x7XGJldGF9ID0gXG1hdGhiZntifQpcXQpjYW4gYmUgc29sdmVkIGJ5ClxbClxib2xkc3ltYm9se1xiZXRhfSA9IFxtYXRoYmZ7QX1fe25cdGltZXMgbn1eey0xfSBcbWF0aGJme2J9ClxdCgpBIHVuaXF1ZSBzb2x1dGlvbiBleGlzdHMgaWYgQSBpcyBmdWxsIHJhbmsuCgpOb3RlLCB0aGF0IGEgc2luZ3VsYXIgdmFsdWUgZGVjb21wb3NpdGlvbiBvZiB0aGUgc3F1YXJlIG1hdHJpeCAkXG1hdGhiZntBfT1cbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhfVxtYXRoYmZ7Vn1eVCQgZW5hYmxlcyB0aGUgaW52ZXJzZSB0byBiZSB3cml0dGVuIGFzCgpcWwpcbWF0aGJme0F9XnstMX0gPSBcbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhfV57LTF9XG1hdGhiZntWfV5UClxdCgppbmRlZWQKXFsKXG1hdGhiZntBfV57LTF9IFxtYXRoYmZ7QX0gPSBcbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhfV57LTF9XG1hdGhiZntWfV5UXG1hdGhiZntWfVxib2xkc3ltYm9se1xEZWx0YX1cbWF0aGJme1Z9XlQgPSBcbWF0aGJme0l9ClxdCgpOb3RlLCB0aGF0IHRoZSBTVkQgZ2VuZXJhbGl6ZXMgdGhpcyB0byBzeXN0ZW1zIG9mIHVuZGVyIChuPHAsIGZhdCBzaG9ydCBtYXRyaWNlcykKIGFuZCBvdmVyIGRldGVybWluZWQgc3lzdGVtcyAobj5wIHRhbGwgc2tpbm55IG1hdHJpY2VzKToKCkxldApcYmVnaW57ZXFuYXJyYXl9ClxtYXRoYmZ7QX0gPSBcbWF0aGJme1V9XGJvbGRzeW1ib2x7XERlbHRhfVxtYXRoYmZ7Vn1eVApcZW5ke2VxbmFycmF5fQoKYW5kIHdlIHdhbnQgdG8gc29sdmUKXGJlZ2lue2VxbmFycmF5fQpcbWF0aGJme0F9IFxib2xkc3ltYm9se1xiZXRhfSAmPSYgXG1hdGhiZntifVxcClxtYXRoYmZ7VX1cYm9sZHN5bWJvbHtcRGVsdGF9XG1hdGhiZntWfV5UIFxib2xkc3ltYm9se1xiZXRhfSAmPSYgXG1hdGhiZntifVxcClxtYXRoYmZ7VX1eVFxtYXRoYmZ7VX1cYm9sZHN5bWJvbHtcRGVsdGF9XG1hdGhiZntWfV5UIFxib2xkc3ltYm9se1xiZXRhfSAmPSYgXG1hdGhiZntVfV5UXG1hdGhiZntifVxcClxib2xkc3ltYm9se1xEZWx0YX1cbWF0aGJme1Z9XlQgXGJvbGRzeW1ib2x7XGJldGF9ICY9JiBcbWF0aGJme1V9XlRcbWF0aGJme2J9XFwKXGJvbGRzeW1ib2x7XERlbHRhfV57LTF9XGJvbGRzeW1ib2x7XERlbHRhfVxtYXRoYmZ7Vn1eVCBcYm9sZHN5bWJvbHtcYmV0YX0gJj0mIFxib2xkc3ltYm9se1xEZWx0YX1eey0xfVxtYXRoYmZ7VX1eVFxtYXRoYmZ7Yn1cXApcbWF0aGJme1Z9XG1hdGhiZntWfV5UIFxib2xkc3ltYm9se1xiZXRhfSAmPSYgXG1hdGhiZntWfVxib2xkc3ltYm9se1xEZWx0YX1eey0xfVxtYXRoYmZ7VX1eVFxtYXRoYmZ7Yn1cXApcYm9sZHN5bWJvbHtcYmV0YX0gJj0mIFxtYXRoYmZ7Vn1cYm9sZHN5bWJvbHtcRGVsdGF9XnstMX1cbWF0aGJme1V9XlRcbWF0aGJme2J9ClxlbmR7ZXFuYXJyYXl9CgpOb3RlLCB0aGF0IGZvciBhbiBvdmVyZGV0ZXJtaW5lZCBzeXN0ZW0gJG4+cCQgc28gJHJcbGVxIHAkLgpHZW5lcmFsbHksICRyPXAkIGFuZCAkXG1hdGhiZntWfSQgaXMgdGh1cyBhIHNxdWFyZSBtYXRyaXggc28gYm90aCAkXG1hdGhiZntWfV5UXG1hdGhiZntWfT1cbWF0aGJme0l9JCBhbmQgICRcbWF0aGJme1Z9XG1hdGhiZntWfV5UPVxtYXRoYmZ7SX0kLiBIb3dldmVyLCAkXG1hdGhiZntVfV5UXG1hdGhiZntVfT1cbWF0aGJme0l9JCBidXQgICRcbWF0aGJme1V9XG1hdGhiZntVfV5UXG5lcVxtYXRoYmZ7SX0kIGJlY2F1c2UgJHI8biQuCgokXG1hdGhiZntBfV5cZGFnZ2VyPVxtYXRoYmZ7Vn1cYm9sZHN5bWJvbHtcRGVsdGF9XnstMX1cbWF0aGJme1V9XlQkIGlzIGFsc28gcmVmZXJyZWQgdG8gYXMgdGhlIHBzZXVkbyBpbnZlcnNlIGFuZCBpdCBlbmFibGVzIHVzIHRvIHNvbHZlIHVuZGVyIGFuZCBvdmVyZGV0ZXJtaW5lZCBzeXN0ZW1zIG9mIGVxdWF0aW9ucy4KCk5vdGUsIHRoYXQgZm9yCgotIHVuZGVyZGV0ZXJtaW5lZCBzeXN0ZW1zIHRoZXJlIHR5cGljYWxseSBkb2VzIG5vdCBleGlzdCBhIHVuaXF1ZSBzb2x1dGlvbgotIGZvciBvdmVyZGV0ZXJtaW5lZCBzeXN0ZW1zIHVzdWFsbHkgdGhlcmUgZG9lcyBub3QgZXhpc3QgYW4gZXhhY3Qgc29sdXRpb24uIFdlIHdpbGwgZm9jdXMgb24gdGhlIGxhdHRlciBpbiB0aGUgbmV4dCBzZWN0aW9uIHdoZXJlIHdlIGV4cGxvcmUgdGhlIGxpbmsgYmV0d2VlbiBsaW5lYXIgcmVncmVzc2lvbiBhbmQgU1ZELgoKIyBMaW5lYXIgcmVncmVzc2lvbiBhbmQgU1ZECgpTdXBwb3NlIHdlIGhhdmUgdGhlIGxpbmVhciByZWdyZXNzaW9uIHByb2JsZW0gd2l0aCAkbj5wJDoKClxbXG1hdGhiZntZfT1cbWF0aGJme1h9XGJvbGRzeW1ib2x7XGJldGF9ICsgXGJvbGRzeW1ib2x7XGVwc2lsb259XF0KCiRcbWF0aGJme1h9JCBpcyBhIHRhbGwgc2tpbm55IG1hdHJpeCB3aXRoICRuID4+IHAkLgoKV2Uga25vdyB0aGF0ClxbClxoYXR7XGJvbGRzeW1ib2x7XGJldGF9fT1cbGVmdChcbWF0aGJme1h9XlQgXG1hdGhiZntYfVxyaWdodCleey0xfVxtYXRoYmZ7WH1eVFxtYXRoYmZ7WX0KXF0KCklmIHdlIHJlcGxhY2UgJFxtYXRoYmZ7WH0kIGJ5IGl0cyBTVkQKClxiZWdpbntlcW5hcnJheX0KXGhhdHtcYm9sZHN5bWJvbHtcYmV0YX19Jj0mXGxlZnQoXG1hdGhiZntWfVxib2xkc3ltYm9se1xEZWx0YX1eMlxtYXRoYmZ7Vn1eVFxyaWdodCleey0xfVxtYXRoYmZ7Vn1cYm9sZHN5bWJvbHtcRGVsdGF9XG1hdGhiZntVfV5UXG1hdGhiZntZfVxcClxoYXR7XGJvbGRzeW1ib2x7XGJldGF9fSY9JlxtYXRoYmZ7Vn1cYm9sZHN5bWJvbHtcRGVsdGF9XnstMn1cbWF0aGJme1Z9XlRcbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhfVxtYXRoYmZ7VX1eVFxtYXRoYmZ7WX1cXApcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0mPSZcbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhfV57LTF9XG1hdGhiZntVfV5UXG1hdGhiZntZfQpcZW5ke2VxbmFycmF5fQoKU28gdGhlIFNWRCBhbHNvIHNvbHZlcyB0aGUgbGluZWFyIHJlZ3Jlc3Npb24gcHJvYmxlbSBieSB1c2luZyB0aGUgcHNldWRvaW52ZXJzZSEKSWYgd2Ugbm93IHRoaW5rIGFib3V0IHRoZSBmaXQ6CgpcYmVnaW57ZXFuYXJyYXl9ClxoYXR7XG1hdGhiZntZfX0mPSZcbWF0aGJme1h9XGhhdHtcYm9sZHN5bWJvbHtcYmV0YX19XFwKJj0mXG1hdGhiZntVfVxib2xkc3ltYm9se1xEZWx0YX1eey0xfVxtYXRoYmZ7Vn1eVFxtYXRoYmZ7Vn1cYm9sZHN5bWJvbHtcRGVsdGF9XG1hdGhiZntVfV5UXG1hdGhiZntZfVxcCiY9JlxtYXRoYmZ7VX1cbWF0aGJme1V9XlRcbWF0aGJme1l9ClxlbmR7ZXFuYXJyYXl9CgotIEZvciBhbiBvdmVyZGV0ZXJtaW5lZCBzeXN0ZW0gJFxtYXRoYmZ7VX1cbWF0aGJme1V9XlQkIGlzIG5vdCBlcXVhbCB0byB0aGUgdW5pdHkgbWF0cml4ICRcbWF0aGJme0l9JCAoZm9yIGFuIG92ZXJkZXRlcm1pbmVkIHN5c3RlbSBvbmx5ICRcbWF0aGJme1V9XlRcbWF0aGJme1V9PVxtYXRoYmZ7SX0kIGJlY2F1c2UgJG4+ciQpLgoKLSBTbyAkXGhhdHtcbWF0aGJme1l9fVxuZXEgXG1hdGhiZntZfSQuIEhlbmNlLCB3ZSB0eXBpY2FsbHkgZG8gbm90IGhhdmUgYW4gZXhhY3Qgc29sdXRpb24uCgotIE5vdGUsIHRoYXQgJFxtYXRoYmZ7VX1cbWF0aGJme1V9XlQkIHNwYW5zIHRoZSBzYW1lIHNwYWNlIGFzIHRoZSBjb2x1bW5zIG9mICRcbWF0aGJme1h9JCwgYW5kIHdpbGwgZGVmaW5lIHRoZSBzYW1lICRwJC1kaW1lbnNpb25hbCBwbGFuZSBpbiB0aGUgJG4kIGRpbWVuc2lvbmFsIHNwYWNlICRcbWF0aGNhbHtSfV5uJCwgZS5nLiBjZnIgJFxtYXRoYmZ7WH1cbGVmdChcbWF0aGJme1h9XlRcbWF0aGJme1h9XHJpZ2h0KV57LTF9XG1hdGhiZntYfV5UJC4gU28gaXQgcHJvamVjdHMgJFxtYXRoYmZ7WX0kIGluIHRoZSBjb2x1bW4gc3BhY2Ugb2YgJFxtYXRoYmZ7WH0kIGFuZCB0aGUgZXJyb3JzIHdpbGwgYmUgb3J0aG9nb25hbCBvbnRvIHRoaXMgcGxhbmUuCgojIyBFeGFtcGxlIHByb3N0YXRlIGRhdGFzZXQKIyMjIEZpdCB3aXRoIGxtCgpgYGB7cn0KcHJvc3RhdGUgPC0gcmVhZF9jc3YoCiAgImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9HVFBCL1BTTFMyMC9tYXN0ZXIvZGF0YS9wcm9zdGF0ZS5jc3YiLAogIGNvbF90eXBlcyA9IGNvbHMoKQopCmxtMSA8LSBsbShscHNhIH4gbGNhdm9sICsgbHdlaWdodCArIHN2aSwgcHJvc3RhdGUpCmBgYAoKIyMjIEZpdCB3aXRoIFNWRAoKYGBge3J9ClggPC0gcHJvc3RhdGVbLGMoMToyLDUpXQpYWywzXSA8LSBhcy5kb3VibGUoWFssM10hPSJoZWFsdGh5IikKWCA8LSBjYmluZChJbnRlcmNlcHQ9MSxYKQoKc3ZkWCA8LSBzdmQoWCkKYmV0YVN2ZCA8LSBzdmRYJHYgJSolIGRpYWcoMS9zdmRYJGQpICUqJSB0KHN2ZFgkdSkgJSolIHByb3N0YXRlJGxwc2EKCmNiaW5kKGxtMSRjb2VmLGJldGFTdmQpCmBgYAoKIyBTVkQgYW5kIE11bHRpLURpbWVuc2lvbmFsIFNjYWxpbmcgKE1EUykKCiMjIEV4YW1wbGUKCkluIHRoaXMgc2VjdGlvbiB3ZSB3aWxsIHVzZSBhIGRhdGFzZXQgb24gZm9vZCBjb25zdW1wdGlvbiBpbiB0aGUgVUsuIFRoZSBkYXRhIG9yaWdpbmF0ZSBmcm9tIHRoZSBVS3Mg4oCYRGVwYXJ0bWVudCBmb3IgRW52aXJvbm1lbnQsIEZvb2QgYW5kIFJ1cmFsIEFmZmFpcnPigJkgKERFRlJBKSwgc2hvd2luZyB0aGUgY29uc3VtcHRpb24gaW4gZ3JhbXMgKHBlciBwZXJzb24sIHBlciB3ZWVrKSBvZiAxNyBkaWZmZXJlbnQgdHlwZXMgb2YgZm9vZHN0dWZmIG1lYXN1cmVkIGFuZCBhdmVyYWdlZCBpbiB0aGUgZm91ciBjb3VudHJpZXMgb2YgdGhlIFVuaXRlZCBLaW5nZG9tIGluIDE5OTcuIFdlIHdvdWxkIGxpa2UgdG8gZXhwbG9yZSB0aGUgZGF0YSBhbmQgaW50ZXJwcmV0IGhvdyB0aGUgZm9vZCBwYXR0ZXJucyBvZiB0aGUgZGlmZmVyZW50IGNvdW50cmllcyBkaWZmZXIuCgpgYGB7cn0KdWsgPC0gcmVhZF9jc3YoCiAgImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGF0T21pY3MvSERBMjAyMC9kYXRhL3VrRm9vZHMuY3N2IiwKICBjb2xfdHlwZXMgPSBjb2xzKCkKKQprbml0cjo6a2FibGUodWssIGNhcHRpb24gPSAiVGhlIGZ1bGwgVUsgZm9vZHMgZGF0YSB0YWJsZSIpCmBgYAoKTm90ZSwgdGhhdCBoZXJlIHRoZSBtYXRyaXggaXMgZGlzcGxheWVkIHdpdGggdGhlIHAgdmFyaWFibGVzIGluIHRoZSByb3dzIGFuZCB0aGUgbiBleHBlcmltZW50YWwgdW5pdHMgKGNvdW50cmllcykgaW4gdGhlIGNvbHVtbnMuClRoaXMgaXMgb2Z0ZW4gZG9uZSBmb3IgaGlnaCBkaW1lbnNpb25hbCBkYXRhIHdoZXJlICRwPj5uJCBiZWNhdXNlIHRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIGxvb2sgYXQgdG8gdGhlIHJhdyBkYXRhIHRhYmxlLgpOb3RlLCB0aGF0IHRoZSBzdmQgY2FsY3VsYXRlcyBsZWZ0IGFuZCByaWdodCBzaW5ndWxhciB2ZWN0b3JzIHNvIGl0IHdpbGwgYWxzbyBwcm92aWRlIHRoZSBjb3JyZWN0IHNvbHV0aW9uLCB3ZSBqdXN0IHNob3VsZCBsb29rIHRvIHRoZSBvdGhlciBzZXQgb2Ygc2luZ3VsYXIgdmVjdG9ycyBpbiBvcmRlciB0byBnZXQgdG8gdGhlIGNvcnJlY3QgaW50ZXJwcmV0YXRpb24uCgojIyBNb3RpdmF0aW9uCgpUaGUgb2JqZWN0aXZlIG9mIE11bHRpZGltZW5zaW9uYWwgU2NhbGluZyAoTURTKSBpcyB0byBmaW5kIGEgbG93LWRpbWVuc2lvbmFsIHJlcHJlc2VudGF0aW9uLCBzYXkgJGskLWRpbWVuc2lvbmFsLCBvZiAkbiQgZGF0YSBwb2ludHMgc3VjaCB0aGF0IHRoZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGUgJG4kIHBvaW50cyBpbiB0aGUgJGskLWRpbWVuc2lvbmFsIHNwYWNlIGlzIGEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIGEgZ2l2ZW4gc3F1YXJlZCBkaXN0YW5jZSBtYXRyaXgsIHNheSAkXG1hdGhiZntEfV9YJC4KCi0gVGhlIHNxdWFyZWQgZGlzdGFuY2UgbWF0cml4ICRcbWF0aGJme0R9X1gkIG1heSBiZSBnaXZlbiB3aXRob3V0IGtub3dsZWRnZSBvZiB0aGUgb3JpZ2luYWwgb2JzZXJ2YXRpb25zIChub3QgZXZlbiB0aGUgZGltZW5zaW9uYWxpdHkpLCBvciBpdCBtYXkgYmUgY29tcHV0ZWQgZnJvbSBhIGdpdmVuIHNldCBvZiAkbiQgJHAkLWRpbWVuc2lvbmFsIGRhdGEgcG9pbnRzLgoKLSBOb3RlIHRoYXQgdGhlIGRpc3RhbmNlcyBiZXR3ZWVuIHBvaW50cyBpbiBhICRrJC1kaW1lbnNpb25hbCBzdWJzcGFjZSBjb2luY2lkZSB3aXRoIHRoZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHMgaW4gdGhlIGxhcmdlciAkcCQtZGltZW5zaW9uYWwgc3BhY2UuCgpVc2Ugb2YgTURTOgoKLSBBIGhpZ2ggZGltZW5zaW9uYWwgZGF0YSBtYXRyaXggJFxtYXRoYmZ7WH0kIGlzIGdpdmVuLCBhbmQgb25lIHdhbnRzIHRvIGdldCBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiAoaW4gMiBvciAzIGRpbWVuc2lvbnMpIG9mIHRoZSBvYnNlcnZhdGlvbnMuIEluIHRoaXMgZ3JhcGggZWFjaCBwb2ludCByZXByZXNlbnRzIGFuIG9ic2VydmF0aW9uIChyb3cgb2YgZGF0YSBtYXRyaXgpLiBGcm9tIHRoaXMgZ3JhcGggb25lIHdhbnRzIHBvaW50cyBjbG9zZSB0byBvbmUgYW5vdGhlciB0byBiZSBzaW1pbGFyLCBhbmQgb2JzZXJ2YXRpb25zIGZhciBhd2F5IGZyb20gb25lIGFub3RoZXIgdG8gYmUgZGlzc2ltaWxhci4gVGh1cyB0aGUgZGlzdGFuY2VzIGJldHdlZW4gdGhlICRuJCBwb2ludHMgaW4gdGhlIG9yaWdpbmFsICRwJC1kaW1lbnNpb25hbCBzcGFjZSBzaG91bGQgYmUgd2VsbCBwcmVzZXJ2ZWQgaW4gdGhlIDIgb3IgMyBkaW1lbnNpb25hbCBzcGFjZS4KCi0gSW4gc29tZSBhcHBsaWNhdGlvbnMgdGhlIHJlc2VhcmNoZXIgb25seSBoYXMga25vd2xlZGdlIG9mIHRoZSBzaW1pbGFyaXR5IChvciBkaXNzaW1pbGFyaXR5KSBiZXR3ZWVuIG9ic2VydmF0aW9ucy4gRm9yIGV4YW1wbGUsIGZvb2QgcHJvZHVjdHMgY2FuIGJlIGV2YWx1YXRlZCBieSBhIHRhc3RlIHBhbmVsIGFuZCBhIGRpc3NpbWlsYXJpdHkgbWF0cml4IGNhbiBiZSBjb21wbGV0ZWQuIFRoaXMgZGlzc2ltaWxhcml0eSBtYXRyaXggc2hvd3MgZm9yIGVhY2ggcGFpciBvZiBmb29kIHByb2R1Y3RzIHRoZWlyIGRpc3NpbWlsYXJpdHkgKG51bWVyaWNhbCB2YWx1ZXMgcHJvdmlkZWQgYnkgdGFzdGUgcGFuZWwsIGJ1dCBub3Qgb2JqZWN0aXZlbHkgcXVhbnRpZmllZCkuIEdpdmVuIHRoaXMgZGlzc2ltaWxhcml0eSBtYXRyaXgsIGEgMiBvciAzIGRpbWVuc2lvbmFsIGdyYXBoIGNvdWxkIGJlIGhlbHBmdWwgaWYgdGhlIGRpc3RhbmNlcyBiZXR3ZWVuIHRoZSBwb2ludHMgKGZvb2QgcHJvZHVjdHMpIGluIHRoaXMgZ3JhcGggYXJlIG1vbm90b25pY2FsbHkgcmVsYXRlZCB0byB0aGUgZGlzc2ltaWxhcml0aWVzIHByb3ZpZGVkIGJ5IHRoZSB0YXN0ZSBwYW5lbC4gRm9vZCBwcm9kdWN0cyBjbG9zZSB0byBvbmUgYW5vdGhlciBpbiB0aGlzIGdyYXBoLCB0YXN0ZSBzaW1pbGFybHkuCgotIEhlcmUgd2UgZGlzY3VzcyB0aGUgIm1ldHJpYyIgTURTLCB3aGljaCBhY3R1YWxseSByZXF1aXJlcyB0aGUgRXVjbGlkZWFuIGRpc3RhbmNlcyBiZXR3ZWVuIG9ic2VydmF0aW9ucy4gSG93ZXZlciwgdGhlIG1ldGhvZCB3b3JrcyBhbHNvIHdlbGwgaWYgdGhlIG1hdHJpeCAkXG1hdGhiZntEfV9YJCBjb250YWlucyBkaXNzaW1pbGFyaXRpZXMgcmF0aGVyIHRoYW4gc3F1YXJlZCBFdWNsaWRlYW4gZGlzdGFuY2VzLgoKCi0tLQoKSW4gdGhpcyBjaGFwdGVyIHdlIGFzc3VtZSB0aGF0IHRoZSBkYXRhIG1hdHJpeCAkXG1hdGhiZntYfSQgaXMgY29sdW1uLWNlbnRlcmVkIChpLmUuIGVhY2ggY29sdW1uIGhhcyBtZWFuIHplcm8pLgoKQ2VudGVyaW5nIGNhbiBiZSBhY2NvbXBsaXNoZWQgYnkgbXVsdGlwbHlpbmcgdGhlIG9yaWdpbmFsIGRhdGEgbWF0cml4ICRcbWF0aGJme1h9JCB3aXRoIHRoZSAkbiBcdGltZXMgbiQgJFxtYXRoYmZ7Y2VudGVyaW5nXCBtYXRyaXh9JAogXFsKICAgXG1hdGhiZntIfSA9IFxtYXRoYmZ7SX0gLSBcZnJhY3sxfXtufSBcbWF0aGJmezF9XG1hdGhiZnsxfV5UICwKIFxdCiBpbiB3aGljaCAkXG1hdGhiZnsxfSQgaXMgYW4gJG4kLXZlY3RvciB3aXRoIGFsbCBlbnRyaWVzIGVxdWFsIHRvIDEuCiBIZW5jZSwgJFxtYXRoYmZ7SH1cbWF0aGJme1h9JCBpcyB0aGUgY29sdW1uLWNlbnRlcmVkIGRhdGEgbWF0cml4LgoKV2Ugd2lsbCBhc3N1bWUgdGhhdCAkXG1hdGhiZntYfSQgaXMgYWxyZWFkeSBjb2x1bW4tY2VudGVyZWQsIGFuZCB0aGVyZWZvcmUgJFxtYXRoYmZ7SH1cbWF0aGJme1h9PVxtYXRoYmZ7WH0kLgoKKE5vdGUsIHRoYXQgdGhlIG1hdHJpeCAkXG1hdGhiZnsxfVxtYXRoYmZ7MX1eVCQgaXMgYW4gJG5cdGltZXMgbiQgbWF0cml4IHdpdGggYWxsIGVudHJpZXMgc2V0IHRvIDEuCikKCi0tLQoKV2Ugd2lsbCBuZWVkIHRoZSBmb2xsb3dpbmcgaW50ZXJlc3RpbmcgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlICoqR3JhbSBtYXRyaXgqKiAkXG1hdGhiZntYfVxtYXRoYmZ7WH1eVCQgYW5kIHRoZSBkaXN0YW5jZSBtYXRyaXguCgotIEZvciBhbiAkblx0aW1lcyBwJCBkYXRhIG1hdHJpeCAkXG1hdGhiZntYfSQsIHRoZSBtYXRyaXggJFxtYXRoYmZ7RH1fWCQgd2l0aCBzcXVhcmVkIGRpc3RhbmNlcyBoYXMgZWxlbWVudHMKICAgXFsKICAgICAgKFxtYXRoYmZ7eH1fe2l9LVxtYXRoYmZ7eH1fe2p9KV5UKFxtYXRoYmZ7eH1fe2l9LVxtYXRoYmZ7eH1fe2p9KSA9IFxWZXJ0IFxtYXRoYmZ7eH1faVxWZXJ0XjIgLSAyIFxtYXRoYmZ7eH1eVF9pXG1hdGhiZnt4fV9qICsgXFZlcnQgXG1hdGhiZnt4fV9qXFZlcnQuXjIKICAgXF0KCgotVGhlICRuXHRpbWVzIG4kIHNxdWFyZWQgZGlzdGFuY2UgbWF0cml4IGNhbiB0aGVuIGJlIHdyaXR0ZW4gYXMKICAgXFsKICAgICBcbWF0aGJme0R9X1ggPSBcbWF0aGJme059IC0gMlxtYXRoYmZ7WH1cbWF0aGJme1h9XlQgKyBcbWF0aGJme059XlQgLAogICBcXQogICB3aXRoICRcbWF0aGJme059JCB0aGUgJG4gXHRpbWVzIG4kIG1hdHJpeCB3aXRoICRpJHRoIHJvdyBmaWxsZWQgd2l0aCAkXFZlcnQgXG1hdGhiZnt4fV9pXFZlcnReMiQuCgotIE5vdGUgdGhhdCB0aGUgZWxlbWVudHMgb2YgJFxtYXRoYmZ7Tn0kIGNhbiBhbHNvIGJlIGZvdW5kIG9uIHRoZSBkaWFnb25hbCBvZiAkXG1hdGhiZntYWH1eVCQuCgotIEdpdmVuIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlICRcbWF0aGJme0h9JCBhbmQgJFxtYXRoYmZ7Tn0kIG1hdHJpY2VzLCBpdCBpcyBlYXN5IHRvIHZlcmlmeSB0aGF0CiAgIFxbCiAgICAgIC1cZnJhY3sxfXsyfVxtYXRoYmZ7SH1cbWF0aGJme0R9X1hcbWF0aGJme0h9ID0gXG1hdGhiZntYfVxtYXRoYmZ7WH1eVC4KICAgXF0gVGhpcyBnaXZlcyBhbiBpbXBvcnRhbnQgcmVsYXRpb24gYmV0d2VlbiB0aGUgZGlzdGFuY2UgbWF0cml4IGFuZCB0aGUgR3JhbSBtYXRyaXguIFdlIHdpbGwgdXNlIHRoZSBub3RhdGlvbiAkXG1hdGhiZntHfV9YID0gLVxmcmFjezF9ezJ9XG1hdGhiZntIfVxtYXRoYmZ7RH1fWFxtYXRoYmZ7SH0kLgoKLSAgVGhlICRuIFx0aW1lcyBuJCBHcmFtIG1hdHJpeCAkXG1hdGhiZntYfVxtYXRoYmZ7WH1eVCQgIGVxdWFscwpcWwogIFxiZWdpbntwbWF0cml4fQogICBcbWF0aGJme3h9XzFeVCBcXAogICBcdmRvdHMgIFxcCiAgIFxtYXRoYmZ7eH1fbl5UCiAgXGVuZHtwbWF0cml4fQogIFxiZWdpbntwbWF0cml4fQogICAgXG1hdGhiZnt4fV8xIFxsZG90cyBcbWF0aGJme3h9X24KICBcZW5ke3BtYXRyaXh9ClxdCmFuZApoYXMgdGh1cyBvbiBpdHMgJChpLGopJHRoIHBvc2l0aW9uIHRoZSBpbm5lciBwcm9kdWN0ClxbCiAgIFxtYXRoYmZ7eH1faV5UXG1hdGhiZnt4fV9qPSBcVmVydCBcbWF0aGJme3h9X2lcVmVydFxWZXJ0IFxtYXRoYmZ7eH1falxWZXJ0IFxjb3M8XG1hdGhiZnt4fV9pLFxtYXRoYmZ7eH1faj4gLgpcXQoKLSBPbiB0aGUgZGlhZ29uYWwgd2UgZmluZCAkXG1hdGhiZnt4fV9pXlRcbWF0aGJme3h9X2k9XFZlcnQgXG1hdGhiZnt4fV9pXFZlcnReMiQsIHRoZSBzcXVhcmVkIG5vcm0gb2YgdGhlICRpJHRoIG9ic2VydmF0aW9uLgoKLSBUaGUgcmVsYXRpb24gJC1cZnJhY3sxfXsyfVxtYXRoYmZ7SH1cbWF0aGJme0R9X1hcbWF0aGJme0h9ID0gXG1hdGhiZntYfVxtYXRoYmZ7WH1eVCQgdGVsbHMgdXMgdGhhdCB0aGUgZGlzdGFuY2UgbWF0cml4IGFuZCB0aGUgR3JhbSBtYXRyaXggY29udGFpbiB0aGUgc2FtZSBpbmZvcm1hdGlvbi4gVGhlIGRpc3RhbmNlcywgaG93ZXZlciwgYXJlIGluIG1vc3Qgc2l0dWF0aW9ucyBlYXNpZXIgdG8gaW50ZXJwcmV0LgoKLS0tCgojIyBMaW5rIHdpdGggdGhlIFNWRAoKTm90ZSwgdGhhdCB3ZSBoYXZlIHNob3duIHRoYXQgd2UgY2FuIHJld3JpdGUgJFxtYXRoYmZ7WH1cbWF0aGJme1h9XlQkIHVzaW5nIHRoZSBTVkQ6CgpcWwpcbWF0aGJme1h9XG1hdGhiZntYfV5UID0gXG1hdGhiZntVfVxib2xkc3ltYm9se1xEZWx0YX1eMlxtYXRoYmZ7VX1eVApcXQoKQmVjYXVzZSB0aGUgdHJ1bmNhdGVkIFNWRCBvZiAkXG1hdGhiZntYfSQgbWluaW1pc2VzIHRoZSBGcm9iZW5pdXMgbm9ybSAkXFZlcnQgXG1hdGhiZntYfS1cbWF0aGJme1h9X2tcVmVydF9GXjIkLCBpdCB0aGlzIGhhcyBhbiBpbXBvcnRhbnQgY29uc2VxdWVuY2U6CgotIExldCAkXG1hdGhiZntEfV9YJCBkZW5vdGUgdGhlICRuIFx0aW1lcyBuJCBtYXRyaXggd2l0aCB0aGUgc3F1YXJlZCBFdWNsaWRpYW4gZGlzdGFuY2VzIGJldHdlZW4gdGhlICRuJCBkYXRhIHBvaW50cyAkXG1hdGhiZnt4fV9pJCBpbiB0aGUgb3JpZ2luYWwgJHAkLWRpbWVuc2lvbmFsIHNwYWNlLgoKLSBMZXQgJFxtYXRoYmZ7RH1fe1prfSQgZGVub3RlIHRoZSAkbiBcdGltZXMgbiQgbWF0cml4IHdpdGggdGhlIHNxdWFyZWQgRXVjbGlkaWFuIGRpc3RhbmNlcyBiZXR3ZWVuIHRoZSAkbiQgdHJhbnNmb3JtZWQgZGF0YSBwb2ludHMgJFxtYXRoYmZ7en1fe2ssaX0kIGluIHRoZSByZWR1Y2VkICRrJC1kaW1lbnNpb25hbCBzcGFjZS4KCiBUaGVuLCBpdCBjYW4gYmUgc2hvd24gdGhhdCB0aGUgdHJ1bmNhdGVkIFNWRCBhbHNvIG1pbmltaXNlcwogXFsKICAgXFZlcnQgXG1hdGhiZntEfV9YIC0gXG1hdGhiZntEfV97Wmt9IFxWZXJ0X0ZeMi4KIFxdCgpPciBpbiBvdGhlciB3b3JkczogVGhlIG4gcG9pbnRzICRcbWF0aGJme3p9X3trLGl9JCBpbiB0aGUgay1kaW1lbnNpb25hbCBzdWJzcGFjZSBzcGFubmVkIGJ5IHRoZSBjb2x1bW5zIG9mICRcbWF0aGJme1Z9X2skIGFyZSB0aGUgYmVzdCBhcHByb3hpbWF0aW9uIG9mIHRoZSAkbiQgb3JpZ2luYWwgcG9pbnRzICRcbWF0aGJme3h9X2kkIGluIHRoZSBvcmlnaW5hbCBwLWRpbWVuc2lvbmFsIHNwYWNlIGluIHRoZSBzZW5zZSB0aGF0IHRoZSBFdWNsaWRlYW4gZGlzdGFuY2VzIGJldHdlZW4gdGhlIG4gb3JpZ2luYWwgcG9pbnRzIGFyZSBiZXN0IGFwcHJveGltYXRlZCBieSB0aGUgRXVjbGlkZWFuIGRpc3RhbmNlcyBiZXR3ZWVuIHRoZSBuIHRyYW5zZm9ybWVkIHBvaW50cywgYW1vbmcgYWxsIHBvc3NpYmxlIGstZGltZW5zaW9uYWwgbGluZWFyIHN1YnNwYWNlcy4KCi0tLQoKLSBJZiAkXG1hdGhiZntYfSQgaXMga25vd24sIHdlIGNhbiByZWFkaWx5IG9idGFpbiB0aGUgay1kaW1lbnNpb25hbCBwcm9qZWN0aW9uIGJ5IHRoZSBTVkQgb2YgJFxtYXRoYmZ7WH0kCgotIElmIHdlIG9ubHkga25vdyB0aGUgZGlzdGFuY2UgbWF0cml4ICRcbWF0aGJme0R9JAoKICAgIDEuIFdlIGNhbiByZWFkaWx5IG9idGFpbiB0aGUgR3JhbSBtYXRyaXgKICAgIFxbLVxmcmFjezF9ezJ9XG1hdGhiZntIfVxtYXRoYmZ7RH1fWFxtYXRoYmZ7SH0gPSBcbWF0aGJme1h9XG1hdGhiZntYfV5UXF0KICAgIDIuIFRoZSB0cnVuY2F0ZWQgU1ZEIG9mIHRoZSBzcXVhcmVkIGFuZCBzeW1tZXRyaWMgR3JhbSBtYXRyaXgKICAgIFxbXG1hdGhiZntVfV9rXGJvbGRzeW1ib2x7XERlbHRhfV9rXlxwcmltZVxtYXRoYmZ7VX1fa15UXF0KICAgIDMuIGZyb20gd2hpY2ggYWxzbyBjYW4gb2J0YWluCiAgICBcW1xtYXRoYmZ7Wn1faz1cbWF0aGJme1V9X2tcYm9sZHN5bWJvbHtcRGVsdGF9X2ssXF0gd2l0aCAkXGJvbGRzeW1ib2x7XERlbHRhfV9rPSBcbWF0aGJme1xEZWx0YX1fa157XHByaW1lIFxmcmFjezF9ezJ9fSQKCiMjIEV4YW1wbGUKCmBgYHtyfQpYIDwtIGFzLm1hdHJpeCh0KHVrWywtMV0pKQpuIDwtIG5yb3coWCkKSCA8LSBkaWFnKG4pIC0gbWF0cml4KDEvbixucm93PW4sbmNvbD1uKQpYIDwtIEglKiVYCnN2ZFVrIDwtIHN2ZChYKQoKayA8LSAyClVrIDwtIHN2ZFVrJHVbLDE6a10KRGsgPC0gZGlhZyhzdmRVayRkWzE6a10pClprIDwtIFVrJSolRGsKcm93bmFtZXMoWmspIDwtIGNvbG5hbWVzKHVrKVstMV0KY29sbmFtZXMoWmspIDwtIHBhc3RlMCgiWiIsMTprKQpaawoKWmsgJT4lCiAgYXMuZGF0YS5mcmFtZSAlPiUKICBnZ3Bsb3QoYWVzKHg9WjEseT1aMixsYWJlbD1yb3duYW1lcyhaaykpKSArCiAgZ2VvbV9wb2ludChzaXplID0gMykgKwogIGdlb21fdGV4dChudWRnZV94ID0gNTApCmBgYAoKLSBUaGUgZ3JhcGggc3VnZ2VzdHMgdGhhdCBXYWxlcyBhbmQgRW5nbGFuZCBhcmUgcXVpdGUgc2ltaWxhciBpbiB0ZXJtcyBvZiBmb29kIGNvbnN1bXB0aW9uLCBhbmQgTm9ydGggSXJlbGFuZCBzZWVtIHRvIGhhdmUgYSB2ZXJ5IGRpZmZlcmVudCBmb29kIGNvbnN1bXB0aW9uIHBhdHRlcm4uCgotIEFsc28gbm90ZSB0aGF0IEVuZ2xhbmQgaXMgY2xvc2UgdG8gdGhlIG9yaWdpbiwgbWVhbmluZyB0aGF0IHRoZSBmb29kIGNvbnN1bXB0aW9uIHBhdHRlcm4gaXMgY2xvc2UgdG8gdGhlIGF2ZXJhZ2UgcGF0dGVybiBpbiB0aGUgVUsuCgotIEEgZmV3IHF1ZXN0aW9ucyByZW1haW46CgogICAgLSBIb3cgd2VsbCBjYW4gdGhlIDE3LWRpbWVuc2lvbmFsIGRhdGEgYmUgcmVwcmVzZW50ZWQgaW4gYSAyLWRpbWVuc2lvbmFsIHN1YnNwYWNlPwogICAgLSBIb3cgY2FuIHdlIGludGVycHJldCB0aGUgZGlzdGFuY2VzIChkaWZmZXJlbmNlcykgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gdGVybXMgb2YgdGhlIG9yaWdpbmFsIDE3IHZhcmlhYmxlcz8KCiMjIFRoZSBiaXBsb3QKClRoZSBiaXBsb3QgaXMgYSBzaW5nbGUgMi1kaW1lbnNpb25hbCBncmFwaCB3aGljaCBkaXNwbGF5cyB0aGUgaW5mb3JtYXRpb24gaW4gYm90aCAkXG1hdGhiZntafV8yPVxtYXRoYmZ7VX1fMlxib2xkc3ltYm9se1xEZWx0YX1fMiQgYW5kICRcbWF0aGJme1Z9XzIkLgoKVGhlIHBsb3Qgb2YgJFxtYXRoYmZ7Wn1fMiQgaGFzIGJlZW4gZGlzY3Vzc2VkIHByZXZpb3VzbHkgKGUuZy4gYmVzdCBhcHByb3hpbWF0aW9uIG9mIGRpc3RhbmNlcykuCgpUaGUgbmFtZSAiYmkicGxvdCByZWZlcnMgdG8gdGhlIHBsb3R0aW5nIG9mIHR3byBwYXJ0cyBvZiB0aGUgU1ZEICgkXG1hdGhiZntafSQgYW5kICRcbWF0aGJme1Z9JCkgaW4gYSBzaW5nbGUgZ3JhcGguCgpGcm9tIHRoZSBnZW9tZXRyaWNhbCBpbnRlcnByZXRhdGlvbiBvZiB0aGUgU1ZEIHdlIGtub3cgdGhhdAokXG1hdGhiZntafV8yJCBpcyB0aGUgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG9mICRcbWF0aGJme1h9JCBvbiAkXG1hdGhiZntWfV8yJCB0aGUgYmFzaXMgc3Bhbm5lZCBieSB0aGUgZmlyc3QgdHdvIHNpbmd1bGFyIHZhbHVlcy4KVGh1cyBmb3IgdGhlICRpXlx0ZXh0e3RofSQgaW5kaXZpZHVhbCB3ZSBnZXQKXFsKXG1hdGhiZnt6fV97MixpfT0gXG1hdGhiZnt4fV9pIFxsZWZ0W1xiZWdpbnthcnJheX17Y2N9XG1hdGhiZnt2fV8xJlxtYXRoYmZ7dn1fMlxlbmR7YXJyYXl9XHJpZ2h0XQpcXQoKV2UgYWxzbyBrbm93IHRoYXQgd2UgY2FuIGFwcHJveGltYXRlICRcbWF0aGJme1h9JCBieSAkXG1hdGhiZntYfV8yJCB3aGljaCBlcXVhbHM6CgpcYmVnaW57YWxpZ259CiAgXG1hdGhiZntYfV8yICY9IFxtYXRoYmZ7Wl8yfVxtYXRoYmZ7Vn1fMl5UXFwKICAmPSBcbWF0aGJme1pfMn1cbGVmdFtcYmVnaW57YXJyYXl9e2N9IFxtYXRoYmZ7dn1fMV5UXFwKICAgICAgXG1hdGhiZnt2fV8yXlRcZW5ke2FycmF5fVxyaWdodF0KICA9IFxtYXRoYmZ7Wl8yfQogICAgXGxlZnRbCiAgICAgIFxiZWdpbnthcnJheX17Y2NjfVx0aWxkZXtcbWF0aGJme3Z9fV97MiwxfSBcbGRvdHMgXHRpbGRle1xtYXRoYmZ7dn19X3syLHB9XGVuZHthcnJheX0KICAgIFxyaWdodF0KXGVuZHthbGlnbn0KCndpdGggJFxtYXRoYmZ7dn1fMSQgYW5kICRcbWF0aGJme3Z9XzIkIHRoZSBmaXJzdCB0d28gcmlnaHQgc2luZ3VsYXIgdmVjdG9yIGFuZCAkXHRpbGRle1xtYXRoYmZ7dn19X2okIHRoZSBqJF5cdGV4dHt0aH0kIGNvbHVtbiBvZiB0aGUgbWF0cml4ICRcbWF0aGJme1Z9XzJeVCQuCgotIFRoaXMgYmFzaWNhbGx5IHNob3dzIHVzIHRoYXQgdGhlIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBvZiAkXG1hdGhiZnt6fV97MixpfSQgZm9yIHN1YmplY3QvZXhwZXJpbWVudGFsIHVuaXQgaSBvbiAkXHRpbGRle1xtYXRoYmZ7dn19X3syLGp9JCBnaXZlcyB1cyB0aGUgYXBwcm94aW1hdGlvbiBvZiB0aGUgdmFsdWUgZm9yICBqJF5cdGV4dHt0aH0kIHZhcmlhYmxlIHRoYXQgd2FzIG9ic2VydmVkIGZvciB0aGUgJGleXHRleHR7dGh9JCBleHBlcmltZW50YWwgdW5pdCwgaS5lLiAkeF97Mixpan0kLgpcW3hfezIsaWp9PVxtYXRoYmZ7en1fezIsaX1eVFx0aWxkZXtcbWF0aGJme3Z9fV97MixqfVxdCgojIyMgVUsgIGV4YW1wbGUKCiMjIyMgQmlwbG90CgpgYGB7cn0KVmsgPC0gc3ZkVWskdlssMTprXQpyb3duYW1lcyhWaykgPC0gdWtbWzFdXQpjb2xuYW1lcyhWaykgPC0gY29sbmFtZXMoWmspCnNjYWxlRmFjdG9yIDwtIG1lYW4oc3ZkVWskZFsxOmtdKQoKZGl5QmlwbG90IDwtIGdncGxvdCgpICsKICBnZW9tX3BvaW50KAogICAgZGF0YT1aayAlPiUgYXMuZGF0YS5mcmFtZSwKICAgIGFlcyh4PVoxLHk9WjIpLAogICAgc2l6ZSA9IDMpICsKICBnZW9tX3RleHQoCiAgICBkYXRhPVprICU+JSBhcy5kYXRhLmZyYW1lLAogICAgYWVzKHg9WjEseT1aMixsYWJlbD1yb3duYW1lcyhaaykpLAogICAgbnVkZ2VfeCA9IDUwKSArCiAgZ2VvbV9zZWdtZW50KAogICAgZGF0YT1WayAlPiUgYXMuZGF0YS5mcmFtZSwKICAgIGFlcyh4PTAsIHk9MCwgeGVuZD1aMSpzY2FsZUZhY3RvciwgeWVuZD1aMipzY2FsZUZhY3RvciksCiAgICBhcnJvdz1hcnJvdyhsZW5ndGg9dW5pdCgwLjQsImNtIikpLAogICAgYWxwaGE9MC4yNSkgKwogIGdlb21fdGV4dCgKICAgIGRhdGE9VmsgJT4lIGFzLmRhdGEuZnJhbWUsCiAgICBhZXMoeD1aMSpzY2FsZUZhY3RvciwgeT1aMipzY2FsZUZhY3RvciwgbGFiZWw9cm93bmFtZXMoVmspKSwKICAgIGFscGhhPTAuNSwKICAgIHNpemU9MykKCmRpeUJpcGxvdAoKYmlwbG90KFprLFZrKQpgYGAKClRoZSBSIGNvZGUgc2hvd3MgdHdvIHdheXMgb2YgY29uc3RydWN0aW5nIGEgYmlwbG90OiB0aGUgZmlyc3QgbWV0aG9kIHN0YXJ0cyBmcm9tIHRoZSBTVkQgb2YgJFxtYXRoYmZ7WH0kIGFuZCBwbG90cyB0aGUgcCB2ZWN0b3JzICRcdGlsZGV7XG1hdGhiZnt2fX1fezIsan0kIGFzIGFycm93cy4gTm90ZSB0aGF0IHdlIHVzZWQgYSBzY2FsaW5nIGZhY3RvciB0byBnaXZlIHRoZSBhcnJvd3MgYSBjb252ZW5pZW50IGxlbmd0aCBpbiB0aGUgZ3JhcGggKG5vdCB0b28gc21hbGwsIG5vdCB0b28gbGFyZ2UpOyBpdCBkb2VzIG5vdCBhZmZlY3QgdGhlIGludGVycHJldGF0aW9uLiBUaGUgc2Vjb25kIHdheSBvZiBvYnRhaW5pbmcgdGhlIGJpcGxvdCBpcyBzaW1wbHkgYnkgdXNpbmcgdGhlIFIgYnVpbHQtaW4gZnVuY3Rpb24gYmlwbG90LgoKIyMjIyBJbGx1c3RyYXRpb24gb2YgcHJvamVjdGlvbgoKV2UgcHJvamVjdCAkXG1hdGhiZnt6fV97MixpfSQgZm9yIE4uSXJlbGFuZCBvbiBGcmVzaF9wb3RhdG9lcy4KCmBgYHtyIGVjaG89RkFMU0V9CmdncGxvdCgpICsKICBnZW9tX3BvaW50KAogICAgZGF0YT1aayAlPiUgYXMuZGF0YS5mcmFtZSwKICAgIGFlcyh4PVoxLHk9WjIpLAogICAgc2l6ZSA9IDMpICsKICBnZW9tX3RleHQoCiAgICBkYXRhPVprICU+JSBhcy5kYXRhLmZyYW1lLAogICAgYWVzKHg9WjEseT1aMixsYWJlbD1yb3duYW1lcyhaaykpLAogICAgbnVkZ2VfeCA9IDUwKSArCiAgZ2VvbV9zZWdtZW50KAogICAgZGF0YT1yYmluZChWa1siRnJlc2hfcG90YXRvZXMiLF0qc2NhbGVGYWN0b3IsWmtbIk4uSXJlbGFuZCIsXSkgJT4lIGFzLmRhdGEuZnJhbWUsCiAgICBhZXMoeD0wLCB5PTAsIHhlbmQ9WjEsIHllbmQ9WjIpLAogICAgYXJyb3c9YXJyb3cobGVuZ3RoPXVuaXQoMC40LCJjbSIpKSwKICAgIGFscGhhPTAuMjUpICsKICAgIGdlb21fc2VnbWVudCgKICAgICAgYWVzKHg9WmtbIk4uSXJlbGFuZCIsMV0sCiAgICAgICAgeT1aa1siTi5JcmVsYW5kIiwyXSwKICAgICAgICB4ZW5kPVZrWyJGcmVzaF9wb3RhdG9lcyIsXSUqJVprWyJOLklyZWxhbmQiLF0qVmtbIkZyZXNoX3BvdGF0b2VzIiwxXSwKICAgICAgICB5ZW5kPVZrWyJGcmVzaF9wb3RhdG9lcyIsXSUqJVprWyJOLklyZWxhbmQiLF0qVmtbIkZyZXNoX3BvdGF0b2VzIiwyXQogICAgICAgICksCiAgICAgICAgbHR5PTIpICsKICAgIGdlb21fdGV4dCgKICAgICAgYWVzKHg9VmtbIkZyZXNoX3BvdGF0b2VzIiwxXSpzY2FsZUZhY3RvciwgeT1Wa1siRnJlc2hfcG90YXRvZXMiLDJdKnNjYWxlRmFjdG9yLCBsYWJlbD0iRnJlc2hfcG90YXRvZXMiKSwKICAgICAgYWxwaGE9MC41LAogICAgICBzaXplPTMpCmBgYAoKCmBgYHtyfQpyb3duYW1lcyhYKSA8LSByb3duYW1lcyhaaykKY29sbmFtZXMoWCkgPC0gcm93bmFtZXMoVmspClhbLCJGcmVzaF9wb3RhdG9lcyJdClprWyJOLklyZWxhbmQiLF0lKiVWa1siRnJlc2hfcG90YXRvZXMiLF0KYGBgCgpXZSBvYnNlcnZlIHRoYXQgTi4gSXJlbGFuZCBoYXMgYSBjb25zdW1wdGlvbiBpbiBGcmVzaF9wb3RhdG9lcyB0aGF0IGlzIGByIFhbIk4uSXJlbGFuZCIsIkZyZXNoX3BvdGF0b2VzIl1gIGFib3ZlIHRoZSBhdmVyYWdlIGFuZCB0aGlzIGlzIHdlbGwgYXBwcm94aW1hdGVkIGJ5IHRoZSBwcm9qZWN0aW9uIGByIHJvdW5kKFprWyJOLklyZWxhbmQiLF0lKiVWa1siRnJlc2hfcG90YXRvZXMiLF0sMikKYC4KCkFsc28gbm90ZSB0aGF0CgotIFRoZSBvcmlnaW4gY29ycmVzcG9uZHMgdG8gdGhlIHNhbXBsZSBhdmVyYWdlIG9mIHRoZSAxNy1kaW1lbnNpb25hbCBvYnNlcnZhdGlvbnMgaW4gdGhlIGRhdGEgbWF0cml4CgotIEVuZ2xhbmQgaXMgY2xvc2UgdG8gdGhlIG9yaWdpbiBhbmQgdGh1cyBvbmUgY291bGQgc2F5IHRoYXQgdGhlIGZvb2QgY29uc3VtcHRpb24gaW4gRW5nbGFuZCBpcyBhcyB0aGUgYXZlcmFnZSBpbiB0aGUgVUsKCi0gUHJvamVjdGluZyB0aGUgJFxtYXRoYmZ7Wn1fMiQgY29vcmRpbmF0ZXMgZm9yIE5vcnRoIElyZWxhbmQgb3J0aG9nb25hbGx5IG9udG8gdGhlIHZlY3RvciAkXHRpbGRle1xtYXRoYmZ7dn19X3syLGp9JCBvZiBmcmVzaCBwb3RhdG9lcywgd2UgZ2V0IGEgbGFyZ2UgYW5kIHBvc2l0aXZlICR4X3syLGlqfSQuIEhlbmNlLCBwZW9wbGUgaW4gTi4gSXJlbGFuZCB0ZW5kIHRvIGVhdCBtb3JlIGZyZXNoIHBvdGF0b2VzIHRoYW4gb24gYXZlcmFnZSBpbiB0aGUgVUsuCgotIFdlIGNhbiBkbyB0aGUgc2FtZSBmb3IgdGhlIG90aGVyIHZlY3RvcnMuCgojIyMgRnVydGhlciBpbnRlcnByZXRhdGlvbiBvZiB0aGUgQmlwbG90CgpGcm9tICRcbWF0aGJme3h9X3trLGl9XlQgPSAgXG1hdGhiZnt6fV97ayxpfV5UXG1hdGhiZntWfV9rXlQkIHdlIGxlYXJudCB0aGF0IHRoZSBvcmlnaW5hbCBkYXRhIGNhbiBiZSAoYXBwcm94aW1hdGVseSkgcmVjb25zdHJ1Y3RlZCBmcm9tIHRoZSAkXG1hdGhiZnt6fV97ayxpfSQuCgogV2Ugbm93IHNob3cgaG93IHRoZSBkaW1lbnNpb25zIG9mICRcbWF0aGJme1p9X2skIChjb2x1bW5zIG9yIHZhcmlhYmxlcykgY2FuIGJlIGludGVycHJldGVkLiBSZW1lbWJlciwKIFxbCiAgXG1hdGhiZnt6fV97ayxpfV5UID0gXG1hdGhiZnt4fV9pXlRcbWF0aGJme1Z9X2sgPSBcbGVmdChcbWF0aGJme3h9X2leVCBcbWF0aGJme3Z9XzEgLCBcbWF0aGJme3h9X2leVCBcbWF0aGJme3Z9XzIgLCBcbGRvdHMgLCBcbWF0aGJme3h9X2leVCBcbWF0aGJme3Z9X2tccmlnaHQpLgogXF0KCiBUaGUgJGokdGggY29sdW1uIG9mICRcbWF0aGJme1p9X2skIGNhbiBiZSB3cml0dGVuIGFzCiBcWwogICBcbWF0aGJme3p9X3trLGp9ID0gXG1hdGhiZntYfVxtYXRoYmZ7dn1faiwKIFxdCgogQW4gaW5kaXZpZHVhbCBlbGVtZW50IG9mICRcbWF0aGJme1p9X2skIGNhbiBiZSB3cml0dGVuIGFzCiBcWwogICB6X3trLGlqfSA9IFxtYXRoYmZ7eH1faV5UXG1hdGhiZnt2fV9qLAogXF0KCiB3aGljaCBpcyBhIGxpbmVhciBjb21iaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YXRpb25zIG9uIHRoZSAkcCQgdmFyaWFibGVzIGluICRcbWF0aGJme3h9X2kkLCB3aXRoIGNvZWZmaWNpZW50cyBnaXZlbiBieSB0aGUgJHAkIGVsZW1lbnRzIGluICRcbWF0aGJme3Z9X2okLiBVbmRlcnN0YW5kaW5nIHRoZSBlbGVtZW50cyBpbiAkXG1hdGhiZnt2fV9qJCB3aWxsIGdpdmUgdXMgaW5zaWdodCBpbnRvIHRoZSBpbnRlcnByZXRhdGlvbiBvZiB0aGUgJGokdGggZGltZW5zaW9uIG9mICRcbWF0aGJme1p9X2skLgoKIyMgSWxsdXN0cmF0aW9uIFVrIGZvb2QKCmBgYHtyfQpwMSA8LSBnZ3Bsb3QoKSArCiAgZ2VvbV9iYXIoCiAgICBhZXMoIHg9cm93bmFtZXMoVmspLCB5PVZrWywxXSksCiAgICBzdGF0PSJpZGVudGl0eSIpICsKICB4bGFiKCJWMSIpICsKICB5bGFiKCJjb250cmlidXRpb24iKSArCiAgY29vcmRfZmxpcCgpCgpwMiA8LQpnZ3Bsb3QoKSArCiAgZ2VvbV9iYXIoCiAgICBhZXMoIHg9cm93bmFtZXMoVmspLCB5PVZrWywyXSksCiAgICBzdGF0PSJpZGVudGl0eSIpICsKICB4bGFiKCJWMiIpICsKICB5bGFiKCJjb250cmlidXRpb24iKSArCiAgY29vcmRfZmxpcCgpCgpncmlkLmFycmFuZ2UocDEscDIsbmNvbD0yKQpgYGAKCkluIGdpdmluZyBhbiBpbnRlcnByZXRhdGlvbiB0byB0aGUgZWxlbWVudHMgaW4gJFxtYXRoYmZ7dn1fMSQgYW5kICRcbWF0aGJme3Z9XzIkLCB3ZSBpZ25vcmUgdGhlIGVsZW1lbnRzIGNsb3NlIHRvIHplcm8gKHRoaXMgaXMgYSBzdWJqZWN0aXZlIGRlY2lzaW9uOyBsYXRlciB3ZSBzZWUgbW9yZSBvYmplY3RpdmUgbWV0aG9kcykuCgpGb3IgJFxtYXRoYmZ7dn1fMSQgKDFzdCBkaW1lbnNpb24gb2YgJFxtYXRoYmZ7Wn1fMiQpOgoKLSBjb250cmFzdCBvZiBzb2Z0IGRyaW5rcyBhbmQgZnJlc2ggcG90YXRvZXMgdmVyc3VzIGZyZXNoIGZydWl0IGFuZCBhbGNvaG9saWMgZHJpbmtzCgotIGEgbGFyZ2UgdmFsdWUgb2YgJHpfe2kxfSQgY2FuIHJlc3VsdCBmcm9tIGVhdGluZyBtYW55IGZyZXNoIHBvdGF0b2VzIGFuZCBkcmlua2luZyBhIGxvdCBvZiBzb2Z0IGRyaW5rcywgYnV0IGVhdGluZyBvbmx5IGZldyBmcmVzaCBmcnVpdCBhbmQgZHJpbmtpbmcgbm90IG11Y2ggYWxjb2hvbGljIGRyaW5rcwoKLSBhIHNtYWxsIHZhbHVlIG9mICR6X3tpMX0kIGNhbiByZXN1bHQgZnJvbSBlYXRpbmcgZmV3IGZyZXNoIHBvdGF0b2VzIGFuZCBkcmlua2luZyBvbmx5IGZldyBzb2Z0IGRyaW5rcywgYnV0IGVhdGluZyBhIGxvdCBvZiBmcmVzaCBmcnVpdCBhbmQgZHJpbmtpbmcgbXVjaCBhbGNvaG9saWMgZHJpbmtzCgpGb3IgJFxtYXRoYmZ7dn1fMiQgKDJuZCBkaW1lbnNpb24gb2YgJFxtYXRoYmZ7Wn1fMiQpOgoKLSBjb250cmFzdCBvZiBzb2Z0IGRyaW5rcyB2ZXJzdXMgZnJlc2ggcG90YXRvZXMKCi0gYSBsYXJnZSB2YWx1ZSBvZiAkel97aTJ9JCBjYW4gcmVzdWx0IGZyb20gZWF0aW5nIG1hbnkgZnJlc2ggcG90YXRvZXMsIGJ1dCBkcmlua2luZyBub3QgbXVjaCBzb2Z0IGRyaW5rcwoKLSBhIHNtYWxsIHZhbHVlIG9mICR6X3tpMn0kIGNhbiByZXN1bHQgZnJvbSBlYXRpbmcgZmV3IGZyZXNoIHBvdGF0b2VzLCBidXQgZHJpbmtpbmcgbXVjaCBzb2Z0IGRyaW5rcyAuCgotLS0KClRoZSBlbGVtZW50cyBpbiB2MSBhbmQgdjIgYXJlIGFsc28gc2hvd24gaW4gdGhlIGJpcGxvdC4KCmBgYHtyfQpncmlkLmFycmFuZ2UocDEsIHAyLCBkaXlCaXBsb3QsIG5jb2w9MiwgbGF5b3V0X21hdHJpeCA9IHJiaW5kKGMoMSwyKSxjKDMsMykpKQpgYGAKCkZyb20gdGhlIGdyYXBoIHdlIHNlZSBlLmcuIHRoYXQgTi4gSXJlbGFuZCBoYXMgYSBoaWdoIHNjb3JlIGZvciB0aGUgZmlyc3QgZGltZW5zaW9uLiBOb3cgdGhhdCB3ZSBjYW4gZ2l2ZSBhbiBpbnRlcnByZXRhdGlvbiB0byB0aGUgZGltZW5zaW9uLCB3ZSBjb25jbHVkZSB0aGF0IGluIE5vcnRoZXJuIElyZWxhbmQgcGVvcGxlIGVhdCByZWxhdGl2ZWx5IG11Y2ggZnJlc2ggcG90YXRvZXMgYW5kIGRyaW5rIG1hbnkgc29mdCBkcmlua3MsIGJ1dCB0aGV5IGRvIG5vdCBkcmluayBtdWNoIGFsY29ob2xpYyBkcmlua3MgYW5kIGVhdCBub3QgbXVjaCBmcmVzaCBmcnVpdC4gV2UgaGFkIGFscmVhZHkgY29tZSB0byB0aGVzZSBmaW5kaW5ncyBieSBwcm9qZWN0aW5nIE4uIElyZWxhbmQgb24gdGhlIHZlY3RvcnMgb2YgdGhlc2UgZm91ciBmb29kIHByb2R1Y3RzLiBUaGlzIGNvbWVzIHRvIG5vIHN1cnByaXNlOiBib3RoIGludGVycHJldGF0aW9ucyBhcmlzZSBmcm9tIHRoZSBzYW1lIGRhdGEgc2V0IGFuZCBpdHMgU1ZELCBhbmQgc28gbm8gY29udHJhZGljdG9yeSByZXN1bHRzIHNob3VsZCBhcmlzZS4gT3RoZXIgY29uY2x1c2lvbnMgY2FuIGJlIGZvdW5kIGluIGEgc2ltaWxhciBmYXNoaW9uLgoKV2UgaGF2ZSBkZXJpdmVkIHRoZSBpbnRlcnByZXRhdGlvbiBvZiB0aGUgZmlyc3QgZGltZW5zaW9uIGZyb20gdGhlIGJhcnBsb3Qgb2YgdGhlIGVsZW1lbnRzIG9mICRcbWF0aGJme3Z9XzEkLiBIb3dldmVyLCB0aGVyZSBpcyBhY3R1YWxseSBubyBuZWVkIHRvIG1ha2UgYSBzZXBhcmF0ZSBwbG90IHRvIHJlYWQgdGhlIGVsZW1lbnRzIG9mICRcbWF0aGJme3Z9XzEkOyB0aGV5IGNhbiBhbHNvIGJlIHJlYWQgZnJvbSBwcm9qZWN0aW5nIHRoZSB2ZWN0b3JzIGluIHRoZSBiaXBsb3Qgb250byB0aGUgZmlyc3QgZGltZW5zaW9uIChpLmUuIGJhc2lzIHZlY3RvciBvZiB0aGUgZmlyc3QgZGltZW5zaW9uKS4gRm9yIGV4YW1wbGUsIGZyZXNoIHBvdGF0b2VzIGlzIGluIHRoZSA3dGggY29sdW1uIG9mICRcbWF0aGJme1h9JCBhbmQgdGh1cyBpbiB0aGUgYmlwbG90IGl0cyB2ZWN0b3IgaXMgJFx0aWxkZXtcbWF0aGJme3Z9fV97Miw3fSQ7IGl0IGlzIGEgMi1kaW1lbnNpb25hbCB2ZWN0b3IgKDItZGltZW5zaW9uYWwgYmlwbG90IGlzIHNob3duKS4gSW4gdGhlIHNwYWNlIG9mIHRoZSBiaXBsb3QgKGkuZS4gdGhlIGNvbHVtbiBzcGFjZSBvZiAkXG1hdGhiZntafV8yJCksIHRoZSBmaXJzdCBiYXNpcyB2ZWN0b3IgaXMgZ2l2ZW4gYnkgJCgxLDApJC4gUHJvamVjdGluZyAgJFx0aWxkZXtcbWF0aGJme3Z9fV97Miw3fV5UJCBvcnRob2dvbmFsbHkgb250byAkKDEsMCkkIGdpdmVzClxbCiAgXHRpbGRle1xtYXRoYmZ7dn19X3syLDd9XlQgIFxiZWdpbntwbWF0cml4fSAxIFxcIDAgXGVuZHtwbWF0cml4fSA9ICh2X3s3MX0gLCB2X3s3Mn0pIFxiZWdpbntwbWF0cml4fSAxIFxcIDAgXGVuZHtwbWF0cml4fSA9IHZfezcxfQpcXQp3aGljaCBpcyB0aGUgc2V2ZW50aCBlbGVtZW50IG9mIHRoZSBmaXJzdCByaWdodC1zaW5ndWxhciB2ZWN0b3Igb2YgJFxtYXRoYmZ7WH0kLCB3aGljaCBpcyB0aHVzIHRoZSBiYXIgb2YgZnJlc2ggcG90YXRvZXMgaW4gdGhlIGJhcnBsb3Qgb2YgdGhlIGZpcnN0IGRpbWVuc2lvbi4KCiMgU1ZEIGFuZCBwcmluY2lwYWwgY29tcG9uZW50IGFuYWx5c2lzIChQQ0EpCgotIFBDQSBpcyBiYXNpY2FsbHkgYSBTVkQKCi0gUENBIGFkZHMgYW5vdGhlciBsYXllciBvZiBpbnRlcnByZXRhdGlvbgoKLSBQQ0EgY29tZXMgd2l0aCBpdHMgb3duIHRlcm1pbm9sb2d5CgotIE9uZSBvZiB0aGUgbW9zdCB3aWRlbHkgdXNlZCBhbGdvcml0aG1zIGZvciBkaW1lbnNpb24gcmVkdWN0aW9uIGFuZCBkYXRhIGV4cGxvcmF0aW9uIG9mIG11bHRpdmFyaWF0ZSBhbmQgaGlnaCBkaW1lbnNpb25hbCBkYXRhLgoKLSBJdCBpcyBtb3RpdmF0ZWQgZnJvbSB0aGUgZGVjb21wb3NpdGlvbiBvZiB0aGUgVmFyaWFuY2UgY292YXJpYW5jZSBtYXRyaXggb2YgdGhlIGRhdGEKCiMjIFZhcmlhbmNlIGNvdmFyaWFuY2UgbWF0cml4CgotICAgRm9yIGEgZ2l2ZW4gY2VudGVyZWQgZGF0YSBtYXRyaXggJFxtYXRoYmZ7WH0kIHRoZSAkcFx0aW1lcyBwJCBjb3ZhcmlhbmNlIG1hdHJpeCBjYW4gYmUgZXN0aW1hdGVkIGJ5CiAgXFsKICAgIFxib2xkc3ltYm9se1xTaWdtYX1fWCA9IFxmcmFjezF9e24tMX1cbWF0aGJme1h9XlRcbWF0aGJme1h9ID1cZnJhY3sxfXtuLTF9XHN1bV97aT0xfV5uIFxtYXRoYmZ7eH1faVxtYXRoYmZ7eH1faV5ULAogIFxdCiAgaS5lLiB0aGUgJChpLGopJHRoIGVsZW1lbnQgaXMgZ2l2ZW4gYnkgKGNvbHVtbiBtZWFucyBhcmUgemVybykKICBcWwogICAgXGZyYWN7MX17bi0xfVxzdW1fe209MX1ebiB4X3ttaX14X3ttan09XGZyYWN7MX17bi0xfVxzdW1fe209MX1ebiAoeF97bWl9LVxiYXJ7eH1faSkoeF97bWp9LVxiYXJ7eH1faikuCiAgXF0KCk5vdGUsIHRoYXQgd2hlbiB3ZSBmb3JnZXQgdG8gd3JpdGUgdGhlIGZhY3RvciAkMS8obi0xKSQgYWxsIHRoZSBkZXJpdmF0aW9ucyBzdGlsbCBob2xkLiBJdCBpcyBvbmx5IGEgcHJvcG9ydGlvbmFsaXR5IGZhY3RvciBhbmQgaXQgZG9lcyBub3QgYWZmZWN0IHRoZSBpbnRlcnByZXRhdGlvbi4KCi0tLQoKIyMgQ29udmVudGlvbmFsIGRlcml2YXRpb24gb2YgUENBCgpQQ0EgaXMgdXN1YWxseSBpbnRyb2R1Y2VkIGFzIGZvbGxvd3MuCgpMZXQKXFsKICB5X2k9XG1hdGhiZnt4fV9pXlRcbWF0aGJme2F9ClxdCndpdGggJFxtYXRoYmZ7YX0kIGEgJHAkLXZlY3RvciBvZiBjb25zdGFudHMuIEhlbmNlICR5X2kkIGlzIGEgbGluZWFyIGNvbWJpbmF0aW9uIChvciB0cmFuc2Zvcm1hdGlvbikgb2YgJFxtYXRoYmZ7eH1faSQuCgpQQ0EgYWltcyBhdCBmaW5kaW5nICRcbWF0aGJme2F9JCBzdWNoIHRoYXQgdGhlIHNhbXBsZSB2YXJpYW5jZSBhbW9uZyB0aGUgJG4kICR5X2kkJ3MgaXMgbWF4aW1hbCwgd2l0aApcYmVnaW57ZXFuYXJyYXkqfQogIFxmcmFjezF9e24tMX1cc3VtX3tpPTF9Xm4gKHlfaSAtIFxiYXJ7eX0pXjIgPSAgXGZyYWN7MX17bi0xfVxzdW1fe2k9MX1ebiB5X2kgXjIgXFwKICAgICY9JiBcZnJhY3sxfXtuLTF9XHN1bV97aT0xfV5uIChcbWF0aGJme3h9X2leVFxtYXRoYmZ7YX0pXjIgPSBcZnJhY3sxfXtuLTF9IFxtYXRoYmZ7YX1eVCBcbGVmdChcc3VtX3tpPTF9Xm4gXG1hdGhiZnt4fV9pXG1hdGhiZnt4fV9pXlRccmlnaHQpIFxtYXRoYmZ7YX0gXFwKICAgICY9JiBcZnJhY3sxfXtuLTF9IFxtYXRoYmZ7YX1eVFxtYXRoYmZ7WH1eVFxtYXRoYmZ7WH1cbWF0aGJme2F9ID0gXG1hdGhiZnthfV5UXGJvbGRzeW1ib2x7XFNpZ21hfV9YXG1hdGhiZnthfQpcZW5ke2VxbmFycmF5Kn0KaW4gd2hpY2ggJFxib2xkc3ltYm9se1xTaWdtYX1fWD0gXGZyYWN7MX17bi0xfVxtYXRoYmZ7WH1eVFxtYXRoYmZ7WH0kIGlzIHRoZSBzYW1wbGUgY292YXJpYW5jZSBtYXRyaXggb2YgJFxtYXRoYmZ7WH0kLgoKIyMjIFByb2JsZW0gZm9yIG9wdGltaXNhdGlvbgoKRmluZGluZyAkXG1hdGhiZnthfSQgdGhhdCBtYXhpbWlzZXMKXFsKICBcdGV4dHt2YXJ9W3ldICA9IFxtYXRoYmZ7YX1eVFxib2xkc3ltYm9se1xTaWdtYX1fWFxtYXRoYmZ7YX0KXF0KaGFzIGEgdHJpdmlhbCBzb2x1dGlvbiAoc2V0IGFsbCBlbGVtZW50cyBvZiAkXG1hdGhiZnthfSQgZXF1YWwgdG8gJFxpbmZ0eSQpLiBUbyBhdm9pZCB0aGUgdHJpdmlhbCBzb2x1dGlvbiwgdGhlIHNvbHV0aW9uIG11c3Qgc2F0aXNmeSBhIHJlc3RyaWN0aW9uLCBlLmcuClxbCiAgXFZlcnQgXG1hdGhiZnthfVxWZXJ0XjIgPSBcbWF0aGJme2F9XlRcbWF0aGJme2F9PTEuClxdCgpUaGUgc29sdXRpb24gb2YgdGhlIGNvbnN0cmFpbmVkIG1heGltaXNhdGlvbiBwcm9ibGVtIG1heSBiZSBmb3JtdWxhdGVkIGFzClxbCiAgXG1hdGhiZnthfSA9IFx0ZXh0e0FyZ01heH1fe2I6XFZlcnQgYlxWZXJ0XjI9MX0gXG1hdGhiZntifV5UXGJvbGRzeW1ib2x7XFNpZ21hfV9YXG1hdGhiZntifS4KXF0KQnkgaW50cm9kdWNpbmcgYSBMYWdyYW5nZSBtdWx0aXBsaWVyICRcbGFtYmRhJCwgd2UgZ2V0IGFuIHVuY29uc3RyYWluZWQgbWF4aW1pc2F0aW9uIHByb2JsZW0sClxbCiAgXG1hdGhiZnthfSA9IFx0ZXh0e0FyZ01heH1fe2J9IFxsZWZ0KFxtYXRoYmZ7Yn1eVFxib2xkc3ltYm9se1xTaWdtYX1fWFxtYXRoYmZ7Yn0tXGxhbWJkYShcbWF0aGJme2J9XlRcbWF0aGJme2J9LTEpXHJpZ2h0KS4KXF0KCi0tLQoKTm90ZSB0aGF0LAoKLSBJZiB0aGUgY29uc3RyYWludCBpcyBsaW5lYXIsIHRoZW4gdGhlIGNvbnN0cmFpbmVkIG9wdGltaXNhdGlvbiBwcm9ibGVtIChoZXJlOiBtYXhpbWlzYXRpb24pIG1heSBiZSByZXBsYWNlZCBieSBhbiB1bmNvbnN0cmFpbmVkIG9wdGltaXNhdGlvbiBwcm9ibGVtIG9mIHRoZSBzYW1lIGNyaXRlcmlvbiBidXQgd2l0aCBhbiBgYHBlbmFsdHkgdGVybScnIGFkZGVkLiBUaGlzIG1ldGhvZCBpcyBkdWUgdG8gTGFncmFuZ2UuIFRoZSBwZW5hbHR5IHRlcm0gdmFuaXNoZXMgd2hlbiB0aGUgY29uc3RyYWludCBpcyBzYXRpc2ZpZWQuCgotIElmIHRoZSBjb25zdHJhaW50IGlzIHNhdGlzZmllZCwgJFxtYXRoYmZ7Yn1eVFxtYXRoYmZ7Yn09XFZlcnQgXG1hdGhiZntifVxWZXJ0XjI9MSQgYW5kIHRodXMgJFxtYXRoYmZ7Yn1eVFxtYXRoYmZ7Yn0tMT0wJCBhbmQgdGhlIGBgcGVuYWx0eScnIHRlcm0gaW4gdGhlIHVuY29uc3RyYWluZWQgY3JpdGVyaW9uIHZhbmlzaGVzLgoKLSBUaGUgTGFncmFuZ2UgbXVsdGlwbGllciAkXGxhbWJkYSQgaXMgdG8gYmUgY29uc2lkZXJlZCBhcyBhbiBleHRyYSBwYXJhbWV0ZXIgdGhhdCBtYXkgaGF2ZSB0byBiZSBlc3RpbWF0ZWQgZnJvbSB0aGUgZGF0YS4KCi0tLQoKVGhlIHNvbHV0aW9uIG9mClxbCiAgXG1hdGhiZnthfSA9IFx0ZXh0e0FyZ01heH1fe2J9IFxsZWZ0KFxtYXRoYmZ7Yn1eVFxib2xkc3ltYm9se1xTaWdtYX1fWFxtYXRoYmZ7Yn0tXGxhbWJkYShcbWF0aGJme2J9XlRcbWF0aGJme2J9LTEpXHJpZ2h0KQpcXQppcyBvYnRhaW5lZCBieSBkaWZmZXJlbnRpYXRpbmcgJFxtYXRoYmZ7Yn1eVFxib2xkc3ltYm9se1xTaWdtYX1fWFxtYXRoYmZ7Yn0tXGxhbWJkYShcbWF0aGJme2J9XlRcbWF0aGJme2J9LTEpJCB3LnIudC4gJFxtYXRoYmZ7Yn0kLCBlcXVhdGluZyBpdCB0byB6ZXJvIGFuZCBzb2x2aW5nIGZvciAkXG1hdGhiZntifSQuClxiZWdpbntlcW5hcnJheSp9CiBcZnJhY3tccGFydGlhbH17XHBhcnRpYWwgXG1hdGhiZntifX0gXGxlZnQoXG1hdGhiZntifV5UXGJvbGRzeW1ib2x7XFNpZ21hfV9YXG1hdGhiZntifS1cbGFtYmRhKFxtYXRoYmZ7Yn1eVFxtYXRoYmZ7Yn0tMSlccmlnaHQpCiAgICAmPSYgMCBcXAogICAgMlxib2xkc3ltYm9se1xTaWdtYX1fWFxtYXRoYmZ7Yn0gLTJcbGFtYmRhXG1hdGhiZntifQogICAgJj0mIDAuClxlbmR7ZXFuYXJyYXkqfQoKSGVuY2UsIHdlIG5lZWQgdGhlIHNvbHV0aW9uIG9mClxbCiAgXGJvbGRzeW1ib2x7XFNpZ21hfV9YXG1hdGhiZntifSA9IFxsYW1iZGFcbWF0aGJme2J9LgpcXQoKVGhpcyBlcXVhdGlvbiBoYXMgJHIkIHNvbHV0aW9uczoKCi0gICRcbWF0aGJme2J9PVxtYXRoYmZ7ZX1faiQ6IHRoZSAkaiR0aCBlaWdlbnZlY3RvciBvZiAkXGJvbGRzeW1ib2x7XFNpZ21hfV9YJAoKLSAgJFxsYW1iZGE9XGxhbWJkYV9qJDogdGhlICRqJHRoIGVpZ2VudmFsdWUgb2YgJFxib2xkc3ltYm9se1xTaWdtYX1fWCQuCgpUaGUgZWlnZW52ZWN0b3JzIGFyZSBvcnRob25vcm1hbCwgaS5lLgokXG1hdGhiZntlfV9pXlRcbWF0aGJme2V9X2o9MSQgaWYgJGk9aiQgYW5kICRcbWF0aGJme2V9X2leVFxtYXRoYmZ7ZX1faj0wJCBvdGhlcndpc2UuCgotLS0KCkNvbnNpZGVyIHRoZSBmb2xsb3dpbmcgY2FsY3VsYXRpb25zLCB3aXRoICRcbWF0aGJme2J9PVxtYXRoYmZ7ZX1faiQsIHRoZSAkaiR0aGUgZWlnZW52ZWN0b3Igb2YgJFxib2xkc3ltYm9se1xTaWdtYX1fWCQuClxiZWdpbntlcW5hcnJheSp9CiAgXHRleHR7dmFyfVt5XQogICAgJj0mIFxtYXRoYmZ7ZX1fal5UXGJvbGRzeW1ib2x7XFNpZ21hfV9YXG1hdGhiZntlfV9qIFxcCiAgICAmPSYgXG1hdGhiZntlfV9qXlQoXGJvbGRzeW1ib2x7XFNpZ21hfV9YXG1hdGhiZntlfV9qKSBcXAogICAgJj0mIFxtYXRoYmZ7ZX1fal5UIFxsZWZ0KFxsYW1iZGFfaiBcbWF0aGJme2V9X2pccmlnaHQpIFxcCiAgICAmPSYgXGxhbWJkYV9qXG1hdGhiZntlfV9qXlRcbWF0aGJme2V9X2ogXFwKICAgICY9JiBcbGFtYmRhX2ouClxlbmR7ZXFuYXJyYXkqfQpCeSBjb252ZW50aW9uIHRoZSBlaWdlbnZlY3RvcnMvZWlnZW52YWx1ZXMgYXJlIG9yZGVyZWQgc28gdGhhdApcWwogIFxsYW1iZGFfMSBcZ2VxIFxsYW1iZGFfMiBcZ2VxIFxjZG90cyBcZ2VxIFxsYW1iZGFfci4KXF0KSGVuY2UsIHRoZSBmaXJzdCBlaWdlbnZlY3RvciAkXG1hdGhiZntlfV8xJCBnaXZlcyB0aGUgbGFyZ2VzdCB2YXJpYW5jZSAkXGxhbWJkYV8xJC4gSGVuY2UsIHRoaXMgaXMgdGhlIHNvbHV0aW9uIHdlIHdlcmUgbG9va2luZyBmb3IuCgotLS0KCldlIG5vdyBzd2l0Y2ggbm90YXRpb24gYW5kIGZyb20gbm93IG9ud2FyZHMgd2UgZGVub3RlICR5JCBieSAkeiQuCgpUaGUgb2JzZXJ2YXRpb25zIG9uIHRoZSBmaXJzdCBwcmluY2lwYWwgY29tcG9uZW50IChQQykgYXJlIHRoZW4gZ2l2ZW4gYnkKXFsKICAgIHpfe2kxfSA9IFxtYXRoYmZ7eH1faV5UXG1hdGhiZntlfV8xLgpcXQoKSW4gUENBIHRlcm1pbm9sb2d5IHRoZXkgYXJlIHJlZmVycmVkIHRvIGFzIHRoZSAqKnNjb3JlcyoqIG9mIHRoZSBmaXJzdCBQQy4gVGhlIGVsZW1lbnRzIGluIHRoZSBlaWdlbnZlY3RvciAkXG1hdGhiZntlfV9pJCB0aGF0IG1ha2UgdXAgdGhlIHRyYW5zZm9ybWF0aW9uIGFyZSBrbm93biBhcyB0aGUgKipsb2FkaW5ncyoqICBvZiB0aGUgZmlyc3QgUEMuCgpUaGUgZmlyc3QgUEMgaXMgdGh1cyBhIG5ldyB2YXJpYWJsZSAoY29uc3RydWN0KSB0aGF0IGhhcyB0aGUgbGFyZ2VzdCB2YXJpYW5jZSBhbW9uZyBhbGwgbGluZWFyIHRyYW5zZm9ybWF0aW9ucyBvZiB0aGUgb3JpZ2luYWwgdmFyaWFibGVzLgoKVmFyaWFiaWxpdHkgYmV0d2VlbiBvYnNlcnZhdGlvbnMgaXMgY29uc2lkZXJlZCBhcyBpbmZvcm1hdGl2ZSB0byB1bmRlcnN0YW5kIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIG9ic2VydmF0aW9ucy4KCi0tLQoKVGhlIGVxdWF0aW9uClxbCiAgXGJvbGRzeW1ib2x7XFNpZ21hfV9YXG1hdGhiZntifSA9IFxsYW1iZGFcbWF0aGJme2J9ClxdCmhhcyAkcj1cdGV4dHtyYW5rfShcYm9sZHN5bWJvbHtcU2lnbWF9X1gpJCBzb2x1dGlvbnMuIFRoZSBlaWdlbnZlY3RvcnMgYXJlIG9ydGhvbm9ybWFsLCBpLmUuClxbCiAgXGZvcmFsbCBpXG5lcSBqOiBcbWF0aGJme2V9X2leVCBcbWF0aGJme2V9X2ogPSAwIFx0ZXh0eyBhbmQgfSBpPWo6IFxtYXRoYmZ7ZX1faV5UIFxtYXRoYmZ7ZX1faiA9IDEKXF0KSGVuY2UgKGZvciAkaVxuZXEgaiQpClxbCiAgXHRleHR7Y292fVxsZWZ0W1xtYXRoYmZ7eH1eVFxtYXRoYmZ7ZX1faSxcbWF0aGJme3h9XlRcbWF0aGJme2V9X2pccmlnaHRdID0gXG1hdGhiZntlfV9pXlRcdGV4dHt2YXJ9W1xtYXRoYmZ7eH1dXG1hdGhiZntlfV9qID0gXG1hdGhiZntlfV9pXlRcYm9sZHN5bWJvbHtcU2lnbWF9X1hcbWF0aGJme2V9X2ogPSBcbWF0aGJme2V9X2leVFxsZWZ0KFxsYW1iZGFfalxtYXRoYmZ7ZX1falxyaWdodCkgPSBcbGFtYmRhX2ogXG1hdGhiZntlfV9pXlRcbWF0aGJme2V9X2ogPSAwClxdCgpJZiAkel97an09XG1hdGhiZnt4fV9pXlRcbWF0aGJme2V9X2okIGRlbm90ZXMgdGhlICRqJHRoIFBDLCB0aGVuClxbCiAgXHRleHR7Y292fVxsZWZ0W3pfaSx6X2pccmlnaHRdPVx0ZXh0e2Nvdn1cbGVmdFtcbWF0aGJme3h9XlRcbWF0aGJme2V9X2ksXG1hdGhiZnt4fV5UXG1hdGhiZntlfV9qXHJpZ2h0XSA9MCBcdGV4dHsgaWYgfSBpXG5lcSBqClxdClxbCiAgXHRleHR7dmFyfVxsZWZ0W3pfalxyaWdodF0gPSBcbGFtYmRhX2ogLgpcXQpXZSBzYXkgdGhhdCB0aGUgJGokdGggUEMgbWF4aW1pc2VzIHRoZSB2YXJpYW5jZSBhbW9uZyBhbGwgbGluZWFyIHRyYW5zZm9ybWF0aW9ucyBzdWNoIHRoYXQgaXQgaXMgdW5jb3JyZWxhdGVkIHdpdGggdGhlIHByZXZpb3VzIFBDcy4KCi0tLQoKIyMjIEludGVycHJldGF0aW9uIG9mIFBDQQoKQSBQQ0EgaXMgYSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgb3JpZ2luYWwgJHAkIHZhcmlhYmxlcyB0byAkciQgUENzIHN1Y2ggdGhhdAoKLSB0aGUgZmlyc3QgUEMgaGFzIGxhcmdlc3QgdmFyaWFuY2UsIGVxdWFsIHRvIGZpcnN0IGVpZ2VudmFsdWUgb2YgJFxib2xkc3ltYm9se1xTaWdtYX1fWCQKCi0gIHRoZSBuZXh0IFBDcyBoYXZlIGRlY3JlYXNpbmcgdmFyaWFuY2VzIChkZWNyZWFzaW5nIGluZm9ybWF0aW9uIGNvbnRlbnQpCgotIGFsbCBQQ3MgYXJlIG11dHVhbGx5IHVuY29ycmVsYXRlZCAobm8gaW5mb3JtYXRpb24tb3ZlcmxhcCkuCgotLS0KCiMjIExpbmsgd2l0aCBTVkQKCklmIHdlIHdyaXRlIHRoZSBlaWdlbiB2YWx1ZSBkZWNvbXBvc2l0aW9uIGluIG1hdHJpeCBmb3JtOgpcWwpcYm9sZHN5bWJvbHtcU2lnbWF9X1hcbWF0aGJmewogIEJ9ID0gXG1hdGhiZntCfVxib2xkc3ltYm9se1xMYW1iZGF9LgpcXQoKd2l0aCAkXGJvbGRzeW1ib2x7XExhbWJkYX0kIGlzIGEgZGlhZ29uYWwgbWF0cml4IHdpdGggZGlhZ29uYWwgZWxlbWVudHMgJFtcbGFtYmRhX2ldX3tpaX0kLgoKV2UgcmVjb2duaXNlIGFuIGV4cHJlc3Npb24gdGhhdCB3ZSBoYXZlIHNlZW4gd2hlbiBkaXNjdXNzaW5nIHRoZSBsaW5rIGJldHdlZW4gdGhlIFNWRCBhbmQgdGhlIHNhbXBsZSBjb3ZhcmlhbmNlIG1hdHJpeAoKXGJlZ2lue2VxbmFycmF5fQpcbWF0aGJme1h9XlRcbWF0aGJme1h9XG1hdGhiZntWfSAmPSZcbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhfV4yClxlbmR7ZXFuYXJyYXl9CgotIFNvLCB0aGUgU1ZEIGNhbiBiZSB1c2VkIHRvIHNvbHZlIHRoZSBzcGVjdHJhbCBkZWNvbXBvc2l0aW9uIChlaWdlbiB2YWx1ZSBlaWdlbiB2ZWN0b3IpIHByb2JsZW0gYW5kIHRoZSBlaWdlbiB2ZWN0b3JzIGNvaW5jaWRlIHdpdGggdGhlIHJpZ2h0IHNpbmd1bGFyIHZlY3RvcnMgYW5kIHRoZSBlaWdlbiB2YWx1ZXMgYXJlIHRoZSBzaW5ndWxhciB2YWx1ZXMgc3F1YXJlZCEKCiMjIENvbnNlcnZhdGlvbiBvZiB2YXJpYW5jZQoKLSBUaGUgdG90YWwgdmFyaWFuY2UgaW4gYSBkYXRhIHNldCAkXG1hdGhiZntYfSQgaXMgZ2l2ZW4gYnkgdGhlIHN1bSBvZiB0aGUgdmFyaWFuY2VzIG9mIHRoZSB2YXJpYWJsZXMsCiAgXFsKICAgIFxzaWdtYV4yX3tcdGV4dHt0b3R9fSA9IFxzdW1fe2o9MX1ecCBcdGV4dHt2YXJ9XGxlZnRbWF9qXHJpZ2h0XSA9IFx0ZXh0e3RyYWNlfShcYm9sZHN5bWJvbHtcU2lnbWF9X1gpCiAgXF0KCgotICBGb3IgYSBzeW1tZXRyaWMgbWF0cml4IGl0IGhvbGRzIHRoYXQKICBcWwogICAgXHRleHR7dHJhY2V9KFxib2xkc3ltYm9se1xTaWdtYX1fWCkgPSBcc3VtX3tqPTF9XnIgXGxhbWJkYV9yLgogIFxdCgotICBTaW5jZSAkXGxhbWJkYV9yPVx0ZXh0e3Zhcn1cbGVmdFtaX2pccmlnaHRdJCwgd2UgZmluZAogIFxbCiAgICBcc2lnbWFeMl97XHRleHR7dG90fX0gPSBcc3VtX3tqPTF9XnAgXHRleHR7dmFyfVxsZWZ0W1hfalxyaWdodF09IFxzdW1fe2o9MX1eciBcdGV4dHt2YXJ9XGxlZnRbWl9qXHJpZ2h0XS4KICBcXQoKJFxsb25ncmlnaHRhcnJvdyQgICBUaHVzIG5vIGluZm9ybWF0aW9uIGlzIGxvc3QgYnkgdGhlIFBDQSB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCAkcCQtZGltZW5zaW9uYWwgc3BhY2UgdG8gdGhlICRyJC1kaW1lbnNpb25hbCBQQ0Egc3BhY2UuCgotLS0KCiMjIENob29zaW5nIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucwoKRm9yIFBDQSB0aGUgcmVhc29uaW5nIGlzIHVzdWFsbHkgYmFzZWQgb24gdGhlIHJlbGF0aXZlIHZhcmlhbmNlIG9mIGEgUEMsClxbCiAgIFxmcmFje1x0ZXh0e3Zhcn1cbGVmdFtaX2pccmlnaHRdfXtcc2lnbWFeMl97XHRleHR7dG90fX19ID0gXGZyYWN7XGxhbWJkYV9qfXtcc3VtX3tpPTF9XnIgXGxhbWJkYV9pfSA9XGZyYWN7XGRlbHRhX2peMn17XHN1bV97aT0xfV5yIFxkZWx0YV9pXjJ9IC4KXF0KSWYgdGhlIGZpcnN0ICRrJCBQQ3MgYXJlIHNlbGVjdGVkIGZvciBmdXJ0aGVyIHVzZSwgdGhlbiB0aGV5IHJlcHJlc2VudApcWwogIDEwMCBcdGltZXMgIFxmcmFje1xzdW1fe2o9MX1eayBcbGFtYmRhX2p9e1xzdW1fe2k9MX1eciBcbGFtYmRhX2l9IFwlCiAgPSAxMDAgXHRpbWVzICBcZnJhY3tcc3VtX3tqPTF9XmsgXGRlbHRhXjJfan17XHN1bV97aT0xfV5yIFxkZWx0YV9pXjJ9IFwlClxdCm9mIHRoZSB0b3RhbCB2YXJpYW5jZSAob3IgaW5mb3JtYXRpb24pIG9mIHRoZSBvcmlnaW5hbCBkYXRhIHNldCAkXG1hdGhiZntYfSQuCgojIyMgVUsgZXhhbXBsZQoKQSBzY3JlZSBwbG90IGlzIG9mdGVuIHVzZWQgdG8gbG9vayBhdCB0aGUgZWlnZW52YWx1ZXMuIEhlcmUgaXQgaXMgc2hvd24gZm9yIHRoZSBVSyBjb25zdW1wdGlvbiBkYXRhLgoKYGBge3J9Cm4gPC0gbnJvdyhYKQpyIDwtIG5jb2woc3ZkVWskdikKdG90VmFyIDwtIHN1bShzdmRVayRkXjIpLyhuLTEpCnZhcnMgPC0gZGF0YS5mcmFtZShjb21wPTE6NCx2YXI9c3ZkVWskZF4yLyhuLTEpKSAlPiUKICBtdXRhdGUocHJvcFZhcj12YXIvdG90VmFyLGN1bVZhcj1jdW1zdW0odmFyL3RvdFZhcikpCgpwVmFyMSA8LSB2YXJzICU+JQogIGdncGxvdChhZXMoeD1jb21wOnIseT12YXIpKSArCiAgZ2VvbV9wb2ludCgpICsKICBnZW9tX2xpbmUoKSArCiAgeGxhYigiQ29tcG9uZW50IikgKwogIHlsYWIoIlZhcmlhbmNlIikKCnBWYXIyIDwtIHZhcnMgJT4lCiAgZ2dwbG90KGFlcyh4PWNvbXA6cix5PXByb3BWYXIpKSArCiAgZ2VvbV9wb2ludCgpICsKICBnZW9tX2xpbmUoKSArCiAgeGxhYigiQ29tcG9uZW50IikgKwogIHlsYWIoIlByb3BvcnRpb24gb2YgVG90YWwgVmFyaWFuY2UiKQoKcFZhcjMgPC0gdmFycyAlPiUKICBnZ3Bsb3QoYWVzKHg9Y29tcDpyLHk9Y3VtVmFyKSkgKwogIGdlb21fcG9pbnQoKSArCiAgZ2VvbV9saW5lKCkgKwogIHhsYWIoIkNvbXBvbmVudCIpICsKICB5bGFiKCJDdW0uIHByb3AuIG9mIHRvdC4gdmFyLiIpCgpncmlkLmFycmFuZ2UocFZhcjEsIHBWYXIyLCBwVmFyMywgbnJvdz0xKQpgYGAKCkZyb20gdGhlc2UgZ3JhcGhzIHdlIG1heSBjb25jbHVkZSB0aGF0IHdpdGggdXNpbmcgayA9IDIgZGltZW5zaW9ucywgbW9yZSB0aGFuIDk1JSBvZiB0aGUgdG90YWwgdmFyaWFuY2UgaXMgcmV0YWluZWQuCgotLS0KCiMjIyBDaG9vc2luZyB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgU1ZECgpNb3JlIGdlbmVyYWxseSwgc2NyZWUgcGxvdHMgYXJlIGFsc28gaW5mb3JtYXRpdmUgZm9yIHRoZSBTVkQuCgoKICBUaGUgbW90aXZhdGlvbiBjb21lcyBmcm9tCiAgXFsKICAgIFx0ZXh0e01pbn1fe0E6IFx0ZXh0e3Jhbmt9KEEpPWt9IFxWZXJ0IFxtYXRoYmZ7WH0gLSBcbWF0aGJme0F9XFZlcnRfRl4yID0gXFZlcnQgXG1hdGhiZntYfSAtIFxtYXRoYmZ7WH1fa1xWZXJ0X0ZeMiA9IFxzdW1fe2o9aysxfV5yXGRlbHRhX3tqfV4yID0gXHN1bV97aj1rKzF9XnJcbGFtYmRhX3tqfS4KICBcXQogIFRoaXMgaXMga25vd24gYXMgdGhlICoqYXBwcm94aW1hdGlvbiBlcnJvcioqIG9mIHRoZSBtYXRyaXggJFxtYXRoYmZ7WH1fayQuCgogIEhlbmNlLAogIFxbCiAgICBcZnJhY3tcc3VtX3tqPTF9XmtcZGVsdGFfal4yfXtcc3VtX3tqPTF9XnIgXGRlbHRhX2peMn0gID1cZnJhY3tcc3VtX3tqPTF9XmtcbGFtYmRhX3tqfX17XHN1bV97aj0xfV5yXGxhbWJkYV97an19CiAgXF0KICBzdGlsbCBtYWtlcyBzZW5zZSBhcyBhIHJlbGF0aXZlIHF1YWxpdHkgbWVhc3VyZSBmb3IgdGhlIFNWRCBpbiBnZW5lcmFsIChpbmNsdWRpbmcgbWF0cml4IGFwcHJveGltYXRpb24gYW5kIE1EUykuCgojIyMgUnVsZXMgb2YgdGh1bWIgdG8gc2VsZWN0IG51bWJlciBvZiBkaW1lbnNpb25zCgpTZWxlY3QgayBzdWNoIHRoYXQKCi0gYXQgbGVhc3QgODAlIG9mIHRoZSB0b3RhbCB2YXJpYW5jZSBpcyByZXRhaW5lZCBpbiB0aGUgUEMgc3BhY2UsIG9yLCBlcXVpdmFsZW50bHksIGF0Cm1vc3QgMjAlIHJlbGF0aXZlIGFwcHJveGltYXRpb24gZXJyb3IKCi0gYWRkaW5nIG1vcmUgZGltZW5zaW9ucyBkb2VzIG5vdCBhZGQgbW9yZSBpbmZvcm1hdGlvbiAoaW4gYSByZWxhdGl2ZSBzZW5zZSk7IHRoaXMgY2FuIG9mdGVuIGJlIHZpc3VhbGx5IGRldGVjdGVkIGFzIHRoZSDigJxrbmVl4oCdIG9yIOKAnGVsYm934oCdIGluIHRoZSBzY3JlZSBwbG90CgotIG5vbmUgb2YgdGhlIGRpbWVuc2lvbnMgaGFzIGEgdmFyaWFuY2Ugc21hbGxlciB0aGFuIHRoZSB2YXJpYW5jZSBvZiBvbmUgb2YgdGhlIHAgb3JpZ2luYWwgdmFyaWFibGVzICh0aGlzIHJ1bGUgaXMgdHlwaWNhbGx5IG9ubHkgdXNlZCB3aGVuIHRoZSB2YXJpYWJsZXMgYXJlIGZpcnN0IHN0YW5kYXJkaXNlZCAtIHNlZSBsYXRlcikuCgojIyBDb3ZhcmlhbmNlIHZzIENvcnJlbGF0aW9uIE1hdHJpeAoKIyMjIERpcmVjdGlvbiBvZiBsYXJnZXN0IHZhcmlhYmlsaXR5CgogTm93IHRoYXQgd2Uga25vdyBob3cgdGhlIFBDcyBhcmUgY29uc3RydWN0ZWQsIHdlIGNhbiBnaXZlIGFuIGFkZGl0aW9uYWwgaW50ZXJwcmV0YXRpb24gdG8gdGhlIGZpcnN0IGVpZ2VudmVjdG9yIC8gcmlnaHQtc2luZ3VsYXIgdmVjdG9yIG9mICRcYm9sZHN5bWJvbHtcU2lnbWF9X1gkLgoKLSBUaGUgZmlyc3QgZWlnZW52ZWN0b3Igb2YgJFxib2xkc3ltYm9se1xTaWdtYX1fWCQgaXMgdGhlIGRpcmVjdGlvbiBpbiB0aGUgb3JpZ2luYWwgJHAkLWRpbWVuc2lvbmFsIHNwYWNlIG9mIHRoZSBsYXJnZXN0IHZhcmlhYmlsaXR5LgoKLSBUaGUgc2Vjb25kIGVpZ2VudmVjdG9yIG9mICRcYm9sZHN5bWJvbHtcU2lnbWF9X1gkIGlzIHRoZSBkaXJlY3Rpb24gaW4gdGhlIG9yaWdpbmFsICRwJC1kaW1lbnNpb25hbCBzcGFjZSBvZiB0aGUgc2Vjb25kIGxhcmdlc3QgdmFyaWFiaWxpdHksIGFtb25nIGFsbCBkaXJlY3Rpb25zIG9ydGhvZ29uYWwgdG8gdGhlIGZpcnN0IGVpZ2VudmVjdG9yCgojIyMjIElyaXMgZXhhbXBsZQoKVGhlIGlyaXMgZGF0YXNldCBpbiBSIGNvbnRhaW5zIGluZm9ybWF0aW9uIG9uIGxlYXZlcyBvZiBpcmlzIGZsb3dlcnMgZnJvbSBkaWZmZXJlbnQgc3BlY2llcy4KSGVyZSwgd2Ugd2lsbCBmb2N1cyBvbiB0aGUgc2V0b3NhIHNwZWNpZXMgYW5kIG9uIHRoZSBzZXBhbCBsZW5ndGggYW5kIHNlcGFsIHdpZHRoLgoKYGBge3J9CmlyaXNTZXRvc2EgPC0gaXJpcyAlPiUKICBmaWx0ZXIoU3BlY2llcyA9PSAic2V0b3NhIikgJT4lCiAgZHBseXI6OnNlbGVjdCgiU2VwYWwuTGVuZ3RoIiwiU2VwYWwuV2lkdGgiKQoKbklyaXMgPC0gbnJvdyhpcmlzU2V0b3NhKQpoSXJpcyA8LSBkaWFnKG5JcmlzKSAtIG1hdHJpeCgxL25JcmlzLCBuSXJpcywgbklyaXMpCmlyaXNYIDwtIGlyaXNTZXRvc2EgJT4lCiAgYXMubWF0cml4CmlyaXNYIDwtIGhJcmlzICUqJSBpcmlzWAoKaXJpc1N2ZCA8LSBzdmQoaXJpc1gpCgpwSXJpcyA8LSBpcmlzWCAlPiUKICBhcy5kYXRhLmZyYW1lICU+JQogIGdncGxvdChhZXMoeD1TZXBhbC5MZW5ndGgseT1TZXBhbC5XaWR0aCkpICsKICBnZW9tX3BvaW50KCkKCnBJcmlzIDwtIHBJcmlzICsKICBnZW9tX3NlZ21lbnQoCiAgICBhZXMoCiAgICAgIHggPSAwLAogICAgICB5ID0gMCwKICAgICAgeGVuZCA9IC1pcmlzU3ZkJHZbMSwxXSppcmlzU3ZkJGRbMV0vc3FydChuSXJpcy0xKSwKICAgICAgeWVuZCA9IC1pcmlzU3ZkJHZbMiwxXSppcmlzU3ZkJGRbMV0vc3FydChuSXJpcy0xKQogICAgICApLAogICAgICBhcnJvdyA9IGFycm93KGxlbmd0aD11bml0KDAuNCwiY20iKSkKICAgICkgKwogIGdlb21fc2VnbWVudCgKICAgIGFlcygKICAgICAgeCA9IDAsCiAgICAgIHkgPSAwLAogICAgICB4ZW5kID0gaXJpc1N2ZCR2WzEsMl0qaXJpc1N2ZCRkWzJdL3NxcnQobklyaXMtMSksCiAgICAgIHllbmQgPSBpcmlzU3ZkJHZbMiwyXSppcmlzU3ZkJGRbMl0vc3FydChuSXJpcy0xKQogICAgICApLAogICAgYXJyb3cgPSBhcnJvdyhsZW5ndGg9dW5pdCgwLjQsImNtIikpCiAgICApICsKICBnZW9tX3RleHQoCiAgICBhZXMoCiAgICAgIHggPSAtaXJpc1N2ZCR2WzEsMV0qaXJpc1N2ZCRkWzFdL3NxcnQobklyaXMtMSkqMS4yLAogICAgICB5ID0gLWlyaXNTdmQkdlsyLDFdKmlyaXNTdmQkZFsxXS9zcXJ0KG5JcmlzLTEpKjEuMiwKICAgICAgbGFiZWw9ImUxIgogICAgICApCiAgICApICsKICBnZW9tX3RleHQoCiAgICBhZXMoCiAgICAgIHggPSBpcmlzU3ZkJHZbMSwyXSppcmlzU3ZkJGRbMl0vc3FydChuSXJpcy0xKSoxLjIsCiAgICAgIHkgPSBpcmlzU3ZkJHZbMiwyXSppcmlzU3ZkJGRbMl0vc3FydChuSXJpcy0xKSoxLjIsCiAgICAgIGxhYmVsPSJlMiIKICAgICAgKQogICAgKSArCiAgeGxpbSgtMSwgMSkgKwogIHlsaW0oLTEsMSkKCnBJcmlzCmBgYAoKIyMjIENvdmFyaWFuY2UgdmVyc3VzIGNvcnJlbGF0aW9uIG1hdHJpeApTbyBmYXIgd2UgaGF2ZSB3b3JrZWQgd2l0aAoKLSB0aGUgY29sdW1uLWNlbnRlcmVkIGRhdGEgbWF0cml4ICRcbWF0aGJme1h9JAoKLSB0aGUgU1ZEIG9mICRcbWF0aGJme1h9JCBhbmQgJFxib2xkc3ltYm9se1xTaWdtYX1fWFxwcm9wdG8gXG1hdGhiZntYfV5UXG1hdGhiZntYfSQgKHRoZSBjb3ZhcmlhbmNlIG1hdHJpeCkuCgpJbiBzb21lIHNpdHVhdGlvbnMgaXQgaXMgYmV0dGVyIHRvIHN0YXJ0IGZyb20gdGhlIHN0YW5kYXJkaXNlZCB2YXJpYWJsZXM6CgotIHN1YnN0cmFjdCBmcm9tIGVhY2ggZWxlbWVudCBpbiAkXG1hdGhiZntYfSQgdGhlICBjb2x1bW4tbWVhbgotIGRpdmlkZSBlYWNoIGNlbnRlcmVkIGVsZW1lbnQgaW4gJFxtYXRoYmZ7WH0kIGJ5IHRoZSBjb2x1bW4tc3BlY2lmaWMgc3RhbmRhcmQgZGV2aWF0aW9uCgpUaHVzIGVhY2ggZWxlbWVudCAkeF97aWp9JCBpcyByZXBsYWNlZCB3aXRoCiAgXFsKICAgICBcZnJhY3t4X3tpan0tXGJhcnt4fV9qfXtzX2p9ICwKICBcXQp3aXRoICRcYmFye3h9X2okIGFuZCAkc19qJCB0aGUgY29sdW1uIG1lYW4gYW5kIGNvbHVtbiBzdGFuZGFyZCBkZXZpYXRpb24uCgotICAgSW4gbWF0cml4IG5vdGF0aW9uLCB0aGUgc3RhbmRhcmRpc2F0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBjZW50ZXJlZCBtYXRyaXggJFxtYXRoYmZ7WH0kIGlzIGNvbXB1dGVkIGFzCiAgXFsKICAgICAgXG1hdGhiZntYfVxtYXRoYmZ7U31ee1xwcmltZS0xfQogIFxdCiAgd2hlcmUgJFxtYXRoYmZ7U31eXHByaW1lJCBpcyBhIGRpYWdvbmFsIG1hdHJpeCB3aXRoIHRoZSBjb2x1bW4tc3BlY2lmaWMgc3RhbmRhcmQgZGV2aWF0aW9ucy4KCi0tLQoKIyMjIyBJcmlzIEV4YW1wbGUKYGBge3J9CnZhcihpcmlzWCkKU3ByaW1lIDwtIGRpYWcoc3FydChkaWFnKHZhcihpcmlzWCkpKSkKWHMgPC0gaXJpc1glKiVzb2x2ZShTcHJpbWUpCnZhcihYcykKYGBgCgpNdWNoIGZhc3RlciB0byB1c2UgdGhlIHNjYWxlIGZ1bmN0aW9uLiBCeSBkZWZhdWx0IGNlbnRlcj1UUlVFIGFuZCBzY2FsZT1UUlVFLgoKYGBge3J9ClhzIDwtIGlyaXNTZXRvc2EgJT4lIHNjYWxlCnZhcihYcykKYGBgCgpTaG93IHByb2JsZW0gb2YgZGlmZmVyZW50IHVuaXRzOgoKLSBTZXBhbCBsZW5ndGggaW4gY20KLSBTZXBhbCB3aWR0aCAgaW4gbW0KCmBgYHtyfQppcmlzWDIgPC0gaXJpc1gKaXJpc1gyWywyXSA8LSBpcmlzWDJbLDJdKjEwCgpwSXJpczIgPC0gaXJpc1gyICU+JQogIGFzLmRhdGEuZnJhbWUgJT4lCiAgZ2dwbG90KGFlcyh4PVNlcGFsLkxlbmd0aCx5PVNlcGFsLldpZHRoKSkgKwogIGdlb21fcG9pbnQoKQoKaXJpc1N2ZDIgPC0gc3ZkKGlyaXNYMikKCnBJcmlzMiA8LSBwSXJpczIgKwogIGdlb21fc2VnbWVudCgKICAgIGFlcygKICAgICAgeCA9IDAsCiAgICAgIHkgPSAwLAogICAgICB4ZW5kID0gaXJpc1N2ZDIkdlsxLDFdKmlyaXNTdmQyJGRbMV0vc3FydChuSXJpcy0xKSwKICAgICAgeWVuZCA9IGlyaXNTdmQyJHZbMiwxXSppcmlzU3ZkMiRkWzFdL3NxcnQobklyaXMtMSkKICAgICAgKSwKICAgICAgYXJyb3cgPSBhcnJvdyhsZW5ndGg9dW5pdCgwLjQsImNtIikpCiAgICApICsKICBnZW9tX3NlZ21lbnQoCiAgICBhZXMoCiAgICAgIHggPSAwLAogICAgICB5ID0gMCwKICAgICAgeGVuZCA9IGlyaXNTdmQyJHZbMSwyXSppcmlzU3ZkMiRkWzJdL3NxcnQobklyaXMtMSksCiAgICAgIHllbmQgPSBpcmlzU3ZkMiR2WzIsMl0qaXJpc1N2ZDIkZFsyXS9zcXJ0KG5JcmlzLTEpCiAgICAgICksCiAgICBhcnJvdyA9IGFycm93KGxlbmd0aD11bml0KDAuNCwiY20iKSkKICAgICkgKwogIGdlb21fdGV4dCgKICAgIGFlcygKICAgICAgeCA9IGlyaXNTdmQyJHZbMSwxXSppcmlzU3ZkMiRkWzFdL3NxcnQobklyaXMtMSkqMS4yLAogICAgICB5ID0gaXJpc1N2ZDIkdlsyLDFdKmlyaXNTdmQyJGRbMV0vc3FydChuSXJpcy0xKSoxLjIsCiAgICAgIGxhYmVsPSJlMSIKICAgICAgKQogICAgKSArCiAgZ2VvbV90ZXh0KAogICAgYWVzKAogICAgICB4ID0gaXJpc1N2ZDIkdlsxLDJdKmlyaXNTdmQyJGRbMl0vc3FydChuSXJpcy0xKSoxLjIsCiAgICAgIHkgPSBpcmlzU3ZkMiR2WzIsMl0qaXJpc1N2ZDIkZFsyXS9zcXJ0KG5JcmlzLTEpKjEuMiwKICAgICAgbGFiZWw9ImUyIgogICAgICApCiAgICApICsKICB4bGltKC0xMCwgMTApICsKICB5bGltKC0xMCwxMCkKCmdyaWQuYXJyYW5nZShwSXJpcywgcElyaXMyKQpgYGAKClRvcDogb3JpZ2luYWwgbWF0cml4IC0tIEJvdHRvbTogc2Vjb25kIGNvbHVtbiBvZiAkXG1hdGhiZntYfSQgbXVsdGlwbGllZCBieSAxMCAoZS5nLiBtb3ZpbmcgZnJvbSBjbSB0byBtbSkuCgpEaXJlY3Rpb25zIG9mIG1heGltYWwgdmFyaWFiaWxpdHkgYXJlIGFmZmVjdGVkIGJ5IHRoZSB1bml0cyBvZiB0aGUgdmFyaWFibGVzLgoKLS0tCgojIyMgUmVjb21tZW5kYXRpb25zCgpXaGVuIHRvIHVzZSBjb3JyZWxhdGlvbiBhbmQgd2hlbiBjb3ZhcmlhbmNlPwoKLSB1c2UgY29ycmVsYXRpb24gd2hlbiBjb2x1bW5zIG9mICRcbWF0aGJme1h9JCBhcmUgZXhwcmVzc2VkIGluIGRpZmZlcmVudCB1bml0cwoKLSB1c2UgY292YXJpYW5jZSB3aGVuIGNvbHVtbnMgb2YgJFxtYXRoYmZ7WH0kIGFyZSBleHByZXNzZWQgaW4gdGhlIHNhbWUgdW5pdHMuCgpUaGVyZSBtYXkgYmUgZXhjZXB0aW9ucy4KCi0tLQoKIyMgUENBIGFuZCB0aGUgTXVsdGl2YXJpYXRlIE5vcm1hbCBEaXN0cmlidXRpb24KClRoZSBkZW5zaXR5IGZ1bmN0aW9uIG9mIGEgbXVsdGl2YXJpYXRlIG5vcm1hbCBkaXN0cmlidXRpb24gKE1WTikgaXMgZ2l2ZW4gYnkKXFsKICBmKFxtYXRoYmZ7eH0pID0gKDJccGkpXnstcC8yfVx2ZXJ0IFxib2xkc3ltYm9se1xTaWdtYX1cdmVydF57LTEvMn0gXGV4cFxsZWZ0KCAtXGZyYWN7MX17Mn0gKFxtYXRoYmZ7eH0tXGJvbGRzeW1ib2x7XG11fSleVCBcYm9sZHN5bWJvbHtcU2lnbWF9XnstMX0gKFxtYXRoYmZ7eH0tXGJvbGRzeW1ib2x7XG11fSlccmlnaHQpICwKXF0Kd2hlcmUKCi0gJFxib2xkc3ltYm9se1xtdX0kIGlzIHRoZSBtdWx0aXZhcmlhdGUgbWVhbiB2ZWN0b3IgKCRwJC1kaW1lbnNpb25hbCkuIFRoZSAkaiR0aCBlbGVtZW50IGlzICRcbXVfaiA9IFx0ZXh0e0V9XGxlZnRbWF9qXHJpZ2h0XSQKCi0gJFxib2xkc3ltYm9se1xTaWdtYX0kIGlzIHRoZSAkcCBcdGltZXMgcCQgY292YXJpYW5jZSBtYXRyaXguIFRoZSAkKGksaikkdGggZWxlbWVudCBpcyAkXHNpZ21hX3tpan09XHRleHR7Y292fVxsZWZ0W1hfaSwgWF9qXHJpZ2h0XSQuCgotLS0KClRvIGdldCBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIHRoZSBNVk4gd2UgZm9jdXMgb24gdGhlIGV4cG9uZW50aWFsIHdoaWNoIGhhcyB0aGUgZmFjdG9yClxbCiAgICAoXG1hdGhiZnt4fS1cYm9sZHN5bWJvbHtcbXV9KV5UIFxib2xkc3ltYm9se1xTaWdtYX1eey0xfSAoXG1hdGhiZnt4fS1cYm9sZHN5bWJvbHtcbXV9KQpcXQpUaGlzIGZhY3RvcgoKLSBpcyB0aGUgb25seSBmYWN0b3IgaW4gdGhlIGRlbnNpdHkgZnVuY3Rpb24gdGhhdCBkZXBlbmRzIG9uICRcbWF0aGJme3h9JAoKLSBpcyBhICRcbWF0aGJme3F1YWRyYXRpY30kIGZvcm0KCi0gaXMgY29uc3RhbnQgaW4gcG9pbnRzICRcbWF0aGJme3h9JCB3aXRoIGNvbnN0YW50IGRlbnNpdHkgJGYoXG1hdGhiZnt4fSkkLgoKLS0tCgpDb25zaWRlciAkcD0yJCAoYml2YXJpYXRlIG5vcm1hbCkuIFRoZW4sIGFsbCAkXG1hdGhiZnt4fSBcaW4gXG1hdGhiYntSfV4yJCBmb3Igd2hpY2gKXFsKICAgIChcbWF0aGJme3h9LVxib2xkc3ltYm9se1xtdX0pXlQgXGJvbGRzeW1ib2x7XFNpZ21hfV57LTF9IChcbWF0aGJme3h9LVxib2xkc3ltYm9se1xtdX0pID0gXHRleHR7Y29uc3RhbnQgfSBjXjIKXF0KbGllIG9uIGFuIGVsbGlwc2Ugd2l0aCBjZW50ZXIgJFxib2xkc3ltYm9se1xtdX0kLgoKVGhlc2UgZWxsaXBzZXMgYXJlIGtub3duIGFzICoqY29uc3RhbnQgZGVuc2l0eSBlbGxpcHNlcyoqLgoKIyMjIGlyaXMgZXhhbXBsZQoKYGBge3J9CnBJcmlzICsKICBzdGF0X2VsbGlwc2UoKSArCiAgc3RhdF9lbGxpcHNlKGxldmVsPS42OCkgKwogIHN0YXRfZWxsaXBzZShsZXZlbD0uMSkKYGBgCgotLS0KCk5vdyBwbHVnIGluIHRoZSBTVkQgb2YgJFxib2xkc3ltYm9se1xTaWdtYX09XG1hdGhiZntWRFZ9XlQkLApcYmVnaW57ZXFuYXJyYXkqfQogICAoXG1hdGhiZnt4fS1cYm9sZHN5bWJvbHtcbXV9KV5UIFxib2xkc3ltYm9se1xTaWdtYX1eey0xfSAoXG1hdGhiZnt4fS1cYm9sZHN5bWJvbHtcbXV9KSAmPSYgY14yXFwKICAgKFxtYXRoYmZ7eH0tXGJvbGRzeW1ib2x7XG11fSleVCBcbWF0aGJme1ZEfV57LTF9XG1hdGhiZntWfV5UIChcbWF0aGJme3h9LVxib2xkc3ltYm9se1xtdX0pICY9JiBjXjIKXGVuZHtlcW5hcnJheSp9CgpOb3RlIHRoYXQgJFxtYXRoYmZ7eH0tXGJvbGRzeW1ib2x7XG11fSQgaXMgdGhlIGNlbnRlcmVkICRcbWF0aGJme3h9JC4gV2l0aG91dCBsb3NzIG9mIGdlbmVyYWxpdHksIHRha2UgJFxib2xkc3ltYm9se1xtdX09XG1hdGhiZnswfSQuCkhlbmNlLApcYmVnaW57ZXFuYXJyYXkqfQogICBcbWF0aGJme3h9XlQgXG1hdGhiZntWRH1eey0xfVxtYXRoYmZ7Vn1eVCBcbWF0aGJme3h9ICY9JiBjXjIgICAgXFwKICAgXGxlZnQoXG1hdGhiZnt4fV5UXG1hdGhiZntWfVxyaWdodCkgXG1hdGhiZntEfV57LTF9IFxsZWZ0KFxtYXRoYmZ7eH1eVFxtYXRoYmZ7Vn1ccmlnaHQpXlQgJj0mIGNeMiBcXAogICBcc3VtX3tqPTF9XnAgKFxtYXRoYmZ7eH1eVFxtYXRoYmZ7dn1faileMiAgLyBcZGVsdGFfaiAmPSYgY14yXFwKICAgXHN1bV97aj0xfV5wICh6X2opXjIgIC8gKGNeMlxkZWx0YV9qKSAmPSYgMS4KXGVuZHtlcW5hcnJheSp9ClRoZSBsYXN0IGVxdWF0aW9uIGlzIHRoZSBlcXVhdGlvbiBvZiBhbiBlbGxpcHNlIHdpdGggYXhlcyBwYXJhbGxlbCB0byB0aGUgYmFzaXMgb2YgJCh6XzEsXGxkb3RzLCB6X3ApJCBhbmQgd2l0aCBoYWxmIGF4aXMgbGVuZ3RocyAkY1xzcXJ0e1xsYW1iZGFfan09Y1xkZWx0YV9qJCB3aXRoICRcbGFtYmRhX2okIHRoZSAkaiR0aCBlaWdlbnZhbHVlIG9mICRcYm9sZHN5bWJvbHtcU2lnbWF9JC4KCi0tLQoKYGBge3J9CnBJcmlzICsKICBzdGF0X2VsbGlwc2UoKSArCiAgc3RhdF9lbGxpcHNlKGxldmVsPS42OCkgKwogIHN0YXRfZWxsaXBzZShsZXZlbD0uMSkKYGBgCgoKVGhpcyBncmFwaHMgc2hvd3MgJG49NTAkIGRhdGEgcG9pbnRzIG9uICRwPTIkIGRpbWVuc2lvbnMuICBUaGUgdHdvIGVsbGlwc2VzIGFyZSBjb25zdGFudCBkZW5zaXR5IGVsbGlwc2VzIGZvciB0aHJlZSBkaWZmZXJlbnQgdmFsdWVzIG9mICRjJCAoaS5lLiB0aHJlZSBkaWZmZXJlbnQgY29uc3RhbnQgZGVuc2l0aWVzKS4gVGhlIGlubmVyIGVsbGlwc2UgY29ycmVzcG9uZHMgdG8gdGhlIGxhcmdlc3QgY29uc3RhbnQgZGVuc2l0eSBhbmQgdGhlIG91dGVyIHRvIHRoZSBzbWFsbGVzdCBjb25zdGFudCBkZW5zaXR5LiBUaGUgYXJyb3dzIHNob3cgdGhlIHR3byBlaWdlbnZlY3RvcnMgLyAgc2luZ3VsYXIgdmVjdG9ycyBhbmQgdGhleSBhcmUgc2NhbGVkIGFjY29yZGluZyB0byB0aGUgc3FydCBvZiB0aGUgZWlnZW4gdmFsdWVzIGFuZCB0aGV5IGZvcm0gdGhlIGF4ZXMgb2YgdGhlIGNvbnN0YW50IGRlbnNpdHkgZWxsaXBzZXMuIEl0IGlzIGNsZWFyIHRoYXQgdGhlIGZpcnN0IGF4aXMgaXMgcG9pbnRpbmcgdG8gdGhlIGxhcmdlciB2YXJpYW5jZS4KCiMjIEJpcGxvdAoKLSAgQmVjYXVzZSBvZiB0aGUgY2xvc2UgY29ubmVjdGlvbiBiZXR3ZWVuIFBDQSBhbmQgdGhlIFNWRCwgdGhlIGJpcGxvdCBhcyBkaXNjdXNzZWQgYmVmb3JlIGlzIHN0aWxsIG1lYW5pbmdmdWwsIHdpdGggdGhlIGZpcnN0IGF4aXMgcG9pbnRpbmcgaW50byB0aGUgZGlyZWN0aW9uIG9mIGxhcmdlc3QgdmFyaWFuY2UuCgojIyBPdmFyaWFuIENhbmNlciBFeGFtcGxlCgpUaGUgb3ZhcmlhbiBjYW5jZXIgZGF0YSBzZXQgY29uc2lzdHMgb2YgcHJvdGVvbWljcyBkYXRhIGZvciAyMTYgcGF0aWVudHMsIDEyMSBvZiB3aG9tIGhhdmUgb3ZhcmlhbiBjYW5jZXIsIGFuZCA5NSBvZiB3aG9tIGRvIG5vdC4gRm9yIGVhY2ggc3ViamVjdCwgdGhlIGV4cHJlc3Npb24gb2YgNDAwMCBzcGVjdHJhbCBmZWF0dXJlcyBpcyBhc3Nlc3NlZC4KVGhlIGZpcnN0IDEyMSByb3dzIGNvbnNpc3Qgb2YgZGF0YSBmb3IgdGhlIGNhbmNlciBwYXRpZW50cy4KCiMjIyBJbXBvcnRpbmcgdGhlIGRhdGEKCmBgYHtyfQpvdmFyaWFuIDwtIHJlYWRfY3N2KAogICJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RhdE9taWNzL0hEQTIwMjAvZGF0YS9vdmFyaWFuLmNzdiIsCiAgY29sX25hbWVzID0gRkFMU0UsCiAgY29sX3R5cGVzID0gY29scygpCikKZ3JpZC5hcnJhbmdlKAogIHFwbG90KDE6NDAwMCwKICAgIG92YXJpYW5bMSxdICU+JSB1bmxpc3QsCiAgICBnZW9tPSJsaW5lIiwKICAgIHlsYWI9ImNlbnRlcmVkIGludGVuc2l0eSIsCiAgICB4bGFiPSIiLG1haW49ImNhbmNlciIsCiAgICB5bGltPXJhbmdlKG92YXJpYW5bYygxLDIsMjAwLDIwMSksXSkpLAogIHFwbG90KDE6NDAwMCwKICAgIG92YXJpYW5bMixdICU+JSB1bmxpc3QsCiAgICBnZW9tPSJsaW5lIiwKICAgIHlsYWI9ImNlbnRlcmVkIGludGVuc2l0eSIsCiAgICB4bGFiPSIiLG1haW49ImNhbmNlciIsCiAgICB5bGltPXJhbmdlKG92YXJpYW5bYygxLDIsMjAwLDIwMSksXSkpLAogIHFwbG90KDE6NDAwMCwKICAgIG92YXJpYW5bMjAwLF0gJT4lIHVubGlzdCwKICAgIGdlb209ImxpbmUiLAogICAgeWxhYj0iY2VudGVyZWQgaW50ZW5zaXR5IiwKICAgIHhsYWI9IiIsbWFpbj0iTm9ybWFsIiwKICAgIHlsaW09cmFuZ2Uob3ZhcmlhbltjKDEsMiwyMDAsMjAxKSxdKSksCiAgcXBsb3QoMTo0MDAwLAogICAgb3ZhcmlhblsyMDAsXSAlPiUgdW5saXN0LAogICAgZ2VvbT0ibGluZSIsCiAgICB5bGFiPSJjZW50ZXJlZCBpbnRlbnNpdHkiLAogICAgeGxhYj0iIixtYWluPSJOb3JtYWwiLAogICAgeWxpbT1yYW5nZShvdmFyaWFuW2MoMSwyLDIwMCwyMDEpLF0pKSwKICBuY29sPTEKICApCmBgYAoKQ2VudGVyaW5nCgpgYGB7cn0Kb3ZhcmlhbiA8LSAgc2NhbGUob3Zhcmlhbiwgc2NhbGU9RkFMU0UpCmdyaWQuYXJyYW5nZSgKICBxcGxvdCgxOjQwMDAsCiAgICBvdmFyaWFuWzEsXSwKICAgIGdlb209ImxpbmUiLAogICAgeWxhYj0iY2VudGVyZWQgaW50ZW5zaXR5IiwKICAgIHhsYWI9IiIsbWFpbj0iY2FuY2VyIiwKICAgIHlsaW09cmFuZ2Uob3ZhcmlhbltjKDEsMiwyMDAsMjAxKSxdKSksCiAgcXBsb3QoMTo0MDAwLAogICAgb3ZhcmlhblsyLF0sCiAgICBnZW9tPSJsaW5lIiwKICAgIHlsYWI9ImNlbnRlcmVkIGludGVuc2l0eSIsCiAgICB4bGFiPSIiLG1haW49ImNhbmNlciIsCiAgICB5bGltPXJhbmdlKG92YXJpYW5bYygxLDIsMjAwLDIwMSksXSkpLAogIHFwbG90KDE6NDAwMCwKICAgIG92YXJpYW5bMjAwLF0sCiAgICBnZW9tPSJsaW5lIiwKICAgIHlsYWI9ImNlbnRlcmVkIGludGVuc2l0eSIsCiAgICB4bGFiPSIiLG1haW49Ik5vcm1hbCIsCiAgICB5bGltPXJhbmdlKG92YXJpYW5bYygxLDIsMjAwLDIwMSksXSkpLAogIHFwbG90KDE6NDAwMCwKICAgIG92YXJpYW5bMjAxLF0sCiAgICBnZW9tPSJsaW5lIiwKICAgIHlsYWI9ImNlbnRlcmVkIGludGVuc2l0eSIsCiAgICB4bGFiPSIiLG1haW49Ik5vcm1hbCIsCiAgICB5bGltPXJhbmdlKG92YXJpYW5bYygxLDIsMjAwLDIwMSksXSkpLAogIG5jb2w9MQogICkKYGBgCgoKIyMjIFNWRCBBbmFseXNpcwoKYGBge3J9CnN2ZE92YXJpYW4gPC0gc3ZkKG92YXJpYW4pCgpuT3ZhcmlhbiA8LSBucm93KG92YXJpYW4pCnIgPC0gbmNvbChzdmRPdmFyaWFuJHYpCgp0b3RWYXIgPC0gc3VtKHN2ZE92YXJpYW4kZF4yKS8obk92YXJpYW4tMSkKdmFycyA8LSBkYXRhLmZyYW1lKGNvbXA9MTpyLHZhcj1zdmRPdmFyaWFuJGReMi8obk92YXJpYW4tMSkpICU+JQogIG11dGF0ZShwcm9wVmFyPXZhci90b3RWYXIsY3VtVmFyPWN1bXN1bSh2YXIvdG90VmFyKSkKCnBWYXIyIDwtIHZhcnMgJT4lCiAgZ2dwbG90KGFlcyh4PWNvbXA6cix5PXByb3BWYXIpKSArCiAgZ2VvbV9wb2ludCgpICsKICBnZW9tX2xpbmUoKSArCiAgeGxhYigiQ29tcG9uZW50IikgKwogIHlsYWIoIlByb3BvcnRpb24gb2YgVG90YWwgVmFyaWFuY2UiKQoKcFZhcjMgPC0gdmFycyAlPiUKICBnZ3Bsb3QoYWVzKHg9Y29tcDpyLHk9Y3VtVmFyKSkgKwogIGdlb21fcG9pbnQoKSArCiAgZ2VvbV9saW5lKCkgKwogIHhsYWIoIkNvbXBvbmVudCIpICsKICB5bGFiKCJDdW0uIHByb3AuIG9mIHRvdC4gdmFyLiIpCgpncmlkLmFycmFuZ2UocFZhcjIsIHBWYXIzLCBucm93PTEpCmBgYAoKV2Ugc2VlIHRoYXQgd2UgY2FuIGV4cGxhaW4gYSBsb3Qgb2YgdGhlIHZhcmlhYmlsaXR5IHVzaW5nIGEgZmV3IFBDJ3MhCgpgYGB7cn0KWmsgPC0gc3ZkT3ZhcmlhbiR1WywxOjZdJSolZGlhZyhzdmRPdmFyaWFuJGRbMTo2XSkKY29sbmFtZXMoWmspIDwtIHBhc3RlMCgiWiIsMTo2KQpWayA8LSBzdmRPdmFyaWFuJHZbLDE6Nl0KY29sbmFtZXMoVmspIDwtIHBhc3RlMCgiViIsMTo2KQpyZWR1Y2VkIDwtIGRhdGEuZnJhbWUoWmssY2FuY2VyPWMocmVwKDEsMTIxKSxyZXAoMiw5NSkpKQoKcE92MSA8LSByZWR1Y2VkICU+JQogIGdncGxvdChhZXMoeD1aMSx5PVoyLGNvbD1jYW5jZXIpKSArCiAgZ2VvbV9wb2ludCgpICArCiAgdGhlbWUobGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiKQoKcE92MiA8LSBWayAlPiUKICBhcy5kYXRhLmZyYW1lICU+JQogIGdncGxvdChhZXMoeD0xOjQwMDAseT1WMSkpICsKICBnZW9tX2xpbmUoKSArCiAgeGxhYigiIikKCnBPdjMgPC0gVmsgJT4lCiAgYXMuZGF0YS5mcmFtZSAlPiUKICBnZ3Bsb3QoYWVzKHg9MTo0MDAwLHk9VjIpKSArCiAgZ2VvbV9saW5lKCkgKwogIHhsYWIoIiIpCgpncmlkLmFycmFuZ2UocE92MSxwT3YyLHBPdjMsbGF5b3V0X21hdHJpeCA9IHJiaW5kKGMoMSwzKSxjKDIsTkEpKSkKYGBgCgoKUmVjb25zdHJ1Y3Rpb24gb2YgcHJvZmlsZXM6CgpgYGB7cn0KaSA8LSAxCnBPdjQgPC0gcXBsb3QoMTo0MDAwLAogIG92YXJpYW5baSxdLAogIGdlb209ImxpbmUiLAogIHlsYWI9ImNlbnRlcmVkIGludGVuc2l0eSIsCiAgeGxhYj0iIixtYWluPSJDYW5jZXIiLAogIHlsaW09cmFuZ2Uob3ZhcmlhbltjKDEsMiwyMDAsMjAxKSxdKSkKCnBPdjUgPC0gcXBsb3QoMTo0MDAwLAogIFZrWywxOjJdICUqJVprW2ksMToyXSwKICBnZW9tPSJsaW5lIiwKICB5bGFiPSJjZW50ZXJlZCBpbnRlbnNpdHkiLAogIHhsYWI9IiIsbWFpbj0iUmVjb25zdHJ1Y3RlZCIsCiAgeWxpbT1yYW5nZShvdmFyaWFuW2MoMSwyLDIwMCwyMDEpLF0pKQoKCgpncmlkLmFycmFuZ2UoCiAgcE92MSArCiAgICBhbm5vdGF0ZSgicG9pbnQiLCB4ID0gcmVkdWNlZFtpLDFdLCB5ID0gcmVkdWNlZFtpLDJdLCBjb2xvdXIgPSAicmVkIixjZXg9MyksCiAgcE92MiwKICBwT3YzLAogIHBPdjQsCiAgcE92NSwKICBsYXlvdXRfbWF0cml4ID0gcmJpbmQoYygxLDIsMyksYyg0LDUsTkEpKSkKYGBgCgoKCmBgYHtyfQppIDwtIDMKcE92NCA8LSBxcGxvdCgxOjQwMDAsCiAgb3ZhcmlhbltpLF0sCiAgZ2VvbT0ibGluZSIsCiAgeWxhYj0iY2VudGVyZWQgaW50ZW5zaXR5IiwKICB4bGFiPSIiLG1haW49IkNhbmNlciIsCiAgeWxpbT1yYW5nZShvdmFyaWFuW2MoMSwyLDIwMCwyMDEpLF0pKQoKcE92NSA8LSBxcGxvdCgxOjQwMDAsCiAgVmtbLDE6Ml0gJSolWmtbaSwxOjJdLAogIGdlb209ImxpbmUiLAogIHlsYWI9ImNlbnRlcmVkIGludGVuc2l0eSIsCiAgeGxhYj0iIixtYWluPSJSZWNvbnN0cnVjdGVkIiwKICB5bGltPXJhbmdlKG92YXJpYW5bYygxLDIsMjAwLDIwMSksXSkpCgoKCmdyaWQuYXJyYW5nZSgKICBwT3YxICsKICAgIGFubm90YXRlKCJwb2ludCIsIHggPSByZWR1Y2VkW2ksMV0sIHkgPSByZWR1Y2VkW2ksMl0sIGNvbG91ciA9ICJyZWQiLGNleD0zKSwKICBwT3YyLAogIHBPdjMsCiAgcE92NCwKICBwT3Y1LAogIGxheW91dF9tYXRyaXggPSByYmluZChjKDEsMiwzKSxjKDQsNSxOQSkpKQpgYGAKCiMgQWNrbm93bGVkZ2VtZW50IHstfQoKLSBPbGl2aWVyIFRoYXMgZm9yIHNoYXJpbmcgaGlzIG1hdGVyaWFscyBvZiBBbmFseXNpcyBvZiBIaWdoIERpbWVuc2lvbmFsIERhdGEgMjAxOS0yMDIwLCB3aGljaCBJIHVzZWQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGlzIGNoYXB0ZXIuCgojIFNlc3Npb24gaW5mbyB7LX0KCjxkZXRhaWxzPjxzdW1tYXJ5PlNlc3Npb24gaW5mbzwvc3VtbWFyeT4KCmBgYHtyIHNlc3Npb25faW5mbywgZWNobz1GQUxTRSwgY2FjaGU9RkFMU0V9ClN5cy50aW1lKCkKc2Vzc2lvbmluZm86OnNlc3Npb25faW5mbygpCmBgYAoKPC9kZXRhaWxzPgo=</div>
<div class="footer">
    <hr>
    This work is licensed under the <a href= "https://creativecommons.org/licenses/by-nc-sa/4.0">
    CC BY-NC-SA 4.0</a> licence.
</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("svd.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
